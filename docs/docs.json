[
  {
    "description": "Parse the CLI arguments.",
    "tags": [
      {
        "title": "static",
        "description": null,
        "lineNumber": 2
      }
    ],
    "loc": {
      "start": {
        "line": 17,
        "column": 2
      },
      "end": {
        "line": 20,
        "column": 5
      }
    },
    "context": {
      "code": "static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli)\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }",
      "file": {
        "id": "BJ2i6eL",
        "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
        "base": "src/",
        "path": {
          "root": "",
          "dir": "src/cli",
          "base": "index.js",
          "ext": ".js",
          "name": "index"
        },
        "source": "/* eslint-env node */\n'use strict';\n\nconst FS = require('../utils/fs');\nconst Log = require('../utils/log');\nconst Liftoff = require('liftoff');\nconst Option = require('mr-doc-utils').Option;\nconst Promise = require('bluebird');\nconst Yargs = require('yargs');\nconst ViynlFS = require('vinyl-fs');\nconst _ = require('lodash');\nconst log = Log.global();\nconst pkg = require('../../package.json');\nconst rc = require('rc');\n\nclass CLI {\n  /**\n   * Parse the CLI arguments.\n   * @static\n   */\n  static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli)\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }\n  /**\n   * Create the CLI.\n   * @static\n   * @return {Liftoff} - An instance of Liftoff.\n   */\n  static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }\n  /**\n   * Launch the cli.\n   * @static\n   * @param {Object} - The parsed CLI arguments.\n   * @return {Promise<Stream>} - A promise to the stream.\n   */\n  static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }\n  /**\n   * Handles the result from the CLI.\n   * @static\n   */\n  static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const sources = source.split(',')\n      .map(path => path.trim())\n      .map(path => FS.normalize(path, rc('mrdoc', options)));\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: options.cwd }), options });\n    });\n  }\n}\n\nmodule.exports = CLI;\n",
        "ref": [
          {
            "BJ2i6eL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/cli",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "/* eslint-env node */\n'use strict';\n\nconst FS = require('../utils/fs');\nconst Log = require('../utils/log');\nconst Liftoff = require('liftoff');\nconst Option = require('mr-doc-utils').Option;\nconst Promise = require('bluebird');\nconst Yargs = require('yargs');\nconst ViynlFS = require('vinyl-fs');\nconst _ = require('lodash');\nconst log = Log.global();\nconst pkg = require('../../package.json');\nconst rc = require('rc');\n\nclass CLI {\n  /**\n   * Parse the CLI arguments.\n   * @static\n   */\n  static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli)\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }\n  /**\n   * Create the CLI.\n   * @static\n   * @return {Liftoff} - An instance of Liftoff.\n   */\n  static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }\n  /**\n   * Launch the cli.\n   * @static\n   * @param {Object} - The parsed CLI arguments.\n   * @return {Promise<Stream>} - A promise to the stream.\n   */\n  static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }\n  /**\n   * Handles the result from the CLI.\n   * @static\n   */\n  static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const sources = source.split(',')\n      .map(path => path.trim())\n      .map(path => FS.normalize(path, rc('mrdoc', options)));\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: options.cwd }), options });\n    });\n  }\n}\n\nmodule.exports = CLI;\n"
            }
          },
          {
            "BJxhiTlL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst JSONC = require('./compilers/json/');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\n// const HTML = require('./compilers/html');\n\nclass Compiler {\n  constructor(options) {\n    this.options = options;\n  }\n  factory() {\n    const format = this.options.compiler.file.format;\n    // DEBUG: Compiler format\n    log.debug(Log.color.blue('Compiler format:'), format);\n    switch (format) {\n      case 'json':\n        return (new JSONC(this.options));\n      case 'html':\n        // return (new HTML(this.options));\n      default:\n        return null;\n    }\n  }\n}\nmodule.exports = Compiler;\n"
            }
          },
          {
            "Hy-2sae8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst JavaScript = require('./parsers/javascript/');\n\nclass Parser {\n  constructor(options) {\n    this.options = options;\n  }\n  factory() {\n    switch (this.options.parser.language) {\n      case 'js':\n      case 'javascript':\n        return (new JavaScript(this.options));\n      default:\n        return null;\n    }\n  }\n}\nmodule.exports = Parser;\n"
            }
          },
          {
            "Skfhjpl8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "extension.js",
                "ext": ".js",
                "name": "extension"
              },
              "source": "'use strict';\n\nclass Extension {\n  static find(language) {\n    return Extension.extensions()[language];\n  }\n  static extensions() {\n    return {\n      js: '.js',\n      javascript: '.js',\n      json: '.json',\n      html: '.html',\n      typescript: '.ts',\n    };\n  }\n}\n\nmodule.exports = Extension;\n"
            }
          },
          {
            "H17hjpxU": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "fs.js",
                "ext": ".js",
                "name": "fs"
              },
              "source": "'use strict';\nconst Path = require('path');\nconst Extension = require('./extension');\nconst isGlob = require('is-glob');\nconst _ = require('lodash');\n\nclass FS {\n  static normalize(path, options) {\n    // Check if the path is not in glob pattern.\n    if (!isGlob(path)) {\n      // Assume that Glob is used.\n      let isFile = false;\n      // Make sure the path is resolved.\n      let str = Path.resolve(options.mrdoc.cwd, path).replace('/', Path.sep);\n      // Check if the path is a file or directory.\n      if (_.isEmpty(Path.parse(path).ext)) {\n        // Check if the path has a '/' at the end.\n        str = str[str.length - 1] === Path.sep ?\n        str : `${str}${Path.sep}`;\n      } else isFile = true;\n      // Make sure the file or directory exists;\n      if (File.existsSync(str)) {\n        if (!isFile) {\n          // Check if the directory has sub-directories.\n          const hasSubDirs = File.readdirSync(str)\n          .filter(file =>\n            File.statSync(Path.join(str, file)).isDirectory()).length > 1;\n          // Get the file extension.\n          const extension = Extension.find(options.parser.language);\n          // Set the glob pattern based on 'hasSubDirs'.\n          str = hasSubDirs ?\n          `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\n        }\n      } else return null;\n      return str;\n    }\n    return path;\n  }\n}\n\nmodule.exports = FS;\n"
            }
          },
          {
            "H1V3i6xL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "log.js",
                "ext": ".js",
                "name": "log"
              },
              "source": "/* eslint-env node */\n'use strict';\n\n/* eslint-env node */\nconst Utils = require('mr-doc-utils');\nconst log = new Utils.Log();\nconst _ = require('lodash');\n\nclass Log {\n  constructor(options) {\n    if (options.silent) {\n      log.on('error', () => { /* NOOP */});\n      return log;\n    }\n    this.levels(options.level)\n    .forEach(level => {\n      if (level === 'error') this.error();\n      else this.other(level);\n    });\n    return log;\n  }\n  levels(level) {\n    const levels = _.isString(level) ? level.split(',') : level;\n    return levels\n    .map(i => i.replace(/\\s/g, ''));\n  }\n  error() {\n    log.on('error', function error() {\n      /* eslint-disable no-console */\n      const args = Array.prototype.slice.call(arguments);\n      args.unshift(log.color.cyan('mrdoc'));\n      console.log.apply(console, args.map(i => log.color.red(i)));\n      /* eslint-enable no-console */\n    });\n  }\n  other(level) {\n    log.on(level, function logger() {\n      /* eslint-disable no-console */\n      const args = Array.prototype.slice.call(arguments);\n      args.unshift(log.color.cyan('mrdoc'));\n      console.log.apply(console, args);\n      /* eslint-enable no-console */\n    });\n  }\n  /**\n   * Get the global instance of Log.\n   * @return {Log} - An instance of Log.\n   */\n  static global() {\n    log.color = Utils.Log.color;\n    return log;\n  }\n}\n\nmodule.exports = Log;\n"
            }
          },
          {
            "B1BhjpeL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "output.js",
                "ext": ".js",
                "name": "output"
              },
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nclass Output {\n  static handler(buffer, options) {\n    return function (callback) {\n      Output.format(buffer, options).forEach(Output.toStream(this, options));\n      callback();\n    };\n  }\n  static format(buffer, options) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler.file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n  static toBuffer(buffer) {\n    return (file, enc, callback) => {\n      buffer.push(file);\n      callback();\n    };\n  }\n  static toStream(context, options) {\n    const file = options.compiler.file;\n    return function (f) {\n      if (file.format === 'json' || file.format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (file.format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "BJUhiTxI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "source.js",
                "ext": ".js",
                "name": "source"
              },
              "source": "'use strict';\nconst ShortID = require('shortid');\nconst File = require('fs-extra');\nconst _ = require('lodash');\nconst Path = require('path');\n\nclass Source {\n  static create(files) {\n    // Process the files.\n    const result = files\n    .map(file => Source.processFile(file));\n    // Create references for each file.\n    const references = result\n    .map(file => Source.createReference(file));\n    // Process the references and attach it to each file.\n    return result\n    .map(file => Source.processReference(file, references));\n  }\n  static processFile(file) {\n    return {\n      id: ShortID.generate(),\n      cwd: file.cwd,\n      base: file.base.replace(file.cwd + Path.sep, ''),\n      path: Path.parse(file.path.replace(file.cwd + Path.sep, '')),\n      source: File.readFileSync(file.path, 'utf8'),\n      comments: undefined,\n    };\n  }\n  static createReference(file) {\n    return {\n      id: file.id,\n      cwd: file.cwd,\n      base: file.base,\n      path: file.path,\n      source: file.source,\n      comments: file.comments,\n    };\n  }\n  static processReference(file, references) {\n    return _.merge(file, {\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\n    });\n  }\n}\n\nmodule.exports = Source;\n"
            }
          },
          {
            "S1vnspgI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/engines",
                "base": "javascript.js",
                "ext": ".js",
                "name": "javascript"
              },
              "source": "'use strict';\n\nconst Babylon = require('babylon');\nconst Acorn = require('acorn');\nconst Espree = require('espree');\nconst ESCodeGen = require('escodegen');\nconst ESTraverse = require('estraverse');\nconst traverse = require('babel-traverse').default;\n\nconst opts = {\n  acorn: (version, comments, tokens) => ({\n    ecmaVersion: version,\n    locations: true,\n    onComment: comments,\n    onToken: tokens,\n    ranges: true,\n  }),\n  babylon: () => ({\n    allowImportExportEverywhere: true,\n    plugins: [\n      'jsx',\n      'flow',\n      'asyncFunctions',\n      'classConstructorCall',\n      'doExpressions',\n      'trailingFunctionCommas',\n      'objectRestSpread',\n      'decorators',\n      'classProperties',\n      'exportExtensions',\n      'exponentiationOperator',\n      'asyncGenerators',\n      'functionBind',\n      'functionSent',\n    ],\n    sourceType: 'module',\n  }),\n  espree: (version) => ({\n    attachComment: true,\n    comment: true,\n    ecmaFeatures: {\n      experimentalObjectRestSpread: true,\n      globalReturn: true,\n      impliedStrict: true,\n      jsx: true,\n    },\n    ecmaVersion: version,\n    loc: true,\n    range: true,\n    sourceType: 'module',\n    tokens: true,\n  }),\n};\n\nclass Engine {\n  constructor(options) {\n    this.options = options;\n    switch (this.options.engine) {\n      case 'acorn':\n        this.engine = Acorn;\n        break;\n      case 'espree':\n        this.engine = Espree;\n        break;\n      default:\n        this.engine = Babylon;\n        break;\n    }\n  }\n  parse(file) {\n    const comments = [];\n    const tokens = [];\n    try {\n      switch (this.options.engine) {\n        case 'acorn':\n          return ESCodeGen\n          .attachComments(this.engine.parse(file.source,\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\n        case 'espree':\n          return this.engine.parse(file.source, opts.espree(this.options.version));\n        default:\n          return this.engine.parse(file.source, opts.babylon());\n      }\n    } catch (error) {\n      throw (new Error(error));\n    }\n  }\n  static traverse(options, ast, callback) {\n    switch (options.engine) {\n      case 'babylon':\n        traverse(ast, {\n          enter: (path) => {\n            const node = path.node;\n            callback(node);\n          } });\n        break;\n      default:\n        ESTraverse.traverse(ast, {\n          /* eslint-disable no-param-reassign */\n          enter: (node) => {\n            if (node.type === 'Program') {\n              node = node.body[0];\n            }\n            callback(node);\n          } });\n          /* eslint-enable no-param-reassign */\n        break;\n    }\n  }\n}\nmodule.exports = Engine;\n"
            }
          },
          {
            "r1OhoagI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "SyY2jagI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass IParser {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser;\n  }\n  /**\n   * Parses the sources' comments into the desired output.\n   * @param  {Array<Object>} results - The files to parse.\n   * @return {Array<Object>} - The parsed comments.\n   */\n  /* eslint-disable no-unused-vars */\n  parse(sources) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = IParser;\n"
            }
          },
          {
            "Bk5nsalU": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/html",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\n\nclass HTML extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.comments = comments;\n  }\n}\nmodule.exports = HTML;\n"
            }
          },
          {
            "rJi2iTgI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/json",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "SJn3oplI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers/javascript",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n"
            }
          },
          {
            "Bkphopx8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers/javascript",
                "base": "synonyms.js",
                "ext": ".js",
                "name": "synonyms"
              },
              "source": "module.exports = {\n  arg: 'param',\n  argument: 'param',\n  constructor: 'class',\n  const: 'constant',\n  defaultvalue: 'default',\n  desc: 'description',\n  emits: 'fires',\n  exception: 'throws',\n  fileoverview: 'file',\n  func: 'function',\n  host: 'external',\n  linkcode: 'link',\n  linkplain: 'link',\n  virtual: 'abstract',\n  method: 'function',\n  overview: 'file',\n  prop: 'property',\n  return: 'returns',\n  var: 'member',\n};\n"
            }
          },
          {
            "H1R3spgL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/html/engines",
                "base": "theme.js",
                "ext": ".js",
                "name": "theme"
              },
              "source": "'use strict';\n\nclass Theme {\n  // constructor() {\n  //\n  // }\n  compile() {\n\n  }\n}\n\nmodule.exports = Theme;\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 21,
          "column": 2
        },
        "end": {
          "line": 28,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          21,
          28
        ]
      }
    }
  },
  {
    "description": "Create the CLI.",
    "tags": [
      {
        "title": "static",
        "description": null,
        "lineNumber": 2
      },
      {
        "title": "returns",
        "description": "An instance of Liftoff.",
        "lineNumber": 3,
        "type": {
          "type": "NameExpression",
          "name": "Liftoff"
        }
      }
    ],
    "loc": {
      "start": {
        "line": 29,
        "column": 2
      },
      "end": {
        "line": 33,
        "column": 5
      }
    },
    "context": {
      "code": "static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }",
      "file": {
        "id": "BJ2i6eL",
        "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
        "base": "src/",
        "path": {
          "root": "",
          "dir": "src/cli",
          "base": "index.js",
          "ext": ".js",
          "name": "index"
        },
        "source": "/* eslint-env node */\n'use strict';\n\nconst FS = require('../utils/fs');\nconst Log = require('../utils/log');\nconst Liftoff = require('liftoff');\nconst Option = require('mr-doc-utils').Option;\nconst Promise = require('bluebird');\nconst Yargs = require('yargs');\nconst ViynlFS = require('vinyl-fs');\nconst _ = require('lodash');\nconst log = Log.global();\nconst pkg = require('../../package.json');\nconst rc = require('rc');\n\nclass CLI {\n  /**\n   * Parse the CLI arguments.\n   * @static\n   */\n  static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli)\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }\n  /**\n   * Create the CLI.\n   * @static\n   * @return {Liftoff} - An instance of Liftoff.\n   */\n  static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }\n  /**\n   * Launch the cli.\n   * @static\n   * @param {Object} - The parsed CLI arguments.\n   * @return {Promise<Stream>} - A promise to the stream.\n   */\n  static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }\n  /**\n   * Handles the result from the CLI.\n   * @static\n   */\n  static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const sources = source.split(',')\n      .map(path => path.trim())\n      .map(path => FS.normalize(path, rc('mrdoc', options)));\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: options.cwd }), options });\n    });\n  }\n}\n\nmodule.exports = CLI;\n",
        "ref": [
          {
            "BJ2i6eL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/cli",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "/* eslint-env node */\n'use strict';\n\nconst FS = require('../utils/fs');\nconst Log = require('../utils/log');\nconst Liftoff = require('liftoff');\nconst Option = require('mr-doc-utils').Option;\nconst Promise = require('bluebird');\nconst Yargs = require('yargs');\nconst ViynlFS = require('vinyl-fs');\nconst _ = require('lodash');\nconst log = Log.global();\nconst pkg = require('../../package.json');\nconst rc = require('rc');\n\nclass CLI {\n  /**\n   * Parse the CLI arguments.\n   * @static\n   */\n  static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli)\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }\n  /**\n   * Create the CLI.\n   * @static\n   * @return {Liftoff} - An instance of Liftoff.\n   */\n  static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }\n  /**\n   * Launch the cli.\n   * @static\n   * @param {Object} - The parsed CLI arguments.\n   * @return {Promise<Stream>} - A promise to the stream.\n   */\n  static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }\n  /**\n   * Handles the result from the CLI.\n   * @static\n   */\n  static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const sources = source.split(',')\n      .map(path => path.trim())\n      .map(path => FS.normalize(path, rc('mrdoc', options)));\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: options.cwd }), options });\n    });\n  }\n}\n\nmodule.exports = CLI;\n"
            }
          },
          {
            "BJxhiTlL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst JSONC = require('./compilers/json/');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\n// const HTML = require('./compilers/html');\n\nclass Compiler {\n  constructor(options) {\n    this.options = options;\n  }\n  factory() {\n    const format = this.options.compiler.file.format;\n    // DEBUG: Compiler format\n    log.debug(Log.color.blue('Compiler format:'), format);\n    switch (format) {\n      case 'json':\n        return (new JSONC(this.options));\n      case 'html':\n        // return (new HTML(this.options));\n      default:\n        return null;\n    }\n  }\n}\nmodule.exports = Compiler;\n"
            }
          },
          {
            "Hy-2sae8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst JavaScript = require('./parsers/javascript/');\n\nclass Parser {\n  constructor(options) {\n    this.options = options;\n  }\n  factory() {\n    switch (this.options.parser.language) {\n      case 'js':\n      case 'javascript':\n        return (new JavaScript(this.options));\n      default:\n        return null;\n    }\n  }\n}\nmodule.exports = Parser;\n"
            }
          },
          {
            "Skfhjpl8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "extension.js",
                "ext": ".js",
                "name": "extension"
              },
              "source": "'use strict';\n\nclass Extension {\n  static find(language) {\n    return Extension.extensions()[language];\n  }\n  static extensions() {\n    return {\n      js: '.js',\n      javascript: '.js',\n      json: '.json',\n      html: '.html',\n      typescript: '.ts',\n    };\n  }\n}\n\nmodule.exports = Extension;\n"
            }
          },
          {
            "H17hjpxU": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "fs.js",
                "ext": ".js",
                "name": "fs"
              },
              "source": "'use strict';\nconst Path = require('path');\nconst Extension = require('./extension');\nconst isGlob = require('is-glob');\nconst _ = require('lodash');\n\nclass FS {\n  static normalize(path, options) {\n    // Check if the path is not in glob pattern.\n    if (!isGlob(path)) {\n      // Assume that Glob is used.\n      let isFile = false;\n      // Make sure the path is resolved.\n      let str = Path.resolve(options.mrdoc.cwd, path).replace('/', Path.sep);\n      // Check if the path is a file or directory.\n      if (_.isEmpty(Path.parse(path).ext)) {\n        // Check if the path has a '/' at the end.\n        str = str[str.length - 1] === Path.sep ?\n        str : `${str}${Path.sep}`;\n      } else isFile = true;\n      // Make sure the file or directory exists;\n      if (File.existsSync(str)) {\n        if (!isFile) {\n          // Check if the directory has sub-directories.\n          const hasSubDirs = File.readdirSync(str)\n          .filter(file =>\n            File.statSync(Path.join(str, file)).isDirectory()).length > 1;\n          // Get the file extension.\n          const extension = Extension.find(options.parser.language);\n          // Set the glob pattern based on 'hasSubDirs'.\n          str = hasSubDirs ?\n          `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\n        }\n      } else return null;\n      return str;\n    }\n    return path;\n  }\n}\n\nmodule.exports = FS;\n"
            }
          },
          {
            "H1V3i6xL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "log.js",
                "ext": ".js",
                "name": "log"
              },
              "source": "/* eslint-env node */\n'use strict';\n\n/* eslint-env node */\nconst Utils = require('mr-doc-utils');\nconst log = new Utils.Log();\nconst _ = require('lodash');\n\nclass Log {\n  constructor(options) {\n    if (options.silent) {\n      log.on('error', () => { /* NOOP */});\n      return log;\n    }\n    this.levels(options.level)\n    .forEach(level => {\n      if (level === 'error') this.error();\n      else this.other(level);\n    });\n    return log;\n  }\n  levels(level) {\n    const levels = _.isString(level) ? level.split(',') : level;\n    return levels\n    .map(i => i.replace(/\\s/g, ''));\n  }\n  error() {\n    log.on('error', function error() {\n      /* eslint-disable no-console */\n      const args = Array.prototype.slice.call(arguments);\n      args.unshift(log.color.cyan('mrdoc'));\n      console.log.apply(console, args.map(i => log.color.red(i)));\n      /* eslint-enable no-console */\n    });\n  }\n  other(level) {\n    log.on(level, function logger() {\n      /* eslint-disable no-console */\n      const args = Array.prototype.slice.call(arguments);\n      args.unshift(log.color.cyan('mrdoc'));\n      console.log.apply(console, args);\n      /* eslint-enable no-console */\n    });\n  }\n  /**\n   * Get the global instance of Log.\n   * @return {Log} - An instance of Log.\n   */\n  static global() {\n    log.color = Utils.Log.color;\n    return log;\n  }\n}\n\nmodule.exports = Log;\n"
            }
          },
          {
            "B1BhjpeL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "output.js",
                "ext": ".js",
                "name": "output"
              },
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nclass Output {\n  static handler(buffer, options) {\n    return function (callback) {\n      Output.format(buffer, options).forEach(Output.toStream(this, options));\n      callback();\n    };\n  }\n  static format(buffer, options) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler.file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n  static toBuffer(buffer) {\n    return (file, enc, callback) => {\n      buffer.push(file);\n      callback();\n    };\n  }\n  static toStream(context, options) {\n    const file = options.compiler.file;\n    return function (f) {\n      if (file.format === 'json' || file.format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (file.format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "BJUhiTxI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "source.js",
                "ext": ".js",
                "name": "source"
              },
              "source": "'use strict';\nconst ShortID = require('shortid');\nconst File = require('fs-extra');\nconst _ = require('lodash');\nconst Path = require('path');\n\nclass Source {\n  static create(files) {\n    // Process the files.\n    const result = files\n    .map(file => Source.processFile(file));\n    // Create references for each file.\n    const references = result\n    .map(file => Source.createReference(file));\n    // Process the references and attach it to each file.\n    return result\n    .map(file => Source.processReference(file, references));\n  }\n  static processFile(file) {\n    return {\n      id: ShortID.generate(),\n      cwd: file.cwd,\n      base: file.base.replace(file.cwd + Path.sep, ''),\n      path: Path.parse(file.path.replace(file.cwd + Path.sep, '')),\n      source: File.readFileSync(file.path, 'utf8'),\n      comments: undefined,\n    };\n  }\n  static createReference(file) {\n    return {\n      id: file.id,\n      cwd: file.cwd,\n      base: file.base,\n      path: file.path,\n      source: file.source,\n      comments: file.comments,\n    };\n  }\n  static processReference(file, references) {\n    return _.merge(file, {\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\n    });\n  }\n}\n\nmodule.exports = Source;\n"
            }
          },
          {
            "S1vnspgI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/engines",
                "base": "javascript.js",
                "ext": ".js",
                "name": "javascript"
              },
              "source": "'use strict';\n\nconst Babylon = require('babylon');\nconst Acorn = require('acorn');\nconst Espree = require('espree');\nconst ESCodeGen = require('escodegen');\nconst ESTraverse = require('estraverse');\nconst traverse = require('babel-traverse').default;\n\nconst opts = {\n  acorn: (version, comments, tokens) => ({\n    ecmaVersion: version,\n    locations: true,\n    onComment: comments,\n    onToken: tokens,\n    ranges: true,\n  }),\n  babylon: () => ({\n    allowImportExportEverywhere: true,\n    plugins: [\n      'jsx',\n      'flow',\n      'asyncFunctions',\n      'classConstructorCall',\n      'doExpressions',\n      'trailingFunctionCommas',\n      'objectRestSpread',\n      'decorators',\n      'classProperties',\n      'exportExtensions',\n      'exponentiationOperator',\n      'asyncGenerators',\n      'functionBind',\n      'functionSent',\n    ],\n    sourceType: 'module',\n  }),\n  espree: (version) => ({\n    attachComment: true,\n    comment: true,\n    ecmaFeatures: {\n      experimentalObjectRestSpread: true,\n      globalReturn: true,\n      impliedStrict: true,\n      jsx: true,\n    },\n    ecmaVersion: version,\n    loc: true,\n    range: true,\n    sourceType: 'module',\n    tokens: true,\n  }),\n};\n\nclass Engine {\n  constructor(options) {\n    this.options = options;\n    switch (this.options.engine) {\n      case 'acorn':\n        this.engine = Acorn;\n        break;\n      case 'espree':\n        this.engine = Espree;\n        break;\n      default:\n        this.engine = Babylon;\n        break;\n    }\n  }\n  parse(file) {\n    const comments = [];\n    const tokens = [];\n    try {\n      switch (this.options.engine) {\n        case 'acorn':\n          return ESCodeGen\n          .attachComments(this.engine.parse(file.source,\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\n        case 'espree':\n          return this.engine.parse(file.source, opts.espree(this.options.version));\n        default:\n          return this.engine.parse(file.source, opts.babylon());\n      }\n    } catch (error) {\n      throw (new Error(error));\n    }\n  }\n  static traverse(options, ast, callback) {\n    switch (options.engine) {\n      case 'babylon':\n        traverse(ast, {\n          enter: (path) => {\n            const node = path.node;\n            callback(node);\n          } });\n        break;\n      default:\n        ESTraverse.traverse(ast, {\n          /* eslint-disable no-param-reassign */\n          enter: (node) => {\n            if (node.type === 'Program') {\n              node = node.body[0];\n            }\n            callback(node);\n          } });\n          /* eslint-enable no-param-reassign */\n        break;\n    }\n  }\n}\nmodule.exports = Engine;\n"
            }
          },
          {
            "r1OhoagI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "SyY2jagI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass IParser {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser;\n  }\n  /**\n   * Parses the sources' comments into the desired output.\n   * @param  {Array<Object>} results - The files to parse.\n   * @return {Array<Object>} - The parsed comments.\n   */\n  /* eslint-disable no-unused-vars */\n  parse(sources) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = IParser;\n"
            }
          },
          {
            "Bk5nsalU": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/html",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\n\nclass HTML extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.comments = comments;\n  }\n}\nmodule.exports = HTML;\n"
            }
          },
          {
            "rJi2iTgI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/json",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "SJn3oplI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers/javascript",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n"
            }
          },
          {
            "Bkphopx8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers/javascript",
                "base": "synonyms.js",
                "ext": ".js",
                "name": "synonyms"
              },
              "source": "module.exports = {\n  arg: 'param',\n  argument: 'param',\n  constructor: 'class',\n  const: 'constant',\n  defaultvalue: 'default',\n  desc: 'description',\n  emits: 'fires',\n  exception: 'throws',\n  fileoverview: 'file',\n  func: 'function',\n  host: 'external',\n  linkcode: 'link',\n  linkplain: 'link',\n  virtual: 'abstract',\n  method: 'function',\n  overview: 'file',\n  prop: 'property',\n  return: 'returns',\n  var: 'member',\n};\n"
            }
          },
          {
            "H1R3spgL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/html/engines",
                "base": "theme.js",
                "ext": ".js",
                "name": "theme"
              },
              "source": "'use strict';\n\nclass Theme {\n  // constructor() {\n  //\n  // }\n  compile() {\n\n  }\n}\n\nmodule.exports = Theme;\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 34,
          "column": 2
        },
        "end": {
          "line": 41,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          34,
          41
        ]
      }
    }
  },
  {
    "description": "Launch the cli.",
    "tags": [
      {
        "title": "static",
        "description": null,
        "lineNumber": 2
      },
      {
        "title": "param",
        "description": "The parsed CLI arguments.",
        "lineNumber": 3,
        "type": null,
        "name": "Object"
      },
      {
        "title": "returns",
        "description": "A promise to the stream.",
        "lineNumber": 4,
        "type": {
          "type": "TypeApplication",
          "expression": {
            "type": "NameExpression",
            "name": "Promise"
          },
          "applications": [
            {
              "type": "NameExpression",
              "name": "Stream"
            }
          ]
        }
      }
    ],
    "loc": {
      "start": {
        "line": 42,
        "column": 2
      },
      "end": {
        "line": 47,
        "column": 5
      }
    },
    "context": {
      "code": "static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }",
      "file": {
        "id": "BJ2i6eL",
        "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
        "base": "src/",
        "path": {
          "root": "",
          "dir": "src/cli",
          "base": "index.js",
          "ext": ".js",
          "name": "index"
        },
        "source": "/* eslint-env node */\n'use strict';\n\nconst FS = require('../utils/fs');\nconst Log = require('../utils/log');\nconst Liftoff = require('liftoff');\nconst Option = require('mr-doc-utils').Option;\nconst Promise = require('bluebird');\nconst Yargs = require('yargs');\nconst ViynlFS = require('vinyl-fs');\nconst _ = require('lodash');\nconst log = Log.global();\nconst pkg = require('../../package.json');\nconst rc = require('rc');\n\nclass CLI {\n  /**\n   * Parse the CLI arguments.\n   * @static\n   */\n  static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli)\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }\n  /**\n   * Create the CLI.\n   * @static\n   * @return {Liftoff} - An instance of Liftoff.\n   */\n  static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }\n  /**\n   * Launch the cli.\n   * @static\n   * @param {Object} - The parsed CLI arguments.\n   * @return {Promise<Stream>} - A promise to the stream.\n   */\n  static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }\n  /**\n   * Handles the result from the CLI.\n   * @static\n   */\n  static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const sources = source.split(',')\n      .map(path => path.trim())\n      .map(path => FS.normalize(path, rc('mrdoc', options)));\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: options.cwd }), options });\n    });\n  }\n}\n\nmodule.exports = CLI;\n",
        "ref": [
          {
            "BJ2i6eL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/cli",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "/* eslint-env node */\n'use strict';\n\nconst FS = require('../utils/fs');\nconst Log = require('../utils/log');\nconst Liftoff = require('liftoff');\nconst Option = require('mr-doc-utils').Option;\nconst Promise = require('bluebird');\nconst Yargs = require('yargs');\nconst ViynlFS = require('vinyl-fs');\nconst _ = require('lodash');\nconst log = Log.global();\nconst pkg = require('../../package.json');\nconst rc = require('rc');\n\nclass CLI {\n  /**\n   * Parse the CLI arguments.\n   * @static\n   */\n  static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli)\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }\n  /**\n   * Create the CLI.\n   * @static\n   * @return {Liftoff} - An instance of Liftoff.\n   */\n  static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }\n  /**\n   * Launch the cli.\n   * @static\n   * @param {Object} - The parsed CLI arguments.\n   * @return {Promise<Stream>} - A promise to the stream.\n   */\n  static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }\n  /**\n   * Handles the result from the CLI.\n   * @static\n   */\n  static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const sources = source.split(',')\n      .map(path => path.trim())\n      .map(path => FS.normalize(path, rc('mrdoc', options)));\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: options.cwd }), options });\n    });\n  }\n}\n\nmodule.exports = CLI;\n"
            }
          },
          {
            "BJxhiTlL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst JSONC = require('./compilers/json/');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\n// const HTML = require('./compilers/html');\n\nclass Compiler {\n  constructor(options) {\n    this.options = options;\n  }\n  factory() {\n    const format = this.options.compiler.file.format;\n    // DEBUG: Compiler format\n    log.debug(Log.color.blue('Compiler format:'), format);\n    switch (format) {\n      case 'json':\n        return (new JSONC(this.options));\n      case 'html':\n        // return (new HTML(this.options));\n      default:\n        return null;\n    }\n  }\n}\nmodule.exports = Compiler;\n"
            }
          },
          {
            "Hy-2sae8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst JavaScript = require('./parsers/javascript/');\n\nclass Parser {\n  constructor(options) {\n    this.options = options;\n  }\n  factory() {\n    switch (this.options.parser.language) {\n      case 'js':\n      case 'javascript':\n        return (new JavaScript(this.options));\n      default:\n        return null;\n    }\n  }\n}\nmodule.exports = Parser;\n"
            }
          },
          {
            "Skfhjpl8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "extension.js",
                "ext": ".js",
                "name": "extension"
              },
              "source": "'use strict';\n\nclass Extension {\n  static find(language) {\n    return Extension.extensions()[language];\n  }\n  static extensions() {\n    return {\n      js: '.js',\n      javascript: '.js',\n      json: '.json',\n      html: '.html',\n      typescript: '.ts',\n    };\n  }\n}\n\nmodule.exports = Extension;\n"
            }
          },
          {
            "H17hjpxU": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "fs.js",
                "ext": ".js",
                "name": "fs"
              },
              "source": "'use strict';\nconst Path = require('path');\nconst Extension = require('./extension');\nconst isGlob = require('is-glob');\nconst _ = require('lodash');\n\nclass FS {\n  static normalize(path, options) {\n    // Check if the path is not in glob pattern.\n    if (!isGlob(path)) {\n      // Assume that Glob is used.\n      let isFile = false;\n      // Make sure the path is resolved.\n      let str = Path.resolve(options.mrdoc.cwd, path).replace('/', Path.sep);\n      // Check if the path is a file or directory.\n      if (_.isEmpty(Path.parse(path).ext)) {\n        // Check if the path has a '/' at the end.\n        str = str[str.length - 1] === Path.sep ?\n        str : `${str}${Path.sep}`;\n      } else isFile = true;\n      // Make sure the file or directory exists;\n      if (File.existsSync(str)) {\n        if (!isFile) {\n          // Check if the directory has sub-directories.\n          const hasSubDirs = File.readdirSync(str)\n          .filter(file =>\n            File.statSync(Path.join(str, file)).isDirectory()).length > 1;\n          // Get the file extension.\n          const extension = Extension.find(options.parser.language);\n          // Set the glob pattern based on 'hasSubDirs'.\n          str = hasSubDirs ?\n          `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\n        }\n      } else return null;\n      return str;\n    }\n    return path;\n  }\n}\n\nmodule.exports = FS;\n"
            }
          },
          {
            "H1V3i6xL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "log.js",
                "ext": ".js",
                "name": "log"
              },
              "source": "/* eslint-env node */\n'use strict';\n\n/* eslint-env node */\nconst Utils = require('mr-doc-utils');\nconst log = new Utils.Log();\nconst _ = require('lodash');\n\nclass Log {\n  constructor(options) {\n    if (options.silent) {\n      log.on('error', () => { /* NOOP */});\n      return log;\n    }\n    this.levels(options.level)\n    .forEach(level => {\n      if (level === 'error') this.error();\n      else this.other(level);\n    });\n    return log;\n  }\n  levels(level) {\n    const levels = _.isString(level) ? level.split(',') : level;\n    return levels\n    .map(i => i.replace(/\\s/g, ''));\n  }\n  error() {\n    log.on('error', function error() {\n      /* eslint-disable no-console */\n      const args = Array.prototype.slice.call(arguments);\n      args.unshift(log.color.cyan('mrdoc'));\n      console.log.apply(console, args.map(i => log.color.red(i)));\n      /* eslint-enable no-console */\n    });\n  }\n  other(level) {\n    log.on(level, function logger() {\n      /* eslint-disable no-console */\n      const args = Array.prototype.slice.call(arguments);\n      args.unshift(log.color.cyan('mrdoc'));\n      console.log.apply(console, args);\n      /* eslint-enable no-console */\n    });\n  }\n  /**\n   * Get the global instance of Log.\n   * @return {Log} - An instance of Log.\n   */\n  static global() {\n    log.color = Utils.Log.color;\n    return log;\n  }\n}\n\nmodule.exports = Log;\n"
            }
          },
          {
            "B1BhjpeL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "output.js",
                "ext": ".js",
                "name": "output"
              },
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nclass Output {\n  static handler(buffer, options) {\n    return function (callback) {\n      Output.format(buffer, options).forEach(Output.toStream(this, options));\n      callback();\n    };\n  }\n  static format(buffer, options) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler.file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n  static toBuffer(buffer) {\n    return (file, enc, callback) => {\n      buffer.push(file);\n      callback();\n    };\n  }\n  static toStream(context, options) {\n    const file = options.compiler.file;\n    return function (f) {\n      if (file.format === 'json' || file.format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (file.format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "BJUhiTxI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "source.js",
                "ext": ".js",
                "name": "source"
              },
              "source": "'use strict';\nconst ShortID = require('shortid');\nconst File = require('fs-extra');\nconst _ = require('lodash');\nconst Path = require('path');\n\nclass Source {\n  static create(files) {\n    // Process the files.\n    const result = files\n    .map(file => Source.processFile(file));\n    // Create references for each file.\n    const references = result\n    .map(file => Source.createReference(file));\n    // Process the references and attach it to each file.\n    return result\n    .map(file => Source.processReference(file, references));\n  }\n  static processFile(file) {\n    return {\n      id: ShortID.generate(),\n      cwd: file.cwd,\n      base: file.base.replace(file.cwd + Path.sep, ''),\n      path: Path.parse(file.path.replace(file.cwd + Path.sep, '')),\n      source: File.readFileSync(file.path, 'utf8'),\n      comments: undefined,\n    };\n  }\n  static createReference(file) {\n    return {\n      id: file.id,\n      cwd: file.cwd,\n      base: file.base,\n      path: file.path,\n      source: file.source,\n      comments: file.comments,\n    };\n  }\n  static processReference(file, references) {\n    return _.merge(file, {\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\n    });\n  }\n}\n\nmodule.exports = Source;\n"
            }
          },
          {
            "S1vnspgI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/engines",
                "base": "javascript.js",
                "ext": ".js",
                "name": "javascript"
              },
              "source": "'use strict';\n\nconst Babylon = require('babylon');\nconst Acorn = require('acorn');\nconst Espree = require('espree');\nconst ESCodeGen = require('escodegen');\nconst ESTraverse = require('estraverse');\nconst traverse = require('babel-traverse').default;\n\nconst opts = {\n  acorn: (version, comments, tokens) => ({\n    ecmaVersion: version,\n    locations: true,\n    onComment: comments,\n    onToken: tokens,\n    ranges: true,\n  }),\n  babylon: () => ({\n    allowImportExportEverywhere: true,\n    plugins: [\n      'jsx',\n      'flow',\n      'asyncFunctions',\n      'classConstructorCall',\n      'doExpressions',\n      'trailingFunctionCommas',\n      'objectRestSpread',\n      'decorators',\n      'classProperties',\n      'exportExtensions',\n      'exponentiationOperator',\n      'asyncGenerators',\n      'functionBind',\n      'functionSent',\n    ],\n    sourceType: 'module',\n  }),\n  espree: (version) => ({\n    attachComment: true,\n    comment: true,\n    ecmaFeatures: {\n      experimentalObjectRestSpread: true,\n      globalReturn: true,\n      impliedStrict: true,\n      jsx: true,\n    },\n    ecmaVersion: version,\n    loc: true,\n    range: true,\n    sourceType: 'module',\n    tokens: true,\n  }),\n};\n\nclass Engine {\n  constructor(options) {\n    this.options = options;\n    switch (this.options.engine) {\n      case 'acorn':\n        this.engine = Acorn;\n        break;\n      case 'espree':\n        this.engine = Espree;\n        break;\n      default:\n        this.engine = Babylon;\n        break;\n    }\n  }\n  parse(file) {\n    const comments = [];\n    const tokens = [];\n    try {\n      switch (this.options.engine) {\n        case 'acorn':\n          return ESCodeGen\n          .attachComments(this.engine.parse(file.source,\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\n        case 'espree':\n          return this.engine.parse(file.source, opts.espree(this.options.version));\n        default:\n          return this.engine.parse(file.source, opts.babylon());\n      }\n    } catch (error) {\n      throw (new Error(error));\n    }\n  }\n  static traverse(options, ast, callback) {\n    switch (options.engine) {\n      case 'babylon':\n        traverse(ast, {\n          enter: (path) => {\n            const node = path.node;\n            callback(node);\n          } });\n        break;\n      default:\n        ESTraverse.traverse(ast, {\n          /* eslint-disable no-param-reassign */\n          enter: (node) => {\n            if (node.type === 'Program') {\n              node = node.body[0];\n            }\n            callback(node);\n          } });\n          /* eslint-enable no-param-reassign */\n        break;\n    }\n  }\n}\nmodule.exports = Engine;\n"
            }
          },
          {
            "r1OhoagI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "SyY2jagI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass IParser {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser;\n  }\n  /**\n   * Parses the sources' comments into the desired output.\n   * @param  {Array<Object>} results - The files to parse.\n   * @return {Array<Object>} - The parsed comments.\n   */\n  /* eslint-disable no-unused-vars */\n  parse(sources) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = IParser;\n"
            }
          },
          {
            "Bk5nsalU": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/html",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\n\nclass HTML extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.comments = comments;\n  }\n}\nmodule.exports = HTML;\n"
            }
          },
          {
            "rJi2iTgI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/json",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "SJn3oplI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers/javascript",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n"
            }
          },
          {
            "Bkphopx8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers/javascript",
                "base": "synonyms.js",
                "ext": ".js",
                "name": "synonyms"
              },
              "source": "module.exports = {\n  arg: 'param',\n  argument: 'param',\n  constructor: 'class',\n  const: 'constant',\n  defaultvalue: 'default',\n  desc: 'description',\n  emits: 'fires',\n  exception: 'throws',\n  fileoverview: 'file',\n  func: 'function',\n  host: 'external',\n  linkcode: 'link',\n  linkplain: 'link',\n  virtual: 'abstract',\n  method: 'function',\n  overview: 'file',\n  prop: 'property',\n  return: 'returns',\n  var: 'member',\n};\n"
            }
          },
          {
            "H1R3spgL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/html/engines",
                "base": "theme.js",
                "ext": ".js",
                "name": "theme"
              },
              "source": "'use strict';\n\nclass Theme {\n  // constructor() {\n  //\n  // }\n  compile() {\n\n  }\n}\n\nmodule.exports = Theme;\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 48,
          "column": 2
        },
        "end": {
          "line": 58,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          48,
          58
        ]
      }
    }
  },
  {
    "description": "Handles the result from the CLI.",
    "tags": [
      {
        "title": "static",
        "description": null,
        "lineNumber": 2
      }
    ],
    "loc": {
      "start": {
        "line": 59,
        "column": 2
      },
      "end": {
        "line": 62,
        "column": 5
      }
    },
    "context": {
      "code": "static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const sources = source.split(',')\n      .map(path => path.trim())\n      .map(path => FS.normalize(path, rc('mrdoc', options)));\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: options.cwd }), options });\n    });\n  }",
      "file": {
        "id": "BJ2i6eL",
        "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
        "base": "src/",
        "path": {
          "root": "",
          "dir": "src/cli",
          "base": "index.js",
          "ext": ".js",
          "name": "index"
        },
        "source": "/* eslint-env node */\n'use strict';\n\nconst FS = require('../utils/fs');\nconst Log = require('../utils/log');\nconst Liftoff = require('liftoff');\nconst Option = require('mr-doc-utils').Option;\nconst Promise = require('bluebird');\nconst Yargs = require('yargs');\nconst ViynlFS = require('vinyl-fs');\nconst _ = require('lodash');\nconst log = Log.global();\nconst pkg = require('../../package.json');\nconst rc = require('rc');\n\nclass CLI {\n  /**\n   * Parse the CLI arguments.\n   * @static\n   */\n  static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli)\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }\n  /**\n   * Create the CLI.\n   * @static\n   * @return {Liftoff} - An instance of Liftoff.\n   */\n  static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }\n  /**\n   * Launch the cli.\n   * @static\n   * @param {Object} - The parsed CLI arguments.\n   * @return {Promise<Stream>} - A promise to the stream.\n   */\n  static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }\n  /**\n   * Handles the result from the CLI.\n   * @static\n   */\n  static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const sources = source.split(',')\n      .map(path => path.trim())\n      .map(path => FS.normalize(path, rc('mrdoc', options)));\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: options.cwd }), options });\n    });\n  }\n}\n\nmodule.exports = CLI;\n",
        "ref": [
          {
            "BJ2i6eL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/cli",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "/* eslint-env node */\n'use strict';\n\nconst FS = require('../utils/fs');\nconst Log = require('../utils/log');\nconst Liftoff = require('liftoff');\nconst Option = require('mr-doc-utils').Option;\nconst Promise = require('bluebird');\nconst Yargs = require('yargs');\nconst ViynlFS = require('vinyl-fs');\nconst _ = require('lodash');\nconst log = Log.global();\nconst pkg = require('../../package.json');\nconst rc = require('rc');\n\nclass CLI {\n  /**\n   * Parse the CLI arguments.\n   * @static\n   */\n  static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli)\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }\n  /**\n   * Create the CLI.\n   * @static\n   * @return {Liftoff} - An instance of Liftoff.\n   */\n  static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }\n  /**\n   * Launch the cli.\n   * @static\n   * @param {Object} - The parsed CLI arguments.\n   * @return {Promise<Stream>} - A promise to the stream.\n   */\n  static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }\n  /**\n   * Handles the result from the CLI.\n   * @static\n   */\n  static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const sources = source.split(',')\n      .map(path => path.trim())\n      .map(path => FS.normalize(path, rc('mrdoc', options)));\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: options.cwd }), options });\n    });\n  }\n}\n\nmodule.exports = CLI;\n"
            }
          },
          {
            "BJxhiTlL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst JSONC = require('./compilers/json/');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\n// const HTML = require('./compilers/html');\n\nclass Compiler {\n  constructor(options) {\n    this.options = options;\n  }\n  factory() {\n    const format = this.options.compiler.file.format;\n    // DEBUG: Compiler format\n    log.debug(Log.color.blue('Compiler format:'), format);\n    switch (format) {\n      case 'json':\n        return (new JSONC(this.options));\n      case 'html':\n        // return (new HTML(this.options));\n      default:\n        return null;\n    }\n  }\n}\nmodule.exports = Compiler;\n"
            }
          },
          {
            "Hy-2sae8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst JavaScript = require('./parsers/javascript/');\n\nclass Parser {\n  constructor(options) {\n    this.options = options;\n  }\n  factory() {\n    switch (this.options.parser.language) {\n      case 'js':\n      case 'javascript':\n        return (new JavaScript(this.options));\n      default:\n        return null;\n    }\n  }\n}\nmodule.exports = Parser;\n"
            }
          },
          {
            "Skfhjpl8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "extension.js",
                "ext": ".js",
                "name": "extension"
              },
              "source": "'use strict';\n\nclass Extension {\n  static find(language) {\n    return Extension.extensions()[language];\n  }\n  static extensions() {\n    return {\n      js: '.js',\n      javascript: '.js',\n      json: '.json',\n      html: '.html',\n      typescript: '.ts',\n    };\n  }\n}\n\nmodule.exports = Extension;\n"
            }
          },
          {
            "H17hjpxU": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "fs.js",
                "ext": ".js",
                "name": "fs"
              },
              "source": "'use strict';\nconst Path = require('path');\nconst Extension = require('./extension');\nconst isGlob = require('is-glob');\nconst _ = require('lodash');\n\nclass FS {\n  static normalize(path, options) {\n    // Check if the path is not in glob pattern.\n    if (!isGlob(path)) {\n      // Assume that Glob is used.\n      let isFile = false;\n      // Make sure the path is resolved.\n      let str = Path.resolve(options.mrdoc.cwd, path).replace('/', Path.sep);\n      // Check if the path is a file or directory.\n      if (_.isEmpty(Path.parse(path).ext)) {\n        // Check if the path has a '/' at the end.\n        str = str[str.length - 1] === Path.sep ?\n        str : `${str}${Path.sep}`;\n      } else isFile = true;\n      // Make sure the file or directory exists;\n      if (File.existsSync(str)) {\n        if (!isFile) {\n          // Check if the directory has sub-directories.\n          const hasSubDirs = File.readdirSync(str)\n          .filter(file =>\n            File.statSync(Path.join(str, file)).isDirectory()).length > 1;\n          // Get the file extension.\n          const extension = Extension.find(options.parser.language);\n          // Set the glob pattern based on 'hasSubDirs'.\n          str = hasSubDirs ?\n          `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\n        }\n      } else return null;\n      return str;\n    }\n    return path;\n  }\n}\n\nmodule.exports = FS;\n"
            }
          },
          {
            "H1V3i6xL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "log.js",
                "ext": ".js",
                "name": "log"
              },
              "source": "/* eslint-env node */\n'use strict';\n\n/* eslint-env node */\nconst Utils = require('mr-doc-utils');\nconst log = new Utils.Log();\nconst _ = require('lodash');\n\nclass Log {\n  constructor(options) {\n    if (options.silent) {\n      log.on('error', () => { /* NOOP */});\n      return log;\n    }\n    this.levels(options.level)\n    .forEach(level => {\n      if (level === 'error') this.error();\n      else this.other(level);\n    });\n    return log;\n  }\n  levels(level) {\n    const levels = _.isString(level) ? level.split(',') : level;\n    return levels\n    .map(i => i.replace(/\\s/g, ''));\n  }\n  error() {\n    log.on('error', function error() {\n      /* eslint-disable no-console */\n      const args = Array.prototype.slice.call(arguments);\n      args.unshift(log.color.cyan('mrdoc'));\n      console.log.apply(console, args.map(i => log.color.red(i)));\n      /* eslint-enable no-console */\n    });\n  }\n  other(level) {\n    log.on(level, function logger() {\n      /* eslint-disable no-console */\n      const args = Array.prototype.slice.call(arguments);\n      args.unshift(log.color.cyan('mrdoc'));\n      console.log.apply(console, args);\n      /* eslint-enable no-console */\n    });\n  }\n  /**\n   * Get the global instance of Log.\n   * @return {Log} - An instance of Log.\n   */\n  static global() {\n    log.color = Utils.Log.color;\n    return log;\n  }\n}\n\nmodule.exports = Log;\n"
            }
          },
          {
            "B1BhjpeL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "output.js",
                "ext": ".js",
                "name": "output"
              },
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nclass Output {\n  static handler(buffer, options) {\n    return function (callback) {\n      Output.format(buffer, options).forEach(Output.toStream(this, options));\n      callback();\n    };\n  }\n  static format(buffer, options) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler.file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n  static toBuffer(buffer) {\n    return (file, enc, callback) => {\n      buffer.push(file);\n      callback();\n    };\n  }\n  static toStream(context, options) {\n    const file = options.compiler.file;\n    return function (f) {\n      if (file.format === 'json' || file.format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (file.format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "BJUhiTxI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "source.js",
                "ext": ".js",
                "name": "source"
              },
              "source": "'use strict';\nconst ShortID = require('shortid');\nconst File = require('fs-extra');\nconst _ = require('lodash');\nconst Path = require('path');\n\nclass Source {\n  static create(files) {\n    // Process the files.\n    const result = files\n    .map(file => Source.processFile(file));\n    // Create references for each file.\n    const references = result\n    .map(file => Source.createReference(file));\n    // Process the references and attach it to each file.\n    return result\n    .map(file => Source.processReference(file, references));\n  }\n  static processFile(file) {\n    return {\n      id: ShortID.generate(),\n      cwd: file.cwd,\n      base: file.base.replace(file.cwd + Path.sep, ''),\n      path: Path.parse(file.path.replace(file.cwd + Path.sep, '')),\n      source: File.readFileSync(file.path, 'utf8'),\n      comments: undefined,\n    };\n  }\n  static createReference(file) {\n    return {\n      id: file.id,\n      cwd: file.cwd,\n      base: file.base,\n      path: file.path,\n      source: file.source,\n      comments: file.comments,\n    };\n  }\n  static processReference(file, references) {\n    return _.merge(file, {\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\n    });\n  }\n}\n\nmodule.exports = Source;\n"
            }
          },
          {
            "S1vnspgI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/engines",
                "base": "javascript.js",
                "ext": ".js",
                "name": "javascript"
              },
              "source": "'use strict';\n\nconst Babylon = require('babylon');\nconst Acorn = require('acorn');\nconst Espree = require('espree');\nconst ESCodeGen = require('escodegen');\nconst ESTraverse = require('estraverse');\nconst traverse = require('babel-traverse').default;\n\nconst opts = {\n  acorn: (version, comments, tokens) => ({\n    ecmaVersion: version,\n    locations: true,\n    onComment: comments,\n    onToken: tokens,\n    ranges: true,\n  }),\n  babylon: () => ({\n    allowImportExportEverywhere: true,\n    plugins: [\n      'jsx',\n      'flow',\n      'asyncFunctions',\n      'classConstructorCall',\n      'doExpressions',\n      'trailingFunctionCommas',\n      'objectRestSpread',\n      'decorators',\n      'classProperties',\n      'exportExtensions',\n      'exponentiationOperator',\n      'asyncGenerators',\n      'functionBind',\n      'functionSent',\n    ],\n    sourceType: 'module',\n  }),\n  espree: (version) => ({\n    attachComment: true,\n    comment: true,\n    ecmaFeatures: {\n      experimentalObjectRestSpread: true,\n      globalReturn: true,\n      impliedStrict: true,\n      jsx: true,\n    },\n    ecmaVersion: version,\n    loc: true,\n    range: true,\n    sourceType: 'module',\n    tokens: true,\n  }),\n};\n\nclass Engine {\n  constructor(options) {\n    this.options = options;\n    switch (this.options.engine) {\n      case 'acorn':\n        this.engine = Acorn;\n        break;\n      case 'espree':\n        this.engine = Espree;\n        break;\n      default:\n        this.engine = Babylon;\n        break;\n    }\n  }\n  parse(file) {\n    const comments = [];\n    const tokens = [];\n    try {\n      switch (this.options.engine) {\n        case 'acorn':\n          return ESCodeGen\n          .attachComments(this.engine.parse(file.source,\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\n        case 'espree':\n          return this.engine.parse(file.source, opts.espree(this.options.version));\n        default:\n          return this.engine.parse(file.source, opts.babylon());\n      }\n    } catch (error) {\n      throw (new Error(error));\n    }\n  }\n  static traverse(options, ast, callback) {\n    switch (options.engine) {\n      case 'babylon':\n        traverse(ast, {\n          enter: (path) => {\n            const node = path.node;\n            callback(node);\n          } });\n        break;\n      default:\n        ESTraverse.traverse(ast, {\n          /* eslint-disable no-param-reassign */\n          enter: (node) => {\n            if (node.type === 'Program') {\n              node = node.body[0];\n            }\n            callback(node);\n          } });\n          /* eslint-enable no-param-reassign */\n        break;\n    }\n  }\n}\nmodule.exports = Engine;\n"
            }
          },
          {
            "r1OhoagI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "SyY2jagI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass IParser {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser;\n  }\n  /**\n   * Parses the sources' comments into the desired output.\n   * @param  {Array<Object>} results - The files to parse.\n   * @return {Array<Object>} - The parsed comments.\n   */\n  /* eslint-disable no-unused-vars */\n  parse(sources) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = IParser;\n"
            }
          },
          {
            "Bk5nsalU": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/html",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\n\nclass HTML extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.comments = comments;\n  }\n}\nmodule.exports = HTML;\n"
            }
          },
          {
            "rJi2iTgI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/json",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "SJn3oplI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers/javascript",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n"
            }
          },
          {
            "Bkphopx8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers/javascript",
                "base": "synonyms.js",
                "ext": ".js",
                "name": "synonyms"
              },
              "source": "module.exports = {\n  arg: 'param',\n  argument: 'param',\n  constructor: 'class',\n  const: 'constant',\n  defaultvalue: 'default',\n  desc: 'description',\n  emits: 'fires',\n  exception: 'throws',\n  fileoverview: 'file',\n  func: 'function',\n  host: 'external',\n  linkcode: 'link',\n  linkplain: 'link',\n  virtual: 'abstract',\n  method: 'function',\n  overview: 'file',\n  prop: 'property',\n  return: 'returns',\n  var: 'member',\n};\n"
            }
          },
          {
            "H1R3spgL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/html/engines",
                "base": "theme.js",
                "ext": ".js",
                "name": "theme"
              },
              "source": "'use strict';\n\nclass Theme {\n  // constructor() {\n  //\n  // }\n  compile() {\n\n  }\n}\n\nmodule.exports = Theme;\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 63,
          "column": 2
        },
        "end": {
          "line": 85,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          63,
          85
        ]
      }
    }
  },
  {
    "description": "Get the global instance of Log.",
    "tags": [
      {
        "title": "returns",
        "description": "An instance of Log.",
        "lineNumber": 2,
        "type": {
          "type": "NameExpression",
          "name": "Log"
        }
      }
    ],
    "loc": {
      "start": {
        "line": 45,
        "column": 2
      },
      "end": {
        "line": 48,
        "column": 5
      }
    },
    "context": {
      "code": "static global() {\n    log.color = Utils.Log.color;\n    return log;\n  }",
      "file": {
        "id": "H1V3i6xL",
        "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
        "base": "src/",
        "path": {
          "root": "",
          "dir": "src/utils",
          "base": "log.js",
          "ext": ".js",
          "name": "log"
        },
        "source": "/* eslint-env node */\n'use strict';\n\n/* eslint-env node */\nconst Utils = require('mr-doc-utils');\nconst log = new Utils.Log();\nconst _ = require('lodash');\n\nclass Log {\n  constructor(options) {\n    if (options.silent) {\n      log.on('error', () => { /* NOOP */});\n      return log;\n    }\n    this.levels(options.level)\n    .forEach(level => {\n      if (level === 'error') this.error();\n      else this.other(level);\n    });\n    return log;\n  }\n  levels(level) {\n    const levels = _.isString(level) ? level.split(',') : level;\n    return levels\n    .map(i => i.replace(/\\s/g, ''));\n  }\n  error() {\n    log.on('error', function error() {\n      /* eslint-disable no-console */\n      const args = Array.prototype.slice.call(arguments);\n      args.unshift(log.color.cyan('mrdoc'));\n      console.log.apply(console, args.map(i => log.color.red(i)));\n      /* eslint-enable no-console */\n    });\n  }\n  other(level) {\n    log.on(level, function logger() {\n      /* eslint-disable no-console */\n      const args = Array.prototype.slice.call(arguments);\n      args.unshift(log.color.cyan('mrdoc'));\n      console.log.apply(console, args);\n      /* eslint-enable no-console */\n    });\n  }\n  /**\n   * Get the global instance of Log.\n   * @return {Log} - An instance of Log.\n   */\n  static global() {\n    log.color = Utils.Log.color;\n    return log;\n  }\n}\n\nmodule.exports = Log;\n",
        "ref": [
          {
            "BJ2i6eL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/cli",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "/* eslint-env node */\n'use strict';\n\nconst FS = require('../utils/fs');\nconst Log = require('../utils/log');\nconst Liftoff = require('liftoff');\nconst Option = require('mr-doc-utils').Option;\nconst Promise = require('bluebird');\nconst Yargs = require('yargs');\nconst ViynlFS = require('vinyl-fs');\nconst _ = require('lodash');\nconst log = Log.global();\nconst pkg = require('../../package.json');\nconst rc = require('rc');\n\nclass CLI {\n  /**\n   * Parse the CLI arguments.\n   * @static\n   */\n  static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli)\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }\n  /**\n   * Create the CLI.\n   * @static\n   * @return {Liftoff} - An instance of Liftoff.\n   */\n  static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }\n  /**\n   * Launch the cli.\n   * @static\n   * @param {Object} - The parsed CLI arguments.\n   * @return {Promise<Stream>} - A promise to the stream.\n   */\n  static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }\n  /**\n   * Handles the result from the CLI.\n   * @static\n   */\n  static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const sources = source.split(',')\n      .map(path => path.trim())\n      .map(path => FS.normalize(path, rc('mrdoc', options)));\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: options.cwd }), options });\n    });\n  }\n}\n\nmodule.exports = CLI;\n"
            }
          },
          {
            "BJxhiTlL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst JSONC = require('./compilers/json/');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\n// const HTML = require('./compilers/html');\n\nclass Compiler {\n  constructor(options) {\n    this.options = options;\n  }\n  factory() {\n    const format = this.options.compiler.file.format;\n    // DEBUG: Compiler format\n    log.debug(Log.color.blue('Compiler format:'), format);\n    switch (format) {\n      case 'json':\n        return (new JSONC(this.options));\n      case 'html':\n        // return (new HTML(this.options));\n      default:\n        return null;\n    }\n  }\n}\nmodule.exports = Compiler;\n"
            }
          },
          {
            "Hy-2sae8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst JavaScript = require('./parsers/javascript/');\n\nclass Parser {\n  constructor(options) {\n    this.options = options;\n  }\n  factory() {\n    switch (this.options.parser.language) {\n      case 'js':\n      case 'javascript':\n        return (new JavaScript(this.options));\n      default:\n        return null;\n    }\n  }\n}\nmodule.exports = Parser;\n"
            }
          },
          {
            "Skfhjpl8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "extension.js",
                "ext": ".js",
                "name": "extension"
              },
              "source": "'use strict';\n\nclass Extension {\n  static find(language) {\n    return Extension.extensions()[language];\n  }\n  static extensions() {\n    return {\n      js: '.js',\n      javascript: '.js',\n      json: '.json',\n      html: '.html',\n      typescript: '.ts',\n    };\n  }\n}\n\nmodule.exports = Extension;\n"
            }
          },
          {
            "H17hjpxU": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "fs.js",
                "ext": ".js",
                "name": "fs"
              },
              "source": "'use strict';\nconst Path = require('path');\nconst Extension = require('./extension');\nconst isGlob = require('is-glob');\nconst _ = require('lodash');\n\nclass FS {\n  static normalize(path, options) {\n    // Check if the path is not in glob pattern.\n    if (!isGlob(path)) {\n      // Assume that Glob is used.\n      let isFile = false;\n      // Make sure the path is resolved.\n      let str = Path.resolve(options.mrdoc.cwd, path).replace('/', Path.sep);\n      // Check if the path is a file or directory.\n      if (_.isEmpty(Path.parse(path).ext)) {\n        // Check if the path has a '/' at the end.\n        str = str[str.length - 1] === Path.sep ?\n        str : `${str}${Path.sep}`;\n      } else isFile = true;\n      // Make sure the file or directory exists;\n      if (File.existsSync(str)) {\n        if (!isFile) {\n          // Check if the directory has sub-directories.\n          const hasSubDirs = File.readdirSync(str)\n          .filter(file =>\n            File.statSync(Path.join(str, file)).isDirectory()).length > 1;\n          // Get the file extension.\n          const extension = Extension.find(options.parser.language);\n          // Set the glob pattern based on 'hasSubDirs'.\n          str = hasSubDirs ?\n          `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\n        }\n      } else return null;\n      return str;\n    }\n    return path;\n  }\n}\n\nmodule.exports = FS;\n"
            }
          },
          {
            "H1V3i6xL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "log.js",
                "ext": ".js",
                "name": "log"
              },
              "source": "/* eslint-env node */\n'use strict';\n\n/* eslint-env node */\nconst Utils = require('mr-doc-utils');\nconst log = new Utils.Log();\nconst _ = require('lodash');\n\nclass Log {\n  constructor(options) {\n    if (options.silent) {\n      log.on('error', () => { /* NOOP */});\n      return log;\n    }\n    this.levels(options.level)\n    .forEach(level => {\n      if (level === 'error') this.error();\n      else this.other(level);\n    });\n    return log;\n  }\n  levels(level) {\n    const levels = _.isString(level) ? level.split(',') : level;\n    return levels\n    .map(i => i.replace(/\\s/g, ''));\n  }\n  error() {\n    log.on('error', function error() {\n      /* eslint-disable no-console */\n      const args = Array.prototype.slice.call(arguments);\n      args.unshift(log.color.cyan('mrdoc'));\n      console.log.apply(console, args.map(i => log.color.red(i)));\n      /* eslint-enable no-console */\n    });\n  }\n  other(level) {\n    log.on(level, function logger() {\n      /* eslint-disable no-console */\n      const args = Array.prototype.slice.call(arguments);\n      args.unshift(log.color.cyan('mrdoc'));\n      console.log.apply(console, args);\n      /* eslint-enable no-console */\n    });\n  }\n  /**\n   * Get the global instance of Log.\n   * @return {Log} - An instance of Log.\n   */\n  static global() {\n    log.color = Utils.Log.color;\n    return log;\n  }\n}\n\nmodule.exports = Log;\n"
            }
          },
          {
            "B1BhjpeL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "output.js",
                "ext": ".js",
                "name": "output"
              },
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nclass Output {\n  static handler(buffer, options) {\n    return function (callback) {\n      Output.format(buffer, options).forEach(Output.toStream(this, options));\n      callback();\n    };\n  }\n  static format(buffer, options) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler.file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n  static toBuffer(buffer) {\n    return (file, enc, callback) => {\n      buffer.push(file);\n      callback();\n    };\n  }\n  static toStream(context, options) {\n    const file = options.compiler.file;\n    return function (f) {\n      if (file.format === 'json' || file.format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (file.format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "BJUhiTxI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "source.js",
                "ext": ".js",
                "name": "source"
              },
              "source": "'use strict';\nconst ShortID = require('shortid');\nconst File = require('fs-extra');\nconst _ = require('lodash');\nconst Path = require('path');\n\nclass Source {\n  static create(files) {\n    // Process the files.\n    const result = files\n    .map(file => Source.processFile(file));\n    // Create references for each file.\n    const references = result\n    .map(file => Source.createReference(file));\n    // Process the references and attach it to each file.\n    return result\n    .map(file => Source.processReference(file, references));\n  }\n  static processFile(file) {\n    return {\n      id: ShortID.generate(),\n      cwd: file.cwd,\n      base: file.base.replace(file.cwd + Path.sep, ''),\n      path: Path.parse(file.path.replace(file.cwd + Path.sep, '')),\n      source: File.readFileSync(file.path, 'utf8'),\n      comments: undefined,\n    };\n  }\n  static createReference(file) {\n    return {\n      id: file.id,\n      cwd: file.cwd,\n      base: file.base,\n      path: file.path,\n      source: file.source,\n      comments: file.comments,\n    };\n  }\n  static processReference(file, references) {\n    return _.merge(file, {\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\n    });\n  }\n}\n\nmodule.exports = Source;\n"
            }
          },
          {
            "S1vnspgI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/engines",
                "base": "javascript.js",
                "ext": ".js",
                "name": "javascript"
              },
              "source": "'use strict';\n\nconst Babylon = require('babylon');\nconst Acorn = require('acorn');\nconst Espree = require('espree');\nconst ESCodeGen = require('escodegen');\nconst ESTraverse = require('estraverse');\nconst traverse = require('babel-traverse').default;\n\nconst opts = {\n  acorn: (version, comments, tokens) => ({\n    ecmaVersion: version,\n    locations: true,\n    onComment: comments,\n    onToken: tokens,\n    ranges: true,\n  }),\n  babylon: () => ({\n    allowImportExportEverywhere: true,\n    plugins: [\n      'jsx',\n      'flow',\n      'asyncFunctions',\n      'classConstructorCall',\n      'doExpressions',\n      'trailingFunctionCommas',\n      'objectRestSpread',\n      'decorators',\n      'classProperties',\n      'exportExtensions',\n      'exponentiationOperator',\n      'asyncGenerators',\n      'functionBind',\n      'functionSent',\n    ],\n    sourceType: 'module',\n  }),\n  espree: (version) => ({\n    attachComment: true,\n    comment: true,\n    ecmaFeatures: {\n      experimentalObjectRestSpread: true,\n      globalReturn: true,\n      impliedStrict: true,\n      jsx: true,\n    },\n    ecmaVersion: version,\n    loc: true,\n    range: true,\n    sourceType: 'module',\n    tokens: true,\n  }),\n};\n\nclass Engine {\n  constructor(options) {\n    this.options = options;\n    switch (this.options.engine) {\n      case 'acorn':\n        this.engine = Acorn;\n        break;\n      case 'espree':\n        this.engine = Espree;\n        break;\n      default:\n        this.engine = Babylon;\n        break;\n    }\n  }\n  parse(file) {\n    const comments = [];\n    const tokens = [];\n    try {\n      switch (this.options.engine) {\n        case 'acorn':\n          return ESCodeGen\n          .attachComments(this.engine.parse(file.source,\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\n        case 'espree':\n          return this.engine.parse(file.source, opts.espree(this.options.version));\n        default:\n          return this.engine.parse(file.source, opts.babylon());\n      }\n    } catch (error) {\n      throw (new Error(error));\n    }\n  }\n  static traverse(options, ast, callback) {\n    switch (options.engine) {\n      case 'babylon':\n        traverse(ast, {\n          enter: (path) => {\n            const node = path.node;\n            callback(node);\n          } });\n        break;\n      default:\n        ESTraverse.traverse(ast, {\n          /* eslint-disable no-param-reassign */\n          enter: (node) => {\n            if (node.type === 'Program') {\n              node = node.body[0];\n            }\n            callback(node);\n          } });\n          /* eslint-enable no-param-reassign */\n        break;\n    }\n  }\n}\nmodule.exports = Engine;\n"
            }
          },
          {
            "r1OhoagI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "SyY2jagI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass IParser {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser;\n  }\n  /**\n   * Parses the sources' comments into the desired output.\n   * @param  {Array<Object>} results - The files to parse.\n   * @return {Array<Object>} - The parsed comments.\n   */\n  /* eslint-disable no-unused-vars */\n  parse(sources) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = IParser;\n"
            }
          },
          {
            "Bk5nsalU": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/html",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\n\nclass HTML extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.comments = comments;\n  }\n}\nmodule.exports = HTML;\n"
            }
          },
          {
            "rJi2iTgI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/json",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "SJn3oplI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers/javascript",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n"
            }
          },
          {
            "Bkphopx8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers/javascript",
                "base": "synonyms.js",
                "ext": ".js",
                "name": "synonyms"
              },
              "source": "module.exports = {\n  arg: 'param',\n  argument: 'param',\n  constructor: 'class',\n  const: 'constant',\n  defaultvalue: 'default',\n  desc: 'description',\n  emits: 'fires',\n  exception: 'throws',\n  fileoverview: 'file',\n  func: 'function',\n  host: 'external',\n  linkcode: 'link',\n  linkplain: 'link',\n  virtual: 'abstract',\n  method: 'function',\n  overview: 'file',\n  prop: 'property',\n  return: 'returns',\n  var: 'member',\n};\n"
            }
          },
          {
            "H1R3spgL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/html/engines",
                "base": "theme.js",
                "ext": ".js",
                "name": "theme"
              },
              "source": "'use strict';\n\nclass Theme {\n  // constructor() {\n  //\n  // }\n  compile() {\n\n  }\n}\n\nmodule.exports = Theme;\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 49,
          "column": 2
        },
        "end": {
          "line": 52,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          49,
          52
        ]
      }
    }
  },
  {
    "description": "",
    "tags": [
      {
        "title": "class",
        "description": null,
        "lineNumber": 1,
        "type": null,
        "name": null
      },
      {
        "title": "param",
        "description": "The options for the compiler provided by mr-doc-utils/options",
        "lineNumber": 2,
        "type": {
          "type": "NameExpression",
          "name": "Object"
        },
        "name": "options"
      }
    ],
    "loc": {
      "start": {
        "line": 3,
        "column": 2
      },
      "end": {
        "line": 6,
        "column": 5
      }
    },
    "context": {
      "code": "constructor(options) {\n    this.options = options;\n  }",
      "file": {
        "id": "r1OhoagI",
        "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
        "base": "src/",
        "path": {
          "root": "",
          "dir": "src/compiler/compilers",
          "base": "interface.js",
          "ext": ".js",
          "name": "interface"
        },
        "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n",
        "ref": [
          {
            "BJ2i6eL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/cli",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "/* eslint-env node */\n'use strict';\n\nconst FS = require('../utils/fs');\nconst Log = require('../utils/log');\nconst Liftoff = require('liftoff');\nconst Option = require('mr-doc-utils').Option;\nconst Promise = require('bluebird');\nconst Yargs = require('yargs');\nconst ViynlFS = require('vinyl-fs');\nconst _ = require('lodash');\nconst log = Log.global();\nconst pkg = require('../../package.json');\nconst rc = require('rc');\n\nclass CLI {\n  /**\n   * Parse the CLI arguments.\n   * @static\n   */\n  static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli)\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }\n  /**\n   * Create the CLI.\n   * @static\n   * @return {Liftoff} - An instance of Liftoff.\n   */\n  static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }\n  /**\n   * Launch the cli.\n   * @static\n   * @param {Object} - The parsed CLI arguments.\n   * @return {Promise<Stream>} - A promise to the stream.\n   */\n  static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }\n  /**\n   * Handles the result from the CLI.\n   * @static\n   */\n  static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const sources = source.split(',')\n      .map(path => path.trim())\n      .map(path => FS.normalize(path, rc('mrdoc', options)));\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: options.cwd }), options });\n    });\n  }\n}\n\nmodule.exports = CLI;\n"
            }
          },
          {
            "BJxhiTlL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst JSONC = require('./compilers/json/');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\n// const HTML = require('./compilers/html');\n\nclass Compiler {\n  constructor(options) {\n    this.options = options;\n  }\n  factory() {\n    const format = this.options.compiler.file.format;\n    // DEBUG: Compiler format\n    log.debug(Log.color.blue('Compiler format:'), format);\n    switch (format) {\n      case 'json':\n        return (new JSONC(this.options));\n      case 'html':\n        // return (new HTML(this.options));\n      default:\n        return null;\n    }\n  }\n}\nmodule.exports = Compiler;\n"
            }
          },
          {
            "Hy-2sae8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst JavaScript = require('./parsers/javascript/');\n\nclass Parser {\n  constructor(options) {\n    this.options = options;\n  }\n  factory() {\n    switch (this.options.parser.language) {\n      case 'js':\n      case 'javascript':\n        return (new JavaScript(this.options));\n      default:\n        return null;\n    }\n  }\n}\nmodule.exports = Parser;\n"
            }
          },
          {
            "Skfhjpl8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "extension.js",
                "ext": ".js",
                "name": "extension"
              },
              "source": "'use strict';\n\nclass Extension {\n  static find(language) {\n    return Extension.extensions()[language];\n  }\n  static extensions() {\n    return {\n      js: '.js',\n      javascript: '.js',\n      json: '.json',\n      html: '.html',\n      typescript: '.ts',\n    };\n  }\n}\n\nmodule.exports = Extension;\n"
            }
          },
          {
            "H17hjpxU": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "fs.js",
                "ext": ".js",
                "name": "fs"
              },
              "source": "'use strict';\nconst Path = require('path');\nconst Extension = require('./extension');\nconst isGlob = require('is-glob');\nconst _ = require('lodash');\n\nclass FS {\n  static normalize(path, options) {\n    // Check if the path is not in glob pattern.\n    if (!isGlob(path)) {\n      // Assume that Glob is used.\n      let isFile = false;\n      // Make sure the path is resolved.\n      let str = Path.resolve(options.mrdoc.cwd, path).replace('/', Path.sep);\n      // Check if the path is a file or directory.\n      if (_.isEmpty(Path.parse(path).ext)) {\n        // Check if the path has a '/' at the end.\n        str = str[str.length - 1] === Path.sep ?\n        str : `${str}${Path.sep}`;\n      } else isFile = true;\n      // Make sure the file or directory exists;\n      if (File.existsSync(str)) {\n        if (!isFile) {\n          // Check if the directory has sub-directories.\n          const hasSubDirs = File.readdirSync(str)\n          .filter(file =>\n            File.statSync(Path.join(str, file)).isDirectory()).length > 1;\n          // Get the file extension.\n          const extension = Extension.find(options.parser.language);\n          // Set the glob pattern based on 'hasSubDirs'.\n          str = hasSubDirs ?\n          `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\n        }\n      } else return null;\n      return str;\n    }\n    return path;\n  }\n}\n\nmodule.exports = FS;\n"
            }
          },
          {
            "H1V3i6xL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "log.js",
                "ext": ".js",
                "name": "log"
              },
              "source": "/* eslint-env node */\n'use strict';\n\n/* eslint-env node */\nconst Utils = require('mr-doc-utils');\nconst log = new Utils.Log();\nconst _ = require('lodash');\n\nclass Log {\n  constructor(options) {\n    if (options.silent) {\n      log.on('error', () => { /* NOOP */});\n      return log;\n    }\n    this.levels(options.level)\n    .forEach(level => {\n      if (level === 'error') this.error();\n      else this.other(level);\n    });\n    return log;\n  }\n  levels(level) {\n    const levels = _.isString(level) ? level.split(',') : level;\n    return levels\n    .map(i => i.replace(/\\s/g, ''));\n  }\n  error() {\n    log.on('error', function error() {\n      /* eslint-disable no-console */\n      const args = Array.prototype.slice.call(arguments);\n      args.unshift(log.color.cyan('mrdoc'));\n      console.log.apply(console, args.map(i => log.color.red(i)));\n      /* eslint-enable no-console */\n    });\n  }\n  other(level) {\n    log.on(level, function logger() {\n      /* eslint-disable no-console */\n      const args = Array.prototype.slice.call(arguments);\n      args.unshift(log.color.cyan('mrdoc'));\n      console.log.apply(console, args);\n      /* eslint-enable no-console */\n    });\n  }\n  /**\n   * Get the global instance of Log.\n   * @return {Log} - An instance of Log.\n   */\n  static global() {\n    log.color = Utils.Log.color;\n    return log;\n  }\n}\n\nmodule.exports = Log;\n"
            }
          },
          {
            "B1BhjpeL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "output.js",
                "ext": ".js",
                "name": "output"
              },
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nclass Output {\n  static handler(buffer, options) {\n    return function (callback) {\n      Output.format(buffer, options).forEach(Output.toStream(this, options));\n      callback();\n    };\n  }\n  static format(buffer, options) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler.file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n  static toBuffer(buffer) {\n    return (file, enc, callback) => {\n      buffer.push(file);\n      callback();\n    };\n  }\n  static toStream(context, options) {\n    const file = options.compiler.file;\n    return function (f) {\n      if (file.format === 'json' || file.format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (file.format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "BJUhiTxI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "source.js",
                "ext": ".js",
                "name": "source"
              },
              "source": "'use strict';\nconst ShortID = require('shortid');\nconst File = require('fs-extra');\nconst _ = require('lodash');\nconst Path = require('path');\n\nclass Source {\n  static create(files) {\n    // Process the files.\n    const result = files\n    .map(file => Source.processFile(file));\n    // Create references for each file.\n    const references = result\n    .map(file => Source.createReference(file));\n    // Process the references and attach it to each file.\n    return result\n    .map(file => Source.processReference(file, references));\n  }\n  static processFile(file) {\n    return {\n      id: ShortID.generate(),\n      cwd: file.cwd,\n      base: file.base.replace(file.cwd + Path.sep, ''),\n      path: Path.parse(file.path.replace(file.cwd + Path.sep, '')),\n      source: File.readFileSync(file.path, 'utf8'),\n      comments: undefined,\n    };\n  }\n  static createReference(file) {\n    return {\n      id: file.id,\n      cwd: file.cwd,\n      base: file.base,\n      path: file.path,\n      source: file.source,\n      comments: file.comments,\n    };\n  }\n  static processReference(file, references) {\n    return _.merge(file, {\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\n    });\n  }\n}\n\nmodule.exports = Source;\n"
            }
          },
          {
            "S1vnspgI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/engines",
                "base": "javascript.js",
                "ext": ".js",
                "name": "javascript"
              },
              "source": "'use strict';\n\nconst Babylon = require('babylon');\nconst Acorn = require('acorn');\nconst Espree = require('espree');\nconst ESCodeGen = require('escodegen');\nconst ESTraverse = require('estraverse');\nconst traverse = require('babel-traverse').default;\n\nconst opts = {\n  acorn: (version, comments, tokens) => ({\n    ecmaVersion: version,\n    locations: true,\n    onComment: comments,\n    onToken: tokens,\n    ranges: true,\n  }),\n  babylon: () => ({\n    allowImportExportEverywhere: true,\n    plugins: [\n      'jsx',\n      'flow',\n      'asyncFunctions',\n      'classConstructorCall',\n      'doExpressions',\n      'trailingFunctionCommas',\n      'objectRestSpread',\n      'decorators',\n      'classProperties',\n      'exportExtensions',\n      'exponentiationOperator',\n      'asyncGenerators',\n      'functionBind',\n      'functionSent',\n    ],\n    sourceType: 'module',\n  }),\n  espree: (version) => ({\n    attachComment: true,\n    comment: true,\n    ecmaFeatures: {\n      experimentalObjectRestSpread: true,\n      globalReturn: true,\n      impliedStrict: true,\n      jsx: true,\n    },\n    ecmaVersion: version,\n    loc: true,\n    range: true,\n    sourceType: 'module',\n    tokens: true,\n  }),\n};\n\nclass Engine {\n  constructor(options) {\n    this.options = options;\n    switch (this.options.engine) {\n      case 'acorn':\n        this.engine = Acorn;\n        break;\n      case 'espree':\n        this.engine = Espree;\n        break;\n      default:\n        this.engine = Babylon;\n        break;\n    }\n  }\n  parse(file) {\n    const comments = [];\n    const tokens = [];\n    try {\n      switch (this.options.engine) {\n        case 'acorn':\n          return ESCodeGen\n          .attachComments(this.engine.parse(file.source,\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\n        case 'espree':\n          return this.engine.parse(file.source, opts.espree(this.options.version));\n        default:\n          return this.engine.parse(file.source, opts.babylon());\n      }\n    } catch (error) {\n      throw (new Error(error));\n    }\n  }\n  static traverse(options, ast, callback) {\n    switch (options.engine) {\n      case 'babylon':\n        traverse(ast, {\n          enter: (path) => {\n            const node = path.node;\n            callback(node);\n          } });\n        break;\n      default:\n        ESTraverse.traverse(ast, {\n          /* eslint-disable no-param-reassign */\n          enter: (node) => {\n            if (node.type === 'Program') {\n              node = node.body[0];\n            }\n            callback(node);\n          } });\n          /* eslint-enable no-param-reassign */\n        break;\n    }\n  }\n}\nmodule.exports = Engine;\n"
            }
          },
          {
            "r1OhoagI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "SyY2jagI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass IParser {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser;\n  }\n  /**\n   * Parses the sources' comments into the desired output.\n   * @param  {Array<Object>} results - The files to parse.\n   * @return {Array<Object>} - The parsed comments.\n   */\n  /* eslint-disable no-unused-vars */\n  parse(sources) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = IParser;\n"
            }
          },
          {
            "Bk5nsalU": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/html",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\n\nclass HTML extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.comments = comments;\n  }\n}\nmodule.exports = HTML;\n"
            }
          },
          {
            "rJi2iTgI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/json",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "SJn3oplI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers/javascript",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n"
            }
          },
          {
            "Bkphopx8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers/javascript",
                "base": "synonyms.js",
                "ext": ".js",
                "name": "synonyms"
              },
              "source": "module.exports = {\n  arg: 'param',\n  argument: 'param',\n  constructor: 'class',\n  const: 'constant',\n  defaultvalue: 'default',\n  desc: 'description',\n  emits: 'fires',\n  exception: 'throws',\n  fileoverview: 'file',\n  func: 'function',\n  host: 'external',\n  linkcode: 'link',\n  linkplain: 'link',\n  virtual: 'abstract',\n  method: 'function',\n  overview: 'file',\n  prop: 'property',\n  return: 'returns',\n  var: 'member',\n};\n"
            }
          },
          {
            "H1R3spgL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/html/engines",
                "base": "theme.js",
                "ext": ".js",
                "name": "theme"
              },
              "source": "'use strict';\n\nclass Theme {\n  // constructor() {\n  //\n  // }\n  compile() {\n\n  }\n}\n\nmodule.exports = Theme;\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 7,
          "column": 2
        },
        "end": {
          "line": 9,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          7,
          9
        ]
      }
    }
  },
  {
    "description": "Compile the comments into the desired output.",
    "tags": [
      {
        "title": "param",
        "description": "The files to compile.",
        "lineNumber": 2,
        "type": {
          "type": "TypeApplication",
          "expression": {
            "type": "NameExpression",
            "name": "Array"
          },
          "applications": [
            {
              "type": "NameExpression",
              "name": "Object"
            }
          ]
        },
        "name": "results"
      },
      {
        "title": "returns",
        "description": "The compiled files.",
        "lineNumber": 3,
        "type": {
          "type": "AllLiteral"
        }
      }
    ],
    "loc": {
      "start": {
        "line": 10,
        "column": 2
      },
      "end": {
        "line": 14,
        "column": 5
      }
    },
    "context": {
      "code": "compile(comments) {\n    // ...\n  }",
      "file": {
        "id": "r1OhoagI",
        "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
        "base": "src/",
        "path": {
          "root": "",
          "dir": "src/compiler/compilers",
          "base": "interface.js",
          "ext": ".js",
          "name": "interface"
        },
        "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n",
        "ref": [
          {
            "BJ2i6eL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/cli",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "/* eslint-env node */\n'use strict';\n\nconst FS = require('../utils/fs');\nconst Log = require('../utils/log');\nconst Liftoff = require('liftoff');\nconst Option = require('mr-doc-utils').Option;\nconst Promise = require('bluebird');\nconst Yargs = require('yargs');\nconst ViynlFS = require('vinyl-fs');\nconst _ = require('lodash');\nconst log = Log.global();\nconst pkg = require('../../package.json');\nconst rc = require('rc');\n\nclass CLI {\n  /**\n   * Parse the CLI arguments.\n   * @static\n   */\n  static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli)\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }\n  /**\n   * Create the CLI.\n   * @static\n   * @return {Liftoff} - An instance of Liftoff.\n   */\n  static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }\n  /**\n   * Launch the cli.\n   * @static\n   * @param {Object} - The parsed CLI arguments.\n   * @return {Promise<Stream>} - A promise to the stream.\n   */\n  static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }\n  /**\n   * Handles the result from the CLI.\n   * @static\n   */\n  static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const sources = source.split(',')\n      .map(path => path.trim())\n      .map(path => FS.normalize(path, rc('mrdoc', options)));\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: options.cwd }), options });\n    });\n  }\n}\n\nmodule.exports = CLI;\n"
            }
          },
          {
            "BJxhiTlL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst JSONC = require('./compilers/json/');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\n// const HTML = require('./compilers/html');\n\nclass Compiler {\n  constructor(options) {\n    this.options = options;\n  }\n  factory() {\n    const format = this.options.compiler.file.format;\n    // DEBUG: Compiler format\n    log.debug(Log.color.blue('Compiler format:'), format);\n    switch (format) {\n      case 'json':\n        return (new JSONC(this.options));\n      case 'html':\n        // return (new HTML(this.options));\n      default:\n        return null;\n    }\n  }\n}\nmodule.exports = Compiler;\n"
            }
          },
          {
            "Hy-2sae8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst JavaScript = require('./parsers/javascript/');\n\nclass Parser {\n  constructor(options) {\n    this.options = options;\n  }\n  factory() {\n    switch (this.options.parser.language) {\n      case 'js':\n      case 'javascript':\n        return (new JavaScript(this.options));\n      default:\n        return null;\n    }\n  }\n}\nmodule.exports = Parser;\n"
            }
          },
          {
            "Skfhjpl8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "extension.js",
                "ext": ".js",
                "name": "extension"
              },
              "source": "'use strict';\n\nclass Extension {\n  static find(language) {\n    return Extension.extensions()[language];\n  }\n  static extensions() {\n    return {\n      js: '.js',\n      javascript: '.js',\n      json: '.json',\n      html: '.html',\n      typescript: '.ts',\n    };\n  }\n}\n\nmodule.exports = Extension;\n"
            }
          },
          {
            "H17hjpxU": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "fs.js",
                "ext": ".js",
                "name": "fs"
              },
              "source": "'use strict';\nconst Path = require('path');\nconst Extension = require('./extension');\nconst isGlob = require('is-glob');\nconst _ = require('lodash');\n\nclass FS {\n  static normalize(path, options) {\n    // Check if the path is not in glob pattern.\n    if (!isGlob(path)) {\n      // Assume that Glob is used.\n      let isFile = false;\n      // Make sure the path is resolved.\n      let str = Path.resolve(options.mrdoc.cwd, path).replace('/', Path.sep);\n      // Check if the path is a file or directory.\n      if (_.isEmpty(Path.parse(path).ext)) {\n        // Check if the path has a '/' at the end.\n        str = str[str.length - 1] === Path.sep ?\n        str : `${str}${Path.sep}`;\n      } else isFile = true;\n      // Make sure the file or directory exists;\n      if (File.existsSync(str)) {\n        if (!isFile) {\n          // Check if the directory has sub-directories.\n          const hasSubDirs = File.readdirSync(str)\n          .filter(file =>\n            File.statSync(Path.join(str, file)).isDirectory()).length > 1;\n          // Get the file extension.\n          const extension = Extension.find(options.parser.language);\n          // Set the glob pattern based on 'hasSubDirs'.\n          str = hasSubDirs ?\n          `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\n        }\n      } else return null;\n      return str;\n    }\n    return path;\n  }\n}\n\nmodule.exports = FS;\n"
            }
          },
          {
            "H1V3i6xL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "log.js",
                "ext": ".js",
                "name": "log"
              },
              "source": "/* eslint-env node */\n'use strict';\n\n/* eslint-env node */\nconst Utils = require('mr-doc-utils');\nconst log = new Utils.Log();\nconst _ = require('lodash');\n\nclass Log {\n  constructor(options) {\n    if (options.silent) {\n      log.on('error', () => { /* NOOP */});\n      return log;\n    }\n    this.levels(options.level)\n    .forEach(level => {\n      if (level === 'error') this.error();\n      else this.other(level);\n    });\n    return log;\n  }\n  levels(level) {\n    const levels = _.isString(level) ? level.split(',') : level;\n    return levels\n    .map(i => i.replace(/\\s/g, ''));\n  }\n  error() {\n    log.on('error', function error() {\n      /* eslint-disable no-console */\n      const args = Array.prototype.slice.call(arguments);\n      args.unshift(log.color.cyan('mrdoc'));\n      console.log.apply(console, args.map(i => log.color.red(i)));\n      /* eslint-enable no-console */\n    });\n  }\n  other(level) {\n    log.on(level, function logger() {\n      /* eslint-disable no-console */\n      const args = Array.prototype.slice.call(arguments);\n      args.unshift(log.color.cyan('mrdoc'));\n      console.log.apply(console, args);\n      /* eslint-enable no-console */\n    });\n  }\n  /**\n   * Get the global instance of Log.\n   * @return {Log} - An instance of Log.\n   */\n  static global() {\n    log.color = Utils.Log.color;\n    return log;\n  }\n}\n\nmodule.exports = Log;\n"
            }
          },
          {
            "B1BhjpeL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "output.js",
                "ext": ".js",
                "name": "output"
              },
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nclass Output {\n  static handler(buffer, options) {\n    return function (callback) {\n      Output.format(buffer, options).forEach(Output.toStream(this, options));\n      callback();\n    };\n  }\n  static format(buffer, options) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler.file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n  static toBuffer(buffer) {\n    return (file, enc, callback) => {\n      buffer.push(file);\n      callback();\n    };\n  }\n  static toStream(context, options) {\n    const file = options.compiler.file;\n    return function (f) {\n      if (file.format === 'json' || file.format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (file.format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "BJUhiTxI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "source.js",
                "ext": ".js",
                "name": "source"
              },
              "source": "'use strict';\nconst ShortID = require('shortid');\nconst File = require('fs-extra');\nconst _ = require('lodash');\nconst Path = require('path');\n\nclass Source {\n  static create(files) {\n    // Process the files.\n    const result = files\n    .map(file => Source.processFile(file));\n    // Create references for each file.\n    const references = result\n    .map(file => Source.createReference(file));\n    // Process the references and attach it to each file.\n    return result\n    .map(file => Source.processReference(file, references));\n  }\n  static processFile(file) {\n    return {\n      id: ShortID.generate(),\n      cwd: file.cwd,\n      base: file.base.replace(file.cwd + Path.sep, ''),\n      path: Path.parse(file.path.replace(file.cwd + Path.sep, '')),\n      source: File.readFileSync(file.path, 'utf8'),\n      comments: undefined,\n    };\n  }\n  static createReference(file) {\n    return {\n      id: file.id,\n      cwd: file.cwd,\n      base: file.base,\n      path: file.path,\n      source: file.source,\n      comments: file.comments,\n    };\n  }\n  static processReference(file, references) {\n    return _.merge(file, {\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\n    });\n  }\n}\n\nmodule.exports = Source;\n"
            }
          },
          {
            "S1vnspgI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/engines",
                "base": "javascript.js",
                "ext": ".js",
                "name": "javascript"
              },
              "source": "'use strict';\n\nconst Babylon = require('babylon');\nconst Acorn = require('acorn');\nconst Espree = require('espree');\nconst ESCodeGen = require('escodegen');\nconst ESTraverse = require('estraverse');\nconst traverse = require('babel-traverse').default;\n\nconst opts = {\n  acorn: (version, comments, tokens) => ({\n    ecmaVersion: version,\n    locations: true,\n    onComment: comments,\n    onToken: tokens,\n    ranges: true,\n  }),\n  babylon: () => ({\n    allowImportExportEverywhere: true,\n    plugins: [\n      'jsx',\n      'flow',\n      'asyncFunctions',\n      'classConstructorCall',\n      'doExpressions',\n      'trailingFunctionCommas',\n      'objectRestSpread',\n      'decorators',\n      'classProperties',\n      'exportExtensions',\n      'exponentiationOperator',\n      'asyncGenerators',\n      'functionBind',\n      'functionSent',\n    ],\n    sourceType: 'module',\n  }),\n  espree: (version) => ({\n    attachComment: true,\n    comment: true,\n    ecmaFeatures: {\n      experimentalObjectRestSpread: true,\n      globalReturn: true,\n      impliedStrict: true,\n      jsx: true,\n    },\n    ecmaVersion: version,\n    loc: true,\n    range: true,\n    sourceType: 'module',\n    tokens: true,\n  }),\n};\n\nclass Engine {\n  constructor(options) {\n    this.options = options;\n    switch (this.options.engine) {\n      case 'acorn':\n        this.engine = Acorn;\n        break;\n      case 'espree':\n        this.engine = Espree;\n        break;\n      default:\n        this.engine = Babylon;\n        break;\n    }\n  }\n  parse(file) {\n    const comments = [];\n    const tokens = [];\n    try {\n      switch (this.options.engine) {\n        case 'acorn':\n          return ESCodeGen\n          .attachComments(this.engine.parse(file.source,\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\n        case 'espree':\n          return this.engine.parse(file.source, opts.espree(this.options.version));\n        default:\n          return this.engine.parse(file.source, opts.babylon());\n      }\n    } catch (error) {\n      throw (new Error(error));\n    }\n  }\n  static traverse(options, ast, callback) {\n    switch (options.engine) {\n      case 'babylon':\n        traverse(ast, {\n          enter: (path) => {\n            const node = path.node;\n            callback(node);\n          } });\n        break;\n      default:\n        ESTraverse.traverse(ast, {\n          /* eslint-disable no-param-reassign */\n          enter: (node) => {\n            if (node.type === 'Program') {\n              node = node.body[0];\n            }\n            callback(node);\n          } });\n          /* eslint-enable no-param-reassign */\n        break;\n    }\n  }\n}\nmodule.exports = Engine;\n"
            }
          },
          {
            "r1OhoagI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "SyY2jagI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass IParser {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser;\n  }\n  /**\n   * Parses the sources' comments into the desired output.\n   * @param  {Array<Object>} results - The files to parse.\n   * @return {Array<Object>} - The parsed comments.\n   */\n  /* eslint-disable no-unused-vars */\n  parse(sources) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = IParser;\n"
            }
          },
          {
            "Bk5nsalU": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/html",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\n\nclass HTML extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.comments = comments;\n  }\n}\nmodule.exports = HTML;\n"
            }
          },
          {
            "rJi2iTgI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/json",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "SJn3oplI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers/javascript",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n"
            }
          },
          {
            "Bkphopx8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers/javascript",
                "base": "synonyms.js",
                "ext": ".js",
                "name": "synonyms"
              },
              "source": "module.exports = {\n  arg: 'param',\n  argument: 'param',\n  constructor: 'class',\n  const: 'constant',\n  defaultvalue: 'default',\n  desc: 'description',\n  emits: 'fires',\n  exception: 'throws',\n  fileoverview: 'file',\n  func: 'function',\n  host: 'external',\n  linkcode: 'link',\n  linkplain: 'link',\n  virtual: 'abstract',\n  method: 'function',\n  overview: 'file',\n  prop: 'property',\n  return: 'returns',\n  var: 'member',\n};\n"
            }
          },
          {
            "H1R3spgL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/html/engines",
                "base": "theme.js",
                "ext": ".js",
                "name": "theme"
              },
              "source": "'use strict';\n\nclass Theme {\n  // constructor() {\n  //\n  // }\n  compile() {\n\n  }\n}\n\nmodule.exports = Theme;\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 16,
          "column": 2
        },
        "end": {
          "line": 18,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          16,
          18
        ]
      }
    }
  },
  {
    "description": "",
    "tags": [
      {
        "title": "class",
        "description": null,
        "lineNumber": 1,
        "type": null,
        "name": null
      },
      {
        "title": "param",
        "description": "The options for the compiler provided by mr-doc-utils/options",
        "lineNumber": 2,
        "type": {
          "type": "NameExpression",
          "name": "Object"
        },
        "name": "options"
      }
    ],
    "loc": {
      "start": {
        "line": 3,
        "column": 2
      },
      "end": {
        "line": 6,
        "column": 5
      }
    },
    "context": {
      "code": "constructor(options) {\n    this.options = options.parser;\n  }",
      "file": {
        "id": "SyY2jagI",
        "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
        "base": "src/",
        "path": {
          "root": "",
          "dir": "src/parser/parsers",
          "base": "interface.js",
          "ext": ".js",
          "name": "interface"
        },
        "source": "'use strict';\nclass IParser {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser;\n  }\n  /**\n   * Parses the sources' comments into the desired output.\n   * @param  {Array<Object>} results - The files to parse.\n   * @return {Array<Object>} - The parsed comments.\n   */\n  /* eslint-disable no-unused-vars */\n  parse(sources) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = IParser;\n",
        "ref": [
          {
            "BJ2i6eL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/cli",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "/* eslint-env node */\n'use strict';\n\nconst FS = require('../utils/fs');\nconst Log = require('../utils/log');\nconst Liftoff = require('liftoff');\nconst Option = require('mr-doc-utils').Option;\nconst Promise = require('bluebird');\nconst Yargs = require('yargs');\nconst ViynlFS = require('vinyl-fs');\nconst _ = require('lodash');\nconst log = Log.global();\nconst pkg = require('../../package.json');\nconst rc = require('rc');\n\nclass CLI {\n  /**\n   * Parse the CLI arguments.\n   * @static\n   */\n  static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli)\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }\n  /**\n   * Create the CLI.\n   * @static\n   * @return {Liftoff} - An instance of Liftoff.\n   */\n  static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }\n  /**\n   * Launch the cli.\n   * @static\n   * @param {Object} - The parsed CLI arguments.\n   * @return {Promise<Stream>} - A promise to the stream.\n   */\n  static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }\n  /**\n   * Handles the result from the CLI.\n   * @static\n   */\n  static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const sources = source.split(',')\n      .map(path => path.trim())\n      .map(path => FS.normalize(path, rc('mrdoc', options)));\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: options.cwd }), options });\n    });\n  }\n}\n\nmodule.exports = CLI;\n"
            }
          },
          {
            "BJxhiTlL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst JSONC = require('./compilers/json/');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\n// const HTML = require('./compilers/html');\n\nclass Compiler {\n  constructor(options) {\n    this.options = options;\n  }\n  factory() {\n    const format = this.options.compiler.file.format;\n    // DEBUG: Compiler format\n    log.debug(Log.color.blue('Compiler format:'), format);\n    switch (format) {\n      case 'json':\n        return (new JSONC(this.options));\n      case 'html':\n        // return (new HTML(this.options));\n      default:\n        return null;\n    }\n  }\n}\nmodule.exports = Compiler;\n"
            }
          },
          {
            "Hy-2sae8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst JavaScript = require('./parsers/javascript/');\n\nclass Parser {\n  constructor(options) {\n    this.options = options;\n  }\n  factory() {\n    switch (this.options.parser.language) {\n      case 'js':\n      case 'javascript':\n        return (new JavaScript(this.options));\n      default:\n        return null;\n    }\n  }\n}\nmodule.exports = Parser;\n"
            }
          },
          {
            "Skfhjpl8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "extension.js",
                "ext": ".js",
                "name": "extension"
              },
              "source": "'use strict';\n\nclass Extension {\n  static find(language) {\n    return Extension.extensions()[language];\n  }\n  static extensions() {\n    return {\n      js: '.js',\n      javascript: '.js',\n      json: '.json',\n      html: '.html',\n      typescript: '.ts',\n    };\n  }\n}\n\nmodule.exports = Extension;\n"
            }
          },
          {
            "H17hjpxU": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "fs.js",
                "ext": ".js",
                "name": "fs"
              },
              "source": "'use strict';\nconst Path = require('path');\nconst Extension = require('./extension');\nconst isGlob = require('is-glob');\nconst _ = require('lodash');\n\nclass FS {\n  static normalize(path, options) {\n    // Check if the path is not in glob pattern.\n    if (!isGlob(path)) {\n      // Assume that Glob is used.\n      let isFile = false;\n      // Make sure the path is resolved.\n      let str = Path.resolve(options.mrdoc.cwd, path).replace('/', Path.sep);\n      // Check if the path is a file or directory.\n      if (_.isEmpty(Path.parse(path).ext)) {\n        // Check if the path has a '/' at the end.\n        str = str[str.length - 1] === Path.sep ?\n        str : `${str}${Path.sep}`;\n      } else isFile = true;\n      // Make sure the file or directory exists;\n      if (File.existsSync(str)) {\n        if (!isFile) {\n          // Check if the directory has sub-directories.\n          const hasSubDirs = File.readdirSync(str)\n          .filter(file =>\n            File.statSync(Path.join(str, file)).isDirectory()).length > 1;\n          // Get the file extension.\n          const extension = Extension.find(options.parser.language);\n          // Set the glob pattern based on 'hasSubDirs'.\n          str = hasSubDirs ?\n          `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\n        }\n      } else return null;\n      return str;\n    }\n    return path;\n  }\n}\n\nmodule.exports = FS;\n"
            }
          },
          {
            "H1V3i6xL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "log.js",
                "ext": ".js",
                "name": "log"
              },
              "source": "/* eslint-env node */\n'use strict';\n\n/* eslint-env node */\nconst Utils = require('mr-doc-utils');\nconst log = new Utils.Log();\nconst _ = require('lodash');\n\nclass Log {\n  constructor(options) {\n    if (options.silent) {\n      log.on('error', () => { /* NOOP */});\n      return log;\n    }\n    this.levels(options.level)\n    .forEach(level => {\n      if (level === 'error') this.error();\n      else this.other(level);\n    });\n    return log;\n  }\n  levels(level) {\n    const levels = _.isString(level) ? level.split(',') : level;\n    return levels\n    .map(i => i.replace(/\\s/g, ''));\n  }\n  error() {\n    log.on('error', function error() {\n      /* eslint-disable no-console */\n      const args = Array.prototype.slice.call(arguments);\n      args.unshift(log.color.cyan('mrdoc'));\n      console.log.apply(console, args.map(i => log.color.red(i)));\n      /* eslint-enable no-console */\n    });\n  }\n  other(level) {\n    log.on(level, function logger() {\n      /* eslint-disable no-console */\n      const args = Array.prototype.slice.call(arguments);\n      args.unshift(log.color.cyan('mrdoc'));\n      console.log.apply(console, args);\n      /* eslint-enable no-console */\n    });\n  }\n  /**\n   * Get the global instance of Log.\n   * @return {Log} - An instance of Log.\n   */\n  static global() {\n    log.color = Utils.Log.color;\n    return log;\n  }\n}\n\nmodule.exports = Log;\n"
            }
          },
          {
            "B1BhjpeL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "output.js",
                "ext": ".js",
                "name": "output"
              },
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nclass Output {\n  static handler(buffer, options) {\n    return function (callback) {\n      Output.format(buffer, options).forEach(Output.toStream(this, options));\n      callback();\n    };\n  }\n  static format(buffer, options) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler.file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n  static toBuffer(buffer) {\n    return (file, enc, callback) => {\n      buffer.push(file);\n      callback();\n    };\n  }\n  static toStream(context, options) {\n    const file = options.compiler.file;\n    return function (f) {\n      if (file.format === 'json' || file.format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (file.format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "BJUhiTxI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "source.js",
                "ext": ".js",
                "name": "source"
              },
              "source": "'use strict';\nconst ShortID = require('shortid');\nconst File = require('fs-extra');\nconst _ = require('lodash');\nconst Path = require('path');\n\nclass Source {\n  static create(files) {\n    // Process the files.\n    const result = files\n    .map(file => Source.processFile(file));\n    // Create references for each file.\n    const references = result\n    .map(file => Source.createReference(file));\n    // Process the references and attach it to each file.\n    return result\n    .map(file => Source.processReference(file, references));\n  }\n  static processFile(file) {\n    return {\n      id: ShortID.generate(),\n      cwd: file.cwd,\n      base: file.base.replace(file.cwd + Path.sep, ''),\n      path: Path.parse(file.path.replace(file.cwd + Path.sep, '')),\n      source: File.readFileSync(file.path, 'utf8'),\n      comments: undefined,\n    };\n  }\n  static createReference(file) {\n    return {\n      id: file.id,\n      cwd: file.cwd,\n      base: file.base,\n      path: file.path,\n      source: file.source,\n      comments: file.comments,\n    };\n  }\n  static processReference(file, references) {\n    return _.merge(file, {\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\n    });\n  }\n}\n\nmodule.exports = Source;\n"
            }
          },
          {
            "S1vnspgI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/engines",
                "base": "javascript.js",
                "ext": ".js",
                "name": "javascript"
              },
              "source": "'use strict';\n\nconst Babylon = require('babylon');\nconst Acorn = require('acorn');\nconst Espree = require('espree');\nconst ESCodeGen = require('escodegen');\nconst ESTraverse = require('estraverse');\nconst traverse = require('babel-traverse').default;\n\nconst opts = {\n  acorn: (version, comments, tokens) => ({\n    ecmaVersion: version,\n    locations: true,\n    onComment: comments,\n    onToken: tokens,\n    ranges: true,\n  }),\n  babylon: () => ({\n    allowImportExportEverywhere: true,\n    plugins: [\n      'jsx',\n      'flow',\n      'asyncFunctions',\n      'classConstructorCall',\n      'doExpressions',\n      'trailingFunctionCommas',\n      'objectRestSpread',\n      'decorators',\n      'classProperties',\n      'exportExtensions',\n      'exponentiationOperator',\n      'asyncGenerators',\n      'functionBind',\n      'functionSent',\n    ],\n    sourceType: 'module',\n  }),\n  espree: (version) => ({\n    attachComment: true,\n    comment: true,\n    ecmaFeatures: {\n      experimentalObjectRestSpread: true,\n      globalReturn: true,\n      impliedStrict: true,\n      jsx: true,\n    },\n    ecmaVersion: version,\n    loc: true,\n    range: true,\n    sourceType: 'module',\n    tokens: true,\n  }),\n};\n\nclass Engine {\n  constructor(options) {\n    this.options = options;\n    switch (this.options.engine) {\n      case 'acorn':\n        this.engine = Acorn;\n        break;\n      case 'espree':\n        this.engine = Espree;\n        break;\n      default:\n        this.engine = Babylon;\n        break;\n    }\n  }\n  parse(file) {\n    const comments = [];\n    const tokens = [];\n    try {\n      switch (this.options.engine) {\n        case 'acorn':\n          return ESCodeGen\n          .attachComments(this.engine.parse(file.source,\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\n        case 'espree':\n          return this.engine.parse(file.source, opts.espree(this.options.version));\n        default:\n          return this.engine.parse(file.source, opts.babylon());\n      }\n    } catch (error) {\n      throw (new Error(error));\n    }\n  }\n  static traverse(options, ast, callback) {\n    switch (options.engine) {\n      case 'babylon':\n        traverse(ast, {\n          enter: (path) => {\n            const node = path.node;\n            callback(node);\n          } });\n        break;\n      default:\n        ESTraverse.traverse(ast, {\n          /* eslint-disable no-param-reassign */\n          enter: (node) => {\n            if (node.type === 'Program') {\n              node = node.body[0];\n            }\n            callback(node);\n          } });\n          /* eslint-enable no-param-reassign */\n        break;\n    }\n  }\n}\nmodule.exports = Engine;\n"
            }
          },
          {
            "r1OhoagI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "SyY2jagI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass IParser {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser;\n  }\n  /**\n   * Parses the sources' comments into the desired output.\n   * @param  {Array<Object>} results - The files to parse.\n   * @return {Array<Object>} - The parsed comments.\n   */\n  /* eslint-disable no-unused-vars */\n  parse(sources) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = IParser;\n"
            }
          },
          {
            "Bk5nsalU": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/html",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\n\nclass HTML extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.comments = comments;\n  }\n}\nmodule.exports = HTML;\n"
            }
          },
          {
            "rJi2iTgI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/json",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "SJn3oplI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers/javascript",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n"
            }
          },
          {
            "Bkphopx8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers/javascript",
                "base": "synonyms.js",
                "ext": ".js",
                "name": "synonyms"
              },
              "source": "module.exports = {\n  arg: 'param',\n  argument: 'param',\n  constructor: 'class',\n  const: 'constant',\n  defaultvalue: 'default',\n  desc: 'description',\n  emits: 'fires',\n  exception: 'throws',\n  fileoverview: 'file',\n  func: 'function',\n  host: 'external',\n  linkcode: 'link',\n  linkplain: 'link',\n  virtual: 'abstract',\n  method: 'function',\n  overview: 'file',\n  prop: 'property',\n  return: 'returns',\n  var: 'member',\n};\n"
            }
          },
          {
            "H1R3spgL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/html/engines",
                "base": "theme.js",
                "ext": ".js",
                "name": "theme"
              },
              "source": "'use strict';\n\nclass Theme {\n  // constructor() {\n  //\n  // }\n  compile() {\n\n  }\n}\n\nmodule.exports = Theme;\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 7,
          "column": 2
        },
        "end": {
          "line": 9,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          7,
          9
        ]
      }
    }
  },
  {
    "description": "Parses the sources' comments into the desired output.",
    "tags": [
      {
        "title": "param",
        "description": "The files to parse.",
        "lineNumber": 2,
        "type": {
          "type": "TypeApplication",
          "expression": {
            "type": "NameExpression",
            "name": "Array"
          },
          "applications": [
            {
              "type": "NameExpression",
              "name": "Object"
            }
          ]
        },
        "name": "results"
      },
      {
        "title": "returns",
        "description": "The parsed comments.",
        "lineNumber": 3,
        "type": {
          "type": "TypeApplication",
          "expression": {
            "type": "NameExpression",
            "name": "Array"
          },
          "applications": [
            {
              "type": "NameExpression",
              "name": "Object"
            }
          ]
        }
      }
    ],
    "loc": {
      "start": {
        "line": 10,
        "column": 2
      },
      "end": {
        "line": 14,
        "column": 5
      }
    },
    "context": {
      "code": "parse(sources) {\n    // ...\n  }",
      "file": {
        "id": "SyY2jagI",
        "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
        "base": "src/",
        "path": {
          "root": "",
          "dir": "src/parser/parsers",
          "base": "interface.js",
          "ext": ".js",
          "name": "interface"
        },
        "source": "'use strict';\nclass IParser {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser;\n  }\n  /**\n   * Parses the sources' comments into the desired output.\n   * @param  {Array<Object>} results - The files to parse.\n   * @return {Array<Object>} - The parsed comments.\n   */\n  /* eslint-disable no-unused-vars */\n  parse(sources) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = IParser;\n",
        "ref": [
          {
            "BJ2i6eL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/cli",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "/* eslint-env node */\n'use strict';\n\nconst FS = require('../utils/fs');\nconst Log = require('../utils/log');\nconst Liftoff = require('liftoff');\nconst Option = require('mr-doc-utils').Option;\nconst Promise = require('bluebird');\nconst Yargs = require('yargs');\nconst ViynlFS = require('vinyl-fs');\nconst _ = require('lodash');\nconst log = Log.global();\nconst pkg = require('../../package.json');\nconst rc = require('rc');\n\nclass CLI {\n  /**\n   * Parse the CLI arguments.\n   * @static\n   */\n  static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli)\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }\n  /**\n   * Create the CLI.\n   * @static\n   * @return {Liftoff} - An instance of Liftoff.\n   */\n  static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }\n  /**\n   * Launch the cli.\n   * @static\n   * @param {Object} - The parsed CLI arguments.\n   * @return {Promise<Stream>} - A promise to the stream.\n   */\n  static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }\n  /**\n   * Handles the result from the CLI.\n   * @static\n   */\n  static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const sources = source.split(',')\n      .map(path => path.trim())\n      .map(path => FS.normalize(path, rc('mrdoc', options)));\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: options.cwd }), options });\n    });\n  }\n}\n\nmodule.exports = CLI;\n"
            }
          },
          {
            "BJxhiTlL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst JSONC = require('./compilers/json/');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\n// const HTML = require('./compilers/html');\n\nclass Compiler {\n  constructor(options) {\n    this.options = options;\n  }\n  factory() {\n    const format = this.options.compiler.file.format;\n    // DEBUG: Compiler format\n    log.debug(Log.color.blue('Compiler format:'), format);\n    switch (format) {\n      case 'json':\n        return (new JSONC(this.options));\n      case 'html':\n        // return (new HTML(this.options));\n      default:\n        return null;\n    }\n  }\n}\nmodule.exports = Compiler;\n"
            }
          },
          {
            "Hy-2sae8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst JavaScript = require('./parsers/javascript/');\n\nclass Parser {\n  constructor(options) {\n    this.options = options;\n  }\n  factory() {\n    switch (this.options.parser.language) {\n      case 'js':\n      case 'javascript':\n        return (new JavaScript(this.options));\n      default:\n        return null;\n    }\n  }\n}\nmodule.exports = Parser;\n"
            }
          },
          {
            "Skfhjpl8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "extension.js",
                "ext": ".js",
                "name": "extension"
              },
              "source": "'use strict';\n\nclass Extension {\n  static find(language) {\n    return Extension.extensions()[language];\n  }\n  static extensions() {\n    return {\n      js: '.js',\n      javascript: '.js',\n      json: '.json',\n      html: '.html',\n      typescript: '.ts',\n    };\n  }\n}\n\nmodule.exports = Extension;\n"
            }
          },
          {
            "H17hjpxU": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "fs.js",
                "ext": ".js",
                "name": "fs"
              },
              "source": "'use strict';\nconst Path = require('path');\nconst Extension = require('./extension');\nconst isGlob = require('is-glob');\nconst _ = require('lodash');\n\nclass FS {\n  static normalize(path, options) {\n    // Check if the path is not in glob pattern.\n    if (!isGlob(path)) {\n      // Assume that Glob is used.\n      let isFile = false;\n      // Make sure the path is resolved.\n      let str = Path.resolve(options.mrdoc.cwd, path).replace('/', Path.sep);\n      // Check if the path is a file or directory.\n      if (_.isEmpty(Path.parse(path).ext)) {\n        // Check if the path has a '/' at the end.\n        str = str[str.length - 1] === Path.sep ?\n        str : `${str}${Path.sep}`;\n      } else isFile = true;\n      // Make sure the file or directory exists;\n      if (File.existsSync(str)) {\n        if (!isFile) {\n          // Check if the directory has sub-directories.\n          const hasSubDirs = File.readdirSync(str)\n          .filter(file =>\n            File.statSync(Path.join(str, file)).isDirectory()).length > 1;\n          // Get the file extension.\n          const extension = Extension.find(options.parser.language);\n          // Set the glob pattern based on 'hasSubDirs'.\n          str = hasSubDirs ?\n          `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\n        }\n      } else return null;\n      return str;\n    }\n    return path;\n  }\n}\n\nmodule.exports = FS;\n"
            }
          },
          {
            "H1V3i6xL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "log.js",
                "ext": ".js",
                "name": "log"
              },
              "source": "/* eslint-env node */\n'use strict';\n\n/* eslint-env node */\nconst Utils = require('mr-doc-utils');\nconst log = new Utils.Log();\nconst _ = require('lodash');\n\nclass Log {\n  constructor(options) {\n    if (options.silent) {\n      log.on('error', () => { /* NOOP */});\n      return log;\n    }\n    this.levels(options.level)\n    .forEach(level => {\n      if (level === 'error') this.error();\n      else this.other(level);\n    });\n    return log;\n  }\n  levels(level) {\n    const levels = _.isString(level) ? level.split(',') : level;\n    return levels\n    .map(i => i.replace(/\\s/g, ''));\n  }\n  error() {\n    log.on('error', function error() {\n      /* eslint-disable no-console */\n      const args = Array.prototype.slice.call(arguments);\n      args.unshift(log.color.cyan('mrdoc'));\n      console.log.apply(console, args.map(i => log.color.red(i)));\n      /* eslint-enable no-console */\n    });\n  }\n  other(level) {\n    log.on(level, function logger() {\n      /* eslint-disable no-console */\n      const args = Array.prototype.slice.call(arguments);\n      args.unshift(log.color.cyan('mrdoc'));\n      console.log.apply(console, args);\n      /* eslint-enable no-console */\n    });\n  }\n  /**\n   * Get the global instance of Log.\n   * @return {Log} - An instance of Log.\n   */\n  static global() {\n    log.color = Utils.Log.color;\n    return log;\n  }\n}\n\nmodule.exports = Log;\n"
            }
          },
          {
            "B1BhjpeL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "output.js",
                "ext": ".js",
                "name": "output"
              },
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nclass Output {\n  static handler(buffer, options) {\n    return function (callback) {\n      Output.format(buffer, options).forEach(Output.toStream(this, options));\n      callback();\n    };\n  }\n  static format(buffer, options) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler.file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n  static toBuffer(buffer) {\n    return (file, enc, callback) => {\n      buffer.push(file);\n      callback();\n    };\n  }\n  static toStream(context, options) {\n    const file = options.compiler.file;\n    return function (f) {\n      if (file.format === 'json' || file.format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (file.format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "BJUhiTxI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "source.js",
                "ext": ".js",
                "name": "source"
              },
              "source": "'use strict';\nconst ShortID = require('shortid');\nconst File = require('fs-extra');\nconst _ = require('lodash');\nconst Path = require('path');\n\nclass Source {\n  static create(files) {\n    // Process the files.\n    const result = files\n    .map(file => Source.processFile(file));\n    // Create references for each file.\n    const references = result\n    .map(file => Source.createReference(file));\n    // Process the references and attach it to each file.\n    return result\n    .map(file => Source.processReference(file, references));\n  }\n  static processFile(file) {\n    return {\n      id: ShortID.generate(),\n      cwd: file.cwd,\n      base: file.base.replace(file.cwd + Path.sep, ''),\n      path: Path.parse(file.path.replace(file.cwd + Path.sep, '')),\n      source: File.readFileSync(file.path, 'utf8'),\n      comments: undefined,\n    };\n  }\n  static createReference(file) {\n    return {\n      id: file.id,\n      cwd: file.cwd,\n      base: file.base,\n      path: file.path,\n      source: file.source,\n      comments: file.comments,\n    };\n  }\n  static processReference(file, references) {\n    return _.merge(file, {\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\n    });\n  }\n}\n\nmodule.exports = Source;\n"
            }
          },
          {
            "S1vnspgI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/engines",
                "base": "javascript.js",
                "ext": ".js",
                "name": "javascript"
              },
              "source": "'use strict';\n\nconst Babylon = require('babylon');\nconst Acorn = require('acorn');\nconst Espree = require('espree');\nconst ESCodeGen = require('escodegen');\nconst ESTraverse = require('estraverse');\nconst traverse = require('babel-traverse').default;\n\nconst opts = {\n  acorn: (version, comments, tokens) => ({\n    ecmaVersion: version,\n    locations: true,\n    onComment: comments,\n    onToken: tokens,\n    ranges: true,\n  }),\n  babylon: () => ({\n    allowImportExportEverywhere: true,\n    plugins: [\n      'jsx',\n      'flow',\n      'asyncFunctions',\n      'classConstructorCall',\n      'doExpressions',\n      'trailingFunctionCommas',\n      'objectRestSpread',\n      'decorators',\n      'classProperties',\n      'exportExtensions',\n      'exponentiationOperator',\n      'asyncGenerators',\n      'functionBind',\n      'functionSent',\n    ],\n    sourceType: 'module',\n  }),\n  espree: (version) => ({\n    attachComment: true,\n    comment: true,\n    ecmaFeatures: {\n      experimentalObjectRestSpread: true,\n      globalReturn: true,\n      impliedStrict: true,\n      jsx: true,\n    },\n    ecmaVersion: version,\n    loc: true,\n    range: true,\n    sourceType: 'module',\n    tokens: true,\n  }),\n};\n\nclass Engine {\n  constructor(options) {\n    this.options = options;\n    switch (this.options.engine) {\n      case 'acorn':\n        this.engine = Acorn;\n        break;\n      case 'espree':\n        this.engine = Espree;\n        break;\n      default:\n        this.engine = Babylon;\n        break;\n    }\n  }\n  parse(file) {\n    const comments = [];\n    const tokens = [];\n    try {\n      switch (this.options.engine) {\n        case 'acorn':\n          return ESCodeGen\n          .attachComments(this.engine.parse(file.source,\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\n        case 'espree':\n          return this.engine.parse(file.source, opts.espree(this.options.version));\n        default:\n          return this.engine.parse(file.source, opts.babylon());\n      }\n    } catch (error) {\n      throw (new Error(error));\n    }\n  }\n  static traverse(options, ast, callback) {\n    switch (options.engine) {\n      case 'babylon':\n        traverse(ast, {\n          enter: (path) => {\n            const node = path.node;\n            callback(node);\n          } });\n        break;\n      default:\n        ESTraverse.traverse(ast, {\n          /* eslint-disable no-param-reassign */\n          enter: (node) => {\n            if (node.type === 'Program') {\n              node = node.body[0];\n            }\n            callback(node);\n          } });\n          /* eslint-enable no-param-reassign */\n        break;\n    }\n  }\n}\nmodule.exports = Engine;\n"
            }
          },
          {
            "r1OhoagI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "SyY2jagI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass IParser {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser;\n  }\n  /**\n   * Parses the sources' comments into the desired output.\n   * @param  {Array<Object>} results - The files to parse.\n   * @return {Array<Object>} - The parsed comments.\n   */\n  /* eslint-disable no-unused-vars */\n  parse(sources) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = IParser;\n"
            }
          },
          {
            "Bk5nsalU": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/html",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\n\nclass HTML extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.comments = comments;\n  }\n}\nmodule.exports = HTML;\n"
            }
          },
          {
            "rJi2iTgI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/json",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "SJn3oplI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers/javascript",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n"
            }
          },
          {
            "Bkphopx8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers/javascript",
                "base": "synonyms.js",
                "ext": ".js",
                "name": "synonyms"
              },
              "source": "module.exports = {\n  arg: 'param',\n  argument: 'param',\n  constructor: 'class',\n  const: 'constant',\n  defaultvalue: 'default',\n  desc: 'description',\n  emits: 'fires',\n  exception: 'throws',\n  fileoverview: 'file',\n  func: 'function',\n  host: 'external',\n  linkcode: 'link',\n  linkplain: 'link',\n  virtual: 'abstract',\n  method: 'function',\n  overview: 'file',\n  prop: 'property',\n  return: 'returns',\n  var: 'member',\n};\n"
            }
          },
          {
            "H1R3spgL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/html/engines",
                "base": "theme.js",
                "ext": ".js",
                "name": "theme"
              },
              "source": "'use strict';\n\nclass Theme {\n  // constructor() {\n  //\n  // }\n  compile() {\n\n  }\n}\n\nmodule.exports = Theme;\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 16,
          "column": 2
        },
        "end": {
          "line": 18,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          16,
          18
        ]
      }
    }
  },
  {
    "description": "Parse the file.",
    "tags": [
      {
        "title": "param",
        "description": "The file to parse.",
        "lineNumber": 2,
        "type": null,
        "name": "Object"
      }
    ],
    "loc": {
      "start": {
        "line": 19,
        "column": 2
      },
      "end": {
        "line": 22,
        "column": 5
      }
    },
    "context": {
      "code": "parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }",
      "file": {
        "id": "SJn3oplI",
        "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
        "base": "src/",
        "path": {
          "root": "",
          "dir": "src/parser/parsers/javascript",
          "base": "index.js",
          "ext": ".js",
          "name": "index"
        },
        "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n",
        "ref": [
          {
            "BJ2i6eL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/cli",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "/* eslint-env node */\n'use strict';\n\nconst FS = require('../utils/fs');\nconst Log = require('../utils/log');\nconst Liftoff = require('liftoff');\nconst Option = require('mr-doc-utils').Option;\nconst Promise = require('bluebird');\nconst Yargs = require('yargs');\nconst ViynlFS = require('vinyl-fs');\nconst _ = require('lodash');\nconst log = Log.global();\nconst pkg = require('../../package.json');\nconst rc = require('rc');\n\nclass CLI {\n  /**\n   * Parse the CLI arguments.\n   * @static\n   */\n  static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli)\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }\n  /**\n   * Create the CLI.\n   * @static\n   * @return {Liftoff} - An instance of Liftoff.\n   */\n  static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }\n  /**\n   * Launch the cli.\n   * @static\n   * @param {Object} - The parsed CLI arguments.\n   * @return {Promise<Stream>} - A promise to the stream.\n   */\n  static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }\n  /**\n   * Handles the result from the CLI.\n   * @static\n   */\n  static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const sources = source.split(',')\n      .map(path => path.trim())\n      .map(path => FS.normalize(path, rc('mrdoc', options)));\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: options.cwd }), options });\n    });\n  }\n}\n\nmodule.exports = CLI;\n"
            }
          },
          {
            "BJxhiTlL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst JSONC = require('./compilers/json/');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\n// const HTML = require('./compilers/html');\n\nclass Compiler {\n  constructor(options) {\n    this.options = options;\n  }\n  factory() {\n    const format = this.options.compiler.file.format;\n    // DEBUG: Compiler format\n    log.debug(Log.color.blue('Compiler format:'), format);\n    switch (format) {\n      case 'json':\n        return (new JSONC(this.options));\n      case 'html':\n        // return (new HTML(this.options));\n      default:\n        return null;\n    }\n  }\n}\nmodule.exports = Compiler;\n"
            }
          },
          {
            "Hy-2sae8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst JavaScript = require('./parsers/javascript/');\n\nclass Parser {\n  constructor(options) {\n    this.options = options;\n  }\n  factory() {\n    switch (this.options.parser.language) {\n      case 'js':\n      case 'javascript':\n        return (new JavaScript(this.options));\n      default:\n        return null;\n    }\n  }\n}\nmodule.exports = Parser;\n"
            }
          },
          {
            "Skfhjpl8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "extension.js",
                "ext": ".js",
                "name": "extension"
              },
              "source": "'use strict';\n\nclass Extension {\n  static find(language) {\n    return Extension.extensions()[language];\n  }\n  static extensions() {\n    return {\n      js: '.js',\n      javascript: '.js',\n      json: '.json',\n      html: '.html',\n      typescript: '.ts',\n    };\n  }\n}\n\nmodule.exports = Extension;\n"
            }
          },
          {
            "H17hjpxU": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "fs.js",
                "ext": ".js",
                "name": "fs"
              },
              "source": "'use strict';\nconst Path = require('path');\nconst Extension = require('./extension');\nconst isGlob = require('is-glob');\nconst _ = require('lodash');\n\nclass FS {\n  static normalize(path, options) {\n    // Check if the path is not in glob pattern.\n    if (!isGlob(path)) {\n      // Assume that Glob is used.\n      let isFile = false;\n      // Make sure the path is resolved.\n      let str = Path.resolve(options.mrdoc.cwd, path).replace('/', Path.sep);\n      // Check if the path is a file or directory.\n      if (_.isEmpty(Path.parse(path).ext)) {\n        // Check if the path has a '/' at the end.\n        str = str[str.length - 1] === Path.sep ?\n        str : `${str}${Path.sep}`;\n      } else isFile = true;\n      // Make sure the file or directory exists;\n      if (File.existsSync(str)) {\n        if (!isFile) {\n          // Check if the directory has sub-directories.\n          const hasSubDirs = File.readdirSync(str)\n          .filter(file =>\n            File.statSync(Path.join(str, file)).isDirectory()).length > 1;\n          // Get the file extension.\n          const extension = Extension.find(options.parser.language);\n          // Set the glob pattern based on 'hasSubDirs'.\n          str = hasSubDirs ?\n          `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\n        }\n      } else return null;\n      return str;\n    }\n    return path;\n  }\n}\n\nmodule.exports = FS;\n"
            }
          },
          {
            "H1V3i6xL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "log.js",
                "ext": ".js",
                "name": "log"
              },
              "source": "/* eslint-env node */\n'use strict';\n\n/* eslint-env node */\nconst Utils = require('mr-doc-utils');\nconst log = new Utils.Log();\nconst _ = require('lodash');\n\nclass Log {\n  constructor(options) {\n    if (options.silent) {\n      log.on('error', () => { /* NOOP */});\n      return log;\n    }\n    this.levels(options.level)\n    .forEach(level => {\n      if (level === 'error') this.error();\n      else this.other(level);\n    });\n    return log;\n  }\n  levels(level) {\n    const levels = _.isString(level) ? level.split(',') : level;\n    return levels\n    .map(i => i.replace(/\\s/g, ''));\n  }\n  error() {\n    log.on('error', function error() {\n      /* eslint-disable no-console */\n      const args = Array.prototype.slice.call(arguments);\n      args.unshift(log.color.cyan('mrdoc'));\n      console.log.apply(console, args.map(i => log.color.red(i)));\n      /* eslint-enable no-console */\n    });\n  }\n  other(level) {\n    log.on(level, function logger() {\n      /* eslint-disable no-console */\n      const args = Array.prototype.slice.call(arguments);\n      args.unshift(log.color.cyan('mrdoc'));\n      console.log.apply(console, args);\n      /* eslint-enable no-console */\n    });\n  }\n  /**\n   * Get the global instance of Log.\n   * @return {Log} - An instance of Log.\n   */\n  static global() {\n    log.color = Utils.Log.color;\n    return log;\n  }\n}\n\nmodule.exports = Log;\n"
            }
          },
          {
            "B1BhjpeL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "output.js",
                "ext": ".js",
                "name": "output"
              },
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nclass Output {\n  static handler(buffer, options) {\n    return function (callback) {\n      Output.format(buffer, options).forEach(Output.toStream(this, options));\n      callback();\n    };\n  }\n  static format(buffer, options) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler.file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n  static toBuffer(buffer) {\n    return (file, enc, callback) => {\n      buffer.push(file);\n      callback();\n    };\n  }\n  static toStream(context, options) {\n    const file = options.compiler.file;\n    return function (f) {\n      if (file.format === 'json' || file.format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (file.format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "BJUhiTxI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "source.js",
                "ext": ".js",
                "name": "source"
              },
              "source": "'use strict';\nconst ShortID = require('shortid');\nconst File = require('fs-extra');\nconst _ = require('lodash');\nconst Path = require('path');\n\nclass Source {\n  static create(files) {\n    // Process the files.\n    const result = files\n    .map(file => Source.processFile(file));\n    // Create references for each file.\n    const references = result\n    .map(file => Source.createReference(file));\n    // Process the references and attach it to each file.\n    return result\n    .map(file => Source.processReference(file, references));\n  }\n  static processFile(file) {\n    return {\n      id: ShortID.generate(),\n      cwd: file.cwd,\n      base: file.base.replace(file.cwd + Path.sep, ''),\n      path: Path.parse(file.path.replace(file.cwd + Path.sep, '')),\n      source: File.readFileSync(file.path, 'utf8'),\n      comments: undefined,\n    };\n  }\n  static createReference(file) {\n    return {\n      id: file.id,\n      cwd: file.cwd,\n      base: file.base,\n      path: file.path,\n      source: file.source,\n      comments: file.comments,\n    };\n  }\n  static processReference(file, references) {\n    return _.merge(file, {\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\n    });\n  }\n}\n\nmodule.exports = Source;\n"
            }
          },
          {
            "S1vnspgI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/engines",
                "base": "javascript.js",
                "ext": ".js",
                "name": "javascript"
              },
              "source": "'use strict';\n\nconst Babylon = require('babylon');\nconst Acorn = require('acorn');\nconst Espree = require('espree');\nconst ESCodeGen = require('escodegen');\nconst ESTraverse = require('estraverse');\nconst traverse = require('babel-traverse').default;\n\nconst opts = {\n  acorn: (version, comments, tokens) => ({\n    ecmaVersion: version,\n    locations: true,\n    onComment: comments,\n    onToken: tokens,\n    ranges: true,\n  }),\n  babylon: () => ({\n    allowImportExportEverywhere: true,\n    plugins: [\n      'jsx',\n      'flow',\n      'asyncFunctions',\n      'classConstructorCall',\n      'doExpressions',\n      'trailingFunctionCommas',\n      'objectRestSpread',\n      'decorators',\n      'classProperties',\n      'exportExtensions',\n      'exponentiationOperator',\n      'asyncGenerators',\n      'functionBind',\n      'functionSent',\n    ],\n    sourceType: 'module',\n  }),\n  espree: (version) => ({\n    attachComment: true,\n    comment: true,\n    ecmaFeatures: {\n      experimentalObjectRestSpread: true,\n      globalReturn: true,\n      impliedStrict: true,\n      jsx: true,\n    },\n    ecmaVersion: version,\n    loc: true,\n    range: true,\n    sourceType: 'module',\n    tokens: true,\n  }),\n};\n\nclass Engine {\n  constructor(options) {\n    this.options = options;\n    switch (this.options.engine) {\n      case 'acorn':\n        this.engine = Acorn;\n        break;\n      case 'espree':\n        this.engine = Espree;\n        break;\n      default:\n        this.engine = Babylon;\n        break;\n    }\n  }\n  parse(file) {\n    const comments = [];\n    const tokens = [];\n    try {\n      switch (this.options.engine) {\n        case 'acorn':\n          return ESCodeGen\n          .attachComments(this.engine.parse(file.source,\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\n        case 'espree':\n          return this.engine.parse(file.source, opts.espree(this.options.version));\n        default:\n          return this.engine.parse(file.source, opts.babylon());\n      }\n    } catch (error) {\n      throw (new Error(error));\n    }\n  }\n  static traverse(options, ast, callback) {\n    switch (options.engine) {\n      case 'babylon':\n        traverse(ast, {\n          enter: (path) => {\n            const node = path.node;\n            callback(node);\n          } });\n        break;\n      default:\n        ESTraverse.traverse(ast, {\n          /* eslint-disable no-param-reassign */\n          enter: (node) => {\n            if (node.type === 'Program') {\n              node = node.body[0];\n            }\n            callback(node);\n          } });\n          /* eslint-enable no-param-reassign */\n        break;\n    }\n  }\n}\nmodule.exports = Engine;\n"
            }
          },
          {
            "r1OhoagI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "SyY2jagI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass IParser {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser;\n  }\n  /**\n   * Parses the sources' comments into the desired output.\n   * @param  {Array<Object>} results - The files to parse.\n   * @return {Array<Object>} - The parsed comments.\n   */\n  /* eslint-disable no-unused-vars */\n  parse(sources) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = IParser;\n"
            }
          },
          {
            "Bk5nsalU": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/html",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\n\nclass HTML extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.comments = comments;\n  }\n}\nmodule.exports = HTML;\n"
            }
          },
          {
            "rJi2iTgI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/json",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "SJn3oplI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers/javascript",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n"
            }
          },
          {
            "Bkphopx8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers/javascript",
                "base": "synonyms.js",
                "ext": ".js",
                "name": "synonyms"
              },
              "source": "module.exports = {\n  arg: 'param',\n  argument: 'param',\n  constructor: 'class',\n  const: 'constant',\n  defaultvalue: 'default',\n  desc: 'description',\n  emits: 'fires',\n  exception: 'throws',\n  fileoverview: 'file',\n  func: 'function',\n  host: 'external',\n  linkcode: 'link',\n  linkplain: 'link',\n  virtual: 'abstract',\n  method: 'function',\n  overview: 'file',\n  prop: 'property',\n  return: 'returns',\n  var: 'member',\n};\n"
            }
          },
          {
            "H1R3spgL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/html/engines",
                "base": "theme.js",
                "ext": ".js",
                "name": "theme"
              },
              "source": "'use strict';\n\nclass Theme {\n  // constructor() {\n  //\n  // }\n  compile() {\n\n  }\n}\n\nmodule.exports = Theme;\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 23,
          "column": 2
        },
        "end": {
          "line": 34,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          23,
          34
        ]
      }
    }
  },
  {
    "description": "Walk the comments.",
    "tags": [
      {
        "title": "param",
        "description": "The comment type and context to walk.",
        "lineNumber": 2,
        "type": null,
        "name": "Object"
      }
    ],
    "loc": {
      "start": {
        "line": 35,
        "column": 2
      },
      "end": {
        "line": 38,
        "column": 5
      }
    },
    "context": {
      "code": "walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }",
      "file": {
        "id": "SJn3oplI",
        "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
        "base": "src/",
        "path": {
          "root": "",
          "dir": "src/parser/parsers/javascript",
          "base": "index.js",
          "ext": ".js",
          "name": "index"
        },
        "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n",
        "ref": [
          {
            "BJ2i6eL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/cli",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "/* eslint-env node */\n'use strict';\n\nconst FS = require('../utils/fs');\nconst Log = require('../utils/log');\nconst Liftoff = require('liftoff');\nconst Option = require('mr-doc-utils').Option;\nconst Promise = require('bluebird');\nconst Yargs = require('yargs');\nconst ViynlFS = require('vinyl-fs');\nconst _ = require('lodash');\nconst log = Log.global();\nconst pkg = require('../../package.json');\nconst rc = require('rc');\n\nclass CLI {\n  /**\n   * Parse the CLI arguments.\n   * @static\n   */\n  static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli)\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }\n  /**\n   * Create the CLI.\n   * @static\n   * @return {Liftoff} - An instance of Liftoff.\n   */\n  static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }\n  /**\n   * Launch the cli.\n   * @static\n   * @param {Object} - The parsed CLI arguments.\n   * @return {Promise<Stream>} - A promise to the stream.\n   */\n  static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }\n  /**\n   * Handles the result from the CLI.\n   * @static\n   */\n  static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const sources = source.split(',')\n      .map(path => path.trim())\n      .map(path => FS.normalize(path, rc('mrdoc', options)));\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: options.cwd }), options });\n    });\n  }\n}\n\nmodule.exports = CLI;\n"
            }
          },
          {
            "BJxhiTlL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst JSONC = require('./compilers/json/');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\n// const HTML = require('./compilers/html');\n\nclass Compiler {\n  constructor(options) {\n    this.options = options;\n  }\n  factory() {\n    const format = this.options.compiler.file.format;\n    // DEBUG: Compiler format\n    log.debug(Log.color.blue('Compiler format:'), format);\n    switch (format) {\n      case 'json':\n        return (new JSONC(this.options));\n      case 'html':\n        // return (new HTML(this.options));\n      default:\n        return null;\n    }\n  }\n}\nmodule.exports = Compiler;\n"
            }
          },
          {
            "Hy-2sae8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst JavaScript = require('./parsers/javascript/');\n\nclass Parser {\n  constructor(options) {\n    this.options = options;\n  }\n  factory() {\n    switch (this.options.parser.language) {\n      case 'js':\n      case 'javascript':\n        return (new JavaScript(this.options));\n      default:\n        return null;\n    }\n  }\n}\nmodule.exports = Parser;\n"
            }
          },
          {
            "Skfhjpl8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "extension.js",
                "ext": ".js",
                "name": "extension"
              },
              "source": "'use strict';\n\nclass Extension {\n  static find(language) {\n    return Extension.extensions()[language];\n  }\n  static extensions() {\n    return {\n      js: '.js',\n      javascript: '.js',\n      json: '.json',\n      html: '.html',\n      typescript: '.ts',\n    };\n  }\n}\n\nmodule.exports = Extension;\n"
            }
          },
          {
            "H17hjpxU": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "fs.js",
                "ext": ".js",
                "name": "fs"
              },
              "source": "'use strict';\nconst Path = require('path');\nconst Extension = require('./extension');\nconst isGlob = require('is-glob');\nconst _ = require('lodash');\n\nclass FS {\n  static normalize(path, options) {\n    // Check if the path is not in glob pattern.\n    if (!isGlob(path)) {\n      // Assume that Glob is used.\n      let isFile = false;\n      // Make sure the path is resolved.\n      let str = Path.resolve(options.mrdoc.cwd, path).replace('/', Path.sep);\n      // Check if the path is a file or directory.\n      if (_.isEmpty(Path.parse(path).ext)) {\n        // Check if the path has a '/' at the end.\n        str = str[str.length - 1] === Path.sep ?\n        str : `${str}${Path.sep}`;\n      } else isFile = true;\n      // Make sure the file or directory exists;\n      if (File.existsSync(str)) {\n        if (!isFile) {\n          // Check if the directory has sub-directories.\n          const hasSubDirs = File.readdirSync(str)\n          .filter(file =>\n            File.statSync(Path.join(str, file)).isDirectory()).length > 1;\n          // Get the file extension.\n          const extension = Extension.find(options.parser.language);\n          // Set the glob pattern based on 'hasSubDirs'.\n          str = hasSubDirs ?\n          `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\n        }\n      } else return null;\n      return str;\n    }\n    return path;\n  }\n}\n\nmodule.exports = FS;\n"
            }
          },
          {
            "H1V3i6xL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "log.js",
                "ext": ".js",
                "name": "log"
              },
              "source": "/* eslint-env node */\n'use strict';\n\n/* eslint-env node */\nconst Utils = require('mr-doc-utils');\nconst log = new Utils.Log();\nconst _ = require('lodash');\n\nclass Log {\n  constructor(options) {\n    if (options.silent) {\n      log.on('error', () => { /* NOOP */});\n      return log;\n    }\n    this.levels(options.level)\n    .forEach(level => {\n      if (level === 'error') this.error();\n      else this.other(level);\n    });\n    return log;\n  }\n  levels(level) {\n    const levels = _.isString(level) ? level.split(',') : level;\n    return levels\n    .map(i => i.replace(/\\s/g, ''));\n  }\n  error() {\n    log.on('error', function error() {\n      /* eslint-disable no-console */\n      const args = Array.prototype.slice.call(arguments);\n      args.unshift(log.color.cyan('mrdoc'));\n      console.log.apply(console, args.map(i => log.color.red(i)));\n      /* eslint-enable no-console */\n    });\n  }\n  other(level) {\n    log.on(level, function logger() {\n      /* eslint-disable no-console */\n      const args = Array.prototype.slice.call(arguments);\n      args.unshift(log.color.cyan('mrdoc'));\n      console.log.apply(console, args);\n      /* eslint-enable no-console */\n    });\n  }\n  /**\n   * Get the global instance of Log.\n   * @return {Log} - An instance of Log.\n   */\n  static global() {\n    log.color = Utils.Log.color;\n    return log;\n  }\n}\n\nmodule.exports = Log;\n"
            }
          },
          {
            "B1BhjpeL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "output.js",
                "ext": ".js",
                "name": "output"
              },
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nclass Output {\n  static handler(buffer, options) {\n    return function (callback) {\n      Output.format(buffer, options).forEach(Output.toStream(this, options));\n      callback();\n    };\n  }\n  static format(buffer, options) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler.file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n  static toBuffer(buffer) {\n    return (file, enc, callback) => {\n      buffer.push(file);\n      callback();\n    };\n  }\n  static toStream(context, options) {\n    const file = options.compiler.file;\n    return function (f) {\n      if (file.format === 'json' || file.format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (file.format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "BJUhiTxI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "source.js",
                "ext": ".js",
                "name": "source"
              },
              "source": "'use strict';\nconst ShortID = require('shortid');\nconst File = require('fs-extra');\nconst _ = require('lodash');\nconst Path = require('path');\n\nclass Source {\n  static create(files) {\n    // Process the files.\n    const result = files\n    .map(file => Source.processFile(file));\n    // Create references for each file.\n    const references = result\n    .map(file => Source.createReference(file));\n    // Process the references and attach it to each file.\n    return result\n    .map(file => Source.processReference(file, references));\n  }\n  static processFile(file) {\n    return {\n      id: ShortID.generate(),\n      cwd: file.cwd,\n      base: file.base.replace(file.cwd + Path.sep, ''),\n      path: Path.parse(file.path.replace(file.cwd + Path.sep, '')),\n      source: File.readFileSync(file.path, 'utf8'),\n      comments: undefined,\n    };\n  }\n  static createReference(file) {\n    return {\n      id: file.id,\n      cwd: file.cwd,\n      base: file.base,\n      path: file.path,\n      source: file.source,\n      comments: file.comments,\n    };\n  }\n  static processReference(file, references) {\n    return _.merge(file, {\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\n    });\n  }\n}\n\nmodule.exports = Source;\n"
            }
          },
          {
            "S1vnspgI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/engines",
                "base": "javascript.js",
                "ext": ".js",
                "name": "javascript"
              },
              "source": "'use strict';\n\nconst Babylon = require('babylon');\nconst Acorn = require('acorn');\nconst Espree = require('espree');\nconst ESCodeGen = require('escodegen');\nconst ESTraverse = require('estraverse');\nconst traverse = require('babel-traverse').default;\n\nconst opts = {\n  acorn: (version, comments, tokens) => ({\n    ecmaVersion: version,\n    locations: true,\n    onComment: comments,\n    onToken: tokens,\n    ranges: true,\n  }),\n  babylon: () => ({\n    allowImportExportEverywhere: true,\n    plugins: [\n      'jsx',\n      'flow',\n      'asyncFunctions',\n      'classConstructorCall',\n      'doExpressions',\n      'trailingFunctionCommas',\n      'objectRestSpread',\n      'decorators',\n      'classProperties',\n      'exportExtensions',\n      'exponentiationOperator',\n      'asyncGenerators',\n      'functionBind',\n      'functionSent',\n    ],\n    sourceType: 'module',\n  }),\n  espree: (version) => ({\n    attachComment: true,\n    comment: true,\n    ecmaFeatures: {\n      experimentalObjectRestSpread: true,\n      globalReturn: true,\n      impliedStrict: true,\n      jsx: true,\n    },\n    ecmaVersion: version,\n    loc: true,\n    range: true,\n    sourceType: 'module',\n    tokens: true,\n  }),\n};\n\nclass Engine {\n  constructor(options) {\n    this.options = options;\n    switch (this.options.engine) {\n      case 'acorn':\n        this.engine = Acorn;\n        break;\n      case 'espree':\n        this.engine = Espree;\n        break;\n      default:\n        this.engine = Babylon;\n        break;\n    }\n  }\n  parse(file) {\n    const comments = [];\n    const tokens = [];\n    try {\n      switch (this.options.engine) {\n        case 'acorn':\n          return ESCodeGen\n          .attachComments(this.engine.parse(file.source,\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\n        case 'espree':\n          return this.engine.parse(file.source, opts.espree(this.options.version));\n        default:\n          return this.engine.parse(file.source, opts.babylon());\n      }\n    } catch (error) {\n      throw (new Error(error));\n    }\n  }\n  static traverse(options, ast, callback) {\n    switch (options.engine) {\n      case 'babylon':\n        traverse(ast, {\n          enter: (path) => {\n            const node = path.node;\n            callback(node);\n          } });\n        break;\n      default:\n        ESTraverse.traverse(ast, {\n          /* eslint-disable no-param-reassign */\n          enter: (node) => {\n            if (node.type === 'Program') {\n              node = node.body[0];\n            }\n            callback(node);\n          } });\n          /* eslint-enable no-param-reassign */\n        break;\n    }\n  }\n}\nmodule.exports = Engine;\n"
            }
          },
          {
            "r1OhoagI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "SyY2jagI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass IParser {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser;\n  }\n  /**\n   * Parses the sources' comments into the desired output.\n   * @param  {Array<Object>} results - The files to parse.\n   * @return {Array<Object>} - The parsed comments.\n   */\n  /* eslint-disable no-unused-vars */\n  parse(sources) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = IParser;\n"
            }
          },
          {
            "Bk5nsalU": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/html",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\n\nclass HTML extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.comments = comments;\n  }\n}\nmodule.exports = HTML;\n"
            }
          },
          {
            "rJi2iTgI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/json",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "SJn3oplI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers/javascript",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n"
            }
          },
          {
            "Bkphopx8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers/javascript",
                "base": "synonyms.js",
                "ext": ".js",
                "name": "synonyms"
              },
              "source": "module.exports = {\n  arg: 'param',\n  argument: 'param',\n  constructor: 'class',\n  const: 'constant',\n  defaultvalue: 'default',\n  desc: 'description',\n  emits: 'fires',\n  exception: 'throws',\n  fileoverview: 'file',\n  func: 'function',\n  host: 'external',\n  linkcode: 'link',\n  linkplain: 'link',\n  virtual: 'abstract',\n  method: 'function',\n  overview: 'file',\n  prop: 'property',\n  return: 'returns',\n  var: 'member',\n};\n"
            }
          },
          {
            "H1R3spgL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/html/engines",
                "base": "theme.js",
                "ext": ".js",
                "name": "theme"
              },
              "source": "'use strict';\n\nclass Theme {\n  // constructor() {\n  //\n  // }\n  compile() {\n\n  }\n}\n\nmodule.exports = Theme;\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 39,
          "column": 2
        },
        "end": {
          "line": 43,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          39,
          43
        ]
      }
    }
  },
  {
    "description": "Parse the comment.",
    "tags": [
      {
        "title": "param",
        "description": "The current node.",
        "lineNumber": 2,
        "type": null,
        "name": "Node"
      },
      {
        "title": "param",
        "description": "The truth value on whether to include the context.",
        "lineNumber": 3,
        "type": null,
        "name": "Boolean"
      }
    ],
    "loc": {
      "start": {
        "line": 44,
        "column": 2
      },
      "end": {
        "line": 48,
        "column": 5
      }
    },
    "context": {
      "code": "parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }",
      "file": {
        "id": "SJn3oplI",
        "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
        "base": "src/",
        "path": {
          "root": "",
          "dir": "src/parser/parsers/javascript",
          "base": "index.js",
          "ext": ".js",
          "name": "index"
        },
        "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n",
        "ref": [
          {
            "BJ2i6eL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/cli",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "/* eslint-env node */\n'use strict';\n\nconst FS = require('../utils/fs');\nconst Log = require('../utils/log');\nconst Liftoff = require('liftoff');\nconst Option = require('mr-doc-utils').Option;\nconst Promise = require('bluebird');\nconst Yargs = require('yargs');\nconst ViynlFS = require('vinyl-fs');\nconst _ = require('lodash');\nconst log = Log.global();\nconst pkg = require('../../package.json');\nconst rc = require('rc');\n\nclass CLI {\n  /**\n   * Parse the CLI arguments.\n   * @static\n   */\n  static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli)\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }\n  /**\n   * Create the CLI.\n   * @static\n   * @return {Liftoff} - An instance of Liftoff.\n   */\n  static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }\n  /**\n   * Launch the cli.\n   * @static\n   * @param {Object} - The parsed CLI arguments.\n   * @return {Promise<Stream>} - A promise to the stream.\n   */\n  static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }\n  /**\n   * Handles the result from the CLI.\n   * @static\n   */\n  static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const sources = source.split(',')\n      .map(path => path.trim())\n      .map(path => FS.normalize(path, rc('mrdoc', options)));\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: options.cwd }), options });\n    });\n  }\n}\n\nmodule.exports = CLI;\n"
            }
          },
          {
            "BJxhiTlL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst JSONC = require('./compilers/json/');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\n// const HTML = require('./compilers/html');\n\nclass Compiler {\n  constructor(options) {\n    this.options = options;\n  }\n  factory() {\n    const format = this.options.compiler.file.format;\n    // DEBUG: Compiler format\n    log.debug(Log.color.blue('Compiler format:'), format);\n    switch (format) {\n      case 'json':\n        return (new JSONC(this.options));\n      case 'html':\n        // return (new HTML(this.options));\n      default:\n        return null;\n    }\n  }\n}\nmodule.exports = Compiler;\n"
            }
          },
          {
            "Hy-2sae8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst JavaScript = require('./parsers/javascript/');\n\nclass Parser {\n  constructor(options) {\n    this.options = options;\n  }\n  factory() {\n    switch (this.options.parser.language) {\n      case 'js':\n      case 'javascript':\n        return (new JavaScript(this.options));\n      default:\n        return null;\n    }\n  }\n}\nmodule.exports = Parser;\n"
            }
          },
          {
            "Skfhjpl8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "extension.js",
                "ext": ".js",
                "name": "extension"
              },
              "source": "'use strict';\n\nclass Extension {\n  static find(language) {\n    return Extension.extensions()[language];\n  }\n  static extensions() {\n    return {\n      js: '.js',\n      javascript: '.js',\n      json: '.json',\n      html: '.html',\n      typescript: '.ts',\n    };\n  }\n}\n\nmodule.exports = Extension;\n"
            }
          },
          {
            "H17hjpxU": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "fs.js",
                "ext": ".js",
                "name": "fs"
              },
              "source": "'use strict';\nconst Path = require('path');\nconst Extension = require('./extension');\nconst isGlob = require('is-glob');\nconst _ = require('lodash');\n\nclass FS {\n  static normalize(path, options) {\n    // Check if the path is not in glob pattern.\n    if (!isGlob(path)) {\n      // Assume that Glob is used.\n      let isFile = false;\n      // Make sure the path is resolved.\n      let str = Path.resolve(options.mrdoc.cwd, path).replace('/', Path.sep);\n      // Check if the path is a file or directory.\n      if (_.isEmpty(Path.parse(path).ext)) {\n        // Check if the path has a '/' at the end.\n        str = str[str.length - 1] === Path.sep ?\n        str : `${str}${Path.sep}`;\n      } else isFile = true;\n      // Make sure the file or directory exists;\n      if (File.existsSync(str)) {\n        if (!isFile) {\n          // Check if the directory has sub-directories.\n          const hasSubDirs = File.readdirSync(str)\n          .filter(file =>\n            File.statSync(Path.join(str, file)).isDirectory()).length > 1;\n          // Get the file extension.\n          const extension = Extension.find(options.parser.language);\n          // Set the glob pattern based on 'hasSubDirs'.\n          str = hasSubDirs ?\n          `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\n        }\n      } else return null;\n      return str;\n    }\n    return path;\n  }\n}\n\nmodule.exports = FS;\n"
            }
          },
          {
            "H1V3i6xL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "log.js",
                "ext": ".js",
                "name": "log"
              },
              "source": "/* eslint-env node */\n'use strict';\n\n/* eslint-env node */\nconst Utils = require('mr-doc-utils');\nconst log = new Utils.Log();\nconst _ = require('lodash');\n\nclass Log {\n  constructor(options) {\n    if (options.silent) {\n      log.on('error', () => { /* NOOP */});\n      return log;\n    }\n    this.levels(options.level)\n    .forEach(level => {\n      if (level === 'error') this.error();\n      else this.other(level);\n    });\n    return log;\n  }\n  levels(level) {\n    const levels = _.isString(level) ? level.split(',') : level;\n    return levels\n    .map(i => i.replace(/\\s/g, ''));\n  }\n  error() {\n    log.on('error', function error() {\n      /* eslint-disable no-console */\n      const args = Array.prototype.slice.call(arguments);\n      args.unshift(log.color.cyan('mrdoc'));\n      console.log.apply(console, args.map(i => log.color.red(i)));\n      /* eslint-enable no-console */\n    });\n  }\n  other(level) {\n    log.on(level, function logger() {\n      /* eslint-disable no-console */\n      const args = Array.prototype.slice.call(arguments);\n      args.unshift(log.color.cyan('mrdoc'));\n      console.log.apply(console, args);\n      /* eslint-enable no-console */\n    });\n  }\n  /**\n   * Get the global instance of Log.\n   * @return {Log} - An instance of Log.\n   */\n  static global() {\n    log.color = Utils.Log.color;\n    return log;\n  }\n}\n\nmodule.exports = Log;\n"
            }
          },
          {
            "B1BhjpeL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "output.js",
                "ext": ".js",
                "name": "output"
              },
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nclass Output {\n  static handler(buffer, options) {\n    return function (callback) {\n      Output.format(buffer, options).forEach(Output.toStream(this, options));\n      callback();\n    };\n  }\n  static format(buffer, options) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler.file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n  static toBuffer(buffer) {\n    return (file, enc, callback) => {\n      buffer.push(file);\n      callback();\n    };\n  }\n  static toStream(context, options) {\n    const file = options.compiler.file;\n    return function (f) {\n      if (file.format === 'json' || file.format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (file.format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "BJUhiTxI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "source.js",
                "ext": ".js",
                "name": "source"
              },
              "source": "'use strict';\nconst ShortID = require('shortid');\nconst File = require('fs-extra');\nconst _ = require('lodash');\nconst Path = require('path');\n\nclass Source {\n  static create(files) {\n    // Process the files.\n    const result = files\n    .map(file => Source.processFile(file));\n    // Create references for each file.\n    const references = result\n    .map(file => Source.createReference(file));\n    // Process the references and attach it to each file.\n    return result\n    .map(file => Source.processReference(file, references));\n  }\n  static processFile(file) {\n    return {\n      id: ShortID.generate(),\n      cwd: file.cwd,\n      base: file.base.replace(file.cwd + Path.sep, ''),\n      path: Path.parse(file.path.replace(file.cwd + Path.sep, '')),\n      source: File.readFileSync(file.path, 'utf8'),\n      comments: undefined,\n    };\n  }\n  static createReference(file) {\n    return {\n      id: file.id,\n      cwd: file.cwd,\n      base: file.base,\n      path: file.path,\n      source: file.source,\n      comments: file.comments,\n    };\n  }\n  static processReference(file, references) {\n    return _.merge(file, {\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\n    });\n  }\n}\n\nmodule.exports = Source;\n"
            }
          },
          {
            "S1vnspgI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/engines",
                "base": "javascript.js",
                "ext": ".js",
                "name": "javascript"
              },
              "source": "'use strict';\n\nconst Babylon = require('babylon');\nconst Acorn = require('acorn');\nconst Espree = require('espree');\nconst ESCodeGen = require('escodegen');\nconst ESTraverse = require('estraverse');\nconst traverse = require('babel-traverse').default;\n\nconst opts = {\n  acorn: (version, comments, tokens) => ({\n    ecmaVersion: version,\n    locations: true,\n    onComment: comments,\n    onToken: tokens,\n    ranges: true,\n  }),\n  babylon: () => ({\n    allowImportExportEverywhere: true,\n    plugins: [\n      'jsx',\n      'flow',\n      'asyncFunctions',\n      'classConstructorCall',\n      'doExpressions',\n      'trailingFunctionCommas',\n      'objectRestSpread',\n      'decorators',\n      'classProperties',\n      'exportExtensions',\n      'exponentiationOperator',\n      'asyncGenerators',\n      'functionBind',\n      'functionSent',\n    ],\n    sourceType: 'module',\n  }),\n  espree: (version) => ({\n    attachComment: true,\n    comment: true,\n    ecmaFeatures: {\n      experimentalObjectRestSpread: true,\n      globalReturn: true,\n      impliedStrict: true,\n      jsx: true,\n    },\n    ecmaVersion: version,\n    loc: true,\n    range: true,\n    sourceType: 'module',\n    tokens: true,\n  }),\n};\n\nclass Engine {\n  constructor(options) {\n    this.options = options;\n    switch (this.options.engine) {\n      case 'acorn':\n        this.engine = Acorn;\n        break;\n      case 'espree':\n        this.engine = Espree;\n        break;\n      default:\n        this.engine = Babylon;\n        break;\n    }\n  }\n  parse(file) {\n    const comments = [];\n    const tokens = [];\n    try {\n      switch (this.options.engine) {\n        case 'acorn':\n          return ESCodeGen\n          .attachComments(this.engine.parse(file.source,\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\n        case 'espree':\n          return this.engine.parse(file.source, opts.espree(this.options.version));\n        default:\n          return this.engine.parse(file.source, opts.babylon());\n      }\n    } catch (error) {\n      throw (new Error(error));\n    }\n  }\n  static traverse(options, ast, callback) {\n    switch (options.engine) {\n      case 'babylon':\n        traverse(ast, {\n          enter: (path) => {\n            const node = path.node;\n            callback(node);\n          } });\n        break;\n      default:\n        ESTraverse.traverse(ast, {\n          /* eslint-disable no-param-reassign */\n          enter: (node) => {\n            if (node.type === 'Program') {\n              node = node.body[0];\n            }\n            callback(node);\n          } });\n          /* eslint-enable no-param-reassign */\n        break;\n    }\n  }\n}\nmodule.exports = Engine;\n"
            }
          },
          {
            "r1OhoagI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "SyY2jagI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass IParser {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser;\n  }\n  /**\n   * Parses the sources' comments into the desired output.\n   * @param  {Array<Object>} results - The files to parse.\n   * @return {Array<Object>} - The parsed comments.\n   */\n  /* eslint-disable no-unused-vars */\n  parse(sources) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = IParser;\n"
            }
          },
          {
            "Bk5nsalU": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/html",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\n\nclass HTML extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.comments = comments;\n  }\n}\nmodule.exports = HTML;\n"
            }
          },
          {
            "rJi2iTgI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/json",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "SJn3oplI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers/javascript",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n"
            }
          },
          {
            "Bkphopx8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers/javascript",
                "base": "synonyms.js",
                "ext": ".js",
                "name": "synonyms"
              },
              "source": "module.exports = {\n  arg: 'param',\n  argument: 'param',\n  constructor: 'class',\n  const: 'constant',\n  defaultvalue: 'default',\n  desc: 'description',\n  emits: 'fires',\n  exception: 'throws',\n  fileoverview: 'file',\n  func: 'function',\n  host: 'external',\n  linkcode: 'link',\n  linkplain: 'link',\n  virtual: 'abstract',\n  method: 'function',\n  overview: 'file',\n  prop: 'property',\n  return: 'returns',\n  var: 'member',\n};\n"
            }
          },
          {
            "H1R3spgL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/html/engines",
                "base": "theme.js",
                "ext": ".js",
                "name": "theme"
              },
              "source": "'use strict';\n\nclass Theme {\n  // constructor() {\n  //\n  // }\n  compile() {\n\n  }\n}\n\nmodule.exports = Theme;\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 49,
          "column": 2
        },
        "end": {
          "line": 76,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          49,
          76
        ]
      }
    }
  },
  {
    "description": "Parse the JSDoc comment.",
    "tags": [
      {
        "title": "param",
        "description": "The comment to parse.",
        "lineNumber": 2,
        "type": null,
        "name": "String"
      },
      {
        "title": "param",
        "description": "The comment location.",
        "lineNumber": 3,
        "type": null,
        "name": "Location"
      },
      {
        "title": "param",
        "description": "The truth value on whether to include the context.",
        "lineNumber": 4,
        "type": null,
        "name": "Boolean"
      }
    ],
    "loc": {
      "start": {
        "line": 77,
        "column": 2
      },
      "end": {
        "line": 82,
        "column": 5
      }
    },
    "context": {
      "code": "parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }",
      "file": {
        "id": "SJn3oplI",
        "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
        "base": "src/",
        "path": {
          "root": "",
          "dir": "src/parser/parsers/javascript",
          "base": "index.js",
          "ext": ".js",
          "name": "index"
        },
        "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n",
        "ref": [
          {
            "BJ2i6eL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/cli",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "/* eslint-env node */\n'use strict';\n\nconst FS = require('../utils/fs');\nconst Log = require('../utils/log');\nconst Liftoff = require('liftoff');\nconst Option = require('mr-doc-utils').Option;\nconst Promise = require('bluebird');\nconst Yargs = require('yargs');\nconst ViynlFS = require('vinyl-fs');\nconst _ = require('lodash');\nconst log = Log.global();\nconst pkg = require('../../package.json');\nconst rc = require('rc');\n\nclass CLI {\n  /**\n   * Parse the CLI arguments.\n   * @static\n   */\n  static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli)\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }\n  /**\n   * Create the CLI.\n   * @static\n   * @return {Liftoff} - An instance of Liftoff.\n   */\n  static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }\n  /**\n   * Launch the cli.\n   * @static\n   * @param {Object} - The parsed CLI arguments.\n   * @return {Promise<Stream>} - A promise to the stream.\n   */\n  static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }\n  /**\n   * Handles the result from the CLI.\n   * @static\n   */\n  static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const sources = source.split(',')\n      .map(path => path.trim())\n      .map(path => FS.normalize(path, rc('mrdoc', options)));\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: options.cwd }), options });\n    });\n  }\n}\n\nmodule.exports = CLI;\n"
            }
          },
          {
            "BJxhiTlL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst JSONC = require('./compilers/json/');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\n// const HTML = require('./compilers/html');\n\nclass Compiler {\n  constructor(options) {\n    this.options = options;\n  }\n  factory() {\n    const format = this.options.compiler.file.format;\n    // DEBUG: Compiler format\n    log.debug(Log.color.blue('Compiler format:'), format);\n    switch (format) {\n      case 'json':\n        return (new JSONC(this.options));\n      case 'html':\n        // return (new HTML(this.options));\n      default:\n        return null;\n    }\n  }\n}\nmodule.exports = Compiler;\n"
            }
          },
          {
            "Hy-2sae8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst JavaScript = require('./parsers/javascript/');\n\nclass Parser {\n  constructor(options) {\n    this.options = options;\n  }\n  factory() {\n    switch (this.options.parser.language) {\n      case 'js':\n      case 'javascript':\n        return (new JavaScript(this.options));\n      default:\n        return null;\n    }\n  }\n}\nmodule.exports = Parser;\n"
            }
          },
          {
            "Skfhjpl8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "extension.js",
                "ext": ".js",
                "name": "extension"
              },
              "source": "'use strict';\n\nclass Extension {\n  static find(language) {\n    return Extension.extensions()[language];\n  }\n  static extensions() {\n    return {\n      js: '.js',\n      javascript: '.js',\n      json: '.json',\n      html: '.html',\n      typescript: '.ts',\n    };\n  }\n}\n\nmodule.exports = Extension;\n"
            }
          },
          {
            "H17hjpxU": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "fs.js",
                "ext": ".js",
                "name": "fs"
              },
              "source": "'use strict';\nconst Path = require('path');\nconst Extension = require('./extension');\nconst isGlob = require('is-glob');\nconst _ = require('lodash');\n\nclass FS {\n  static normalize(path, options) {\n    // Check if the path is not in glob pattern.\n    if (!isGlob(path)) {\n      // Assume that Glob is used.\n      let isFile = false;\n      // Make sure the path is resolved.\n      let str = Path.resolve(options.mrdoc.cwd, path).replace('/', Path.sep);\n      // Check if the path is a file or directory.\n      if (_.isEmpty(Path.parse(path).ext)) {\n        // Check if the path has a '/' at the end.\n        str = str[str.length - 1] === Path.sep ?\n        str : `${str}${Path.sep}`;\n      } else isFile = true;\n      // Make sure the file or directory exists;\n      if (File.existsSync(str)) {\n        if (!isFile) {\n          // Check if the directory has sub-directories.\n          const hasSubDirs = File.readdirSync(str)\n          .filter(file =>\n            File.statSync(Path.join(str, file)).isDirectory()).length > 1;\n          // Get the file extension.\n          const extension = Extension.find(options.parser.language);\n          // Set the glob pattern based on 'hasSubDirs'.\n          str = hasSubDirs ?\n          `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\n        }\n      } else return null;\n      return str;\n    }\n    return path;\n  }\n}\n\nmodule.exports = FS;\n"
            }
          },
          {
            "H1V3i6xL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "log.js",
                "ext": ".js",
                "name": "log"
              },
              "source": "/* eslint-env node */\n'use strict';\n\n/* eslint-env node */\nconst Utils = require('mr-doc-utils');\nconst log = new Utils.Log();\nconst _ = require('lodash');\n\nclass Log {\n  constructor(options) {\n    if (options.silent) {\n      log.on('error', () => { /* NOOP */});\n      return log;\n    }\n    this.levels(options.level)\n    .forEach(level => {\n      if (level === 'error') this.error();\n      else this.other(level);\n    });\n    return log;\n  }\n  levels(level) {\n    const levels = _.isString(level) ? level.split(',') : level;\n    return levels\n    .map(i => i.replace(/\\s/g, ''));\n  }\n  error() {\n    log.on('error', function error() {\n      /* eslint-disable no-console */\n      const args = Array.prototype.slice.call(arguments);\n      args.unshift(log.color.cyan('mrdoc'));\n      console.log.apply(console, args.map(i => log.color.red(i)));\n      /* eslint-enable no-console */\n    });\n  }\n  other(level) {\n    log.on(level, function logger() {\n      /* eslint-disable no-console */\n      const args = Array.prototype.slice.call(arguments);\n      args.unshift(log.color.cyan('mrdoc'));\n      console.log.apply(console, args);\n      /* eslint-enable no-console */\n    });\n  }\n  /**\n   * Get the global instance of Log.\n   * @return {Log} - An instance of Log.\n   */\n  static global() {\n    log.color = Utils.Log.color;\n    return log;\n  }\n}\n\nmodule.exports = Log;\n"
            }
          },
          {
            "B1BhjpeL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "output.js",
                "ext": ".js",
                "name": "output"
              },
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nclass Output {\n  static handler(buffer, options) {\n    return function (callback) {\n      Output.format(buffer, options).forEach(Output.toStream(this, options));\n      callback();\n    };\n  }\n  static format(buffer, options) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler.file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n  static toBuffer(buffer) {\n    return (file, enc, callback) => {\n      buffer.push(file);\n      callback();\n    };\n  }\n  static toStream(context, options) {\n    const file = options.compiler.file;\n    return function (f) {\n      if (file.format === 'json' || file.format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (file.format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "BJUhiTxI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "source.js",
                "ext": ".js",
                "name": "source"
              },
              "source": "'use strict';\nconst ShortID = require('shortid');\nconst File = require('fs-extra');\nconst _ = require('lodash');\nconst Path = require('path');\n\nclass Source {\n  static create(files) {\n    // Process the files.\n    const result = files\n    .map(file => Source.processFile(file));\n    // Create references for each file.\n    const references = result\n    .map(file => Source.createReference(file));\n    // Process the references and attach it to each file.\n    return result\n    .map(file => Source.processReference(file, references));\n  }\n  static processFile(file) {\n    return {\n      id: ShortID.generate(),\n      cwd: file.cwd,\n      base: file.base.replace(file.cwd + Path.sep, ''),\n      path: Path.parse(file.path.replace(file.cwd + Path.sep, '')),\n      source: File.readFileSync(file.path, 'utf8'),\n      comments: undefined,\n    };\n  }\n  static createReference(file) {\n    return {\n      id: file.id,\n      cwd: file.cwd,\n      base: file.base,\n      path: file.path,\n      source: file.source,\n      comments: file.comments,\n    };\n  }\n  static processReference(file, references) {\n    return _.merge(file, {\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\n    });\n  }\n}\n\nmodule.exports = Source;\n"
            }
          },
          {
            "S1vnspgI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/engines",
                "base": "javascript.js",
                "ext": ".js",
                "name": "javascript"
              },
              "source": "'use strict';\n\nconst Babylon = require('babylon');\nconst Acorn = require('acorn');\nconst Espree = require('espree');\nconst ESCodeGen = require('escodegen');\nconst ESTraverse = require('estraverse');\nconst traverse = require('babel-traverse').default;\n\nconst opts = {\n  acorn: (version, comments, tokens) => ({\n    ecmaVersion: version,\n    locations: true,\n    onComment: comments,\n    onToken: tokens,\n    ranges: true,\n  }),\n  babylon: () => ({\n    allowImportExportEverywhere: true,\n    plugins: [\n      'jsx',\n      'flow',\n      'asyncFunctions',\n      'classConstructorCall',\n      'doExpressions',\n      'trailingFunctionCommas',\n      'objectRestSpread',\n      'decorators',\n      'classProperties',\n      'exportExtensions',\n      'exponentiationOperator',\n      'asyncGenerators',\n      'functionBind',\n      'functionSent',\n    ],\n    sourceType: 'module',\n  }),\n  espree: (version) => ({\n    attachComment: true,\n    comment: true,\n    ecmaFeatures: {\n      experimentalObjectRestSpread: true,\n      globalReturn: true,\n      impliedStrict: true,\n      jsx: true,\n    },\n    ecmaVersion: version,\n    loc: true,\n    range: true,\n    sourceType: 'module',\n    tokens: true,\n  }),\n};\n\nclass Engine {\n  constructor(options) {\n    this.options = options;\n    switch (this.options.engine) {\n      case 'acorn':\n        this.engine = Acorn;\n        break;\n      case 'espree':\n        this.engine = Espree;\n        break;\n      default:\n        this.engine = Babylon;\n        break;\n    }\n  }\n  parse(file) {\n    const comments = [];\n    const tokens = [];\n    try {\n      switch (this.options.engine) {\n        case 'acorn':\n          return ESCodeGen\n          .attachComments(this.engine.parse(file.source,\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\n        case 'espree':\n          return this.engine.parse(file.source, opts.espree(this.options.version));\n        default:\n          return this.engine.parse(file.source, opts.babylon());\n      }\n    } catch (error) {\n      throw (new Error(error));\n    }\n  }\n  static traverse(options, ast, callback) {\n    switch (options.engine) {\n      case 'babylon':\n        traverse(ast, {\n          enter: (path) => {\n            const node = path.node;\n            callback(node);\n          } });\n        break;\n      default:\n        ESTraverse.traverse(ast, {\n          /* eslint-disable no-param-reassign */\n          enter: (node) => {\n            if (node.type === 'Program') {\n              node = node.body[0];\n            }\n            callback(node);\n          } });\n          /* eslint-enable no-param-reassign */\n        break;\n    }\n  }\n}\nmodule.exports = Engine;\n"
            }
          },
          {
            "r1OhoagI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "SyY2jagI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass IParser {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser;\n  }\n  /**\n   * Parses the sources' comments into the desired output.\n   * @param  {Array<Object>} results - The files to parse.\n   * @return {Array<Object>} - The parsed comments.\n   */\n  /* eslint-disable no-unused-vars */\n  parse(sources) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = IParser;\n"
            }
          },
          {
            "Bk5nsalU": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/html",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\n\nclass HTML extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.comments = comments;\n  }\n}\nmodule.exports = HTML;\n"
            }
          },
          {
            "rJi2iTgI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/json",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "SJn3oplI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers/javascript",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n"
            }
          },
          {
            "Bkphopx8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers/javascript",
                "base": "synonyms.js",
                "ext": ".js",
                "name": "synonyms"
              },
              "source": "module.exports = {\n  arg: 'param',\n  argument: 'param',\n  constructor: 'class',\n  const: 'constant',\n  defaultvalue: 'default',\n  desc: 'description',\n  emits: 'fires',\n  exception: 'throws',\n  fileoverview: 'file',\n  func: 'function',\n  host: 'external',\n  linkcode: 'link',\n  linkplain: 'link',\n  virtual: 'abstract',\n  method: 'function',\n  overview: 'file',\n  prop: 'property',\n  return: 'returns',\n  var: 'member',\n};\n"
            }
          },
          {
            "H1R3spgL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/html/engines",
                "base": "theme.js",
                "ext": ".js",
                "name": "theme"
              },
              "source": "'use strict';\n\nclass Theme {\n  // constructor() {\n  //\n  // }\n  compile() {\n\n  }\n}\n\nmodule.exports = Theme;\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 83,
          "column": 2
        },
        "end": {
          "line": 104,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          83,
          104
        ]
      }
    }
  },
  {
    "description": "Determine whether the comment is normalized.",
    "tags": [
      {
        "title": "param",
        "description": "The comment to determine.",
        "lineNumber": 2,
        "type": null,
        "name": "String"
      },
      {
        "title": "returns",
        "description": "The truth value.",
        "lineNumber": 3,
        "type": {
          "type": "NameExpression",
          "name": "Boolean"
        }
      }
    ],
    "loc": {
      "start": {
        "line": 105,
        "column": 2
      },
      "end": {
        "line": 109,
        "column": 5
      }
    },
    "context": {
      "code": "isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }",
      "file": {
        "id": "SJn3oplI",
        "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
        "base": "src/",
        "path": {
          "root": "",
          "dir": "src/parser/parsers/javascript",
          "base": "index.js",
          "ext": ".js",
          "name": "index"
        },
        "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n",
        "ref": [
          {
            "BJ2i6eL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/cli",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "/* eslint-env node */\n'use strict';\n\nconst FS = require('../utils/fs');\nconst Log = require('../utils/log');\nconst Liftoff = require('liftoff');\nconst Option = require('mr-doc-utils').Option;\nconst Promise = require('bluebird');\nconst Yargs = require('yargs');\nconst ViynlFS = require('vinyl-fs');\nconst _ = require('lodash');\nconst log = Log.global();\nconst pkg = require('../../package.json');\nconst rc = require('rc');\n\nclass CLI {\n  /**\n   * Parse the CLI arguments.\n   * @static\n   */\n  static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli)\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }\n  /**\n   * Create the CLI.\n   * @static\n   * @return {Liftoff} - An instance of Liftoff.\n   */\n  static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }\n  /**\n   * Launch the cli.\n   * @static\n   * @param {Object} - The parsed CLI arguments.\n   * @return {Promise<Stream>} - A promise to the stream.\n   */\n  static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }\n  /**\n   * Handles the result from the CLI.\n   * @static\n   */\n  static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const sources = source.split(',')\n      .map(path => path.trim())\n      .map(path => FS.normalize(path, rc('mrdoc', options)));\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: options.cwd }), options });\n    });\n  }\n}\n\nmodule.exports = CLI;\n"
            }
          },
          {
            "BJxhiTlL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst JSONC = require('./compilers/json/');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\n// const HTML = require('./compilers/html');\n\nclass Compiler {\n  constructor(options) {\n    this.options = options;\n  }\n  factory() {\n    const format = this.options.compiler.file.format;\n    // DEBUG: Compiler format\n    log.debug(Log.color.blue('Compiler format:'), format);\n    switch (format) {\n      case 'json':\n        return (new JSONC(this.options));\n      case 'html':\n        // return (new HTML(this.options));\n      default:\n        return null;\n    }\n  }\n}\nmodule.exports = Compiler;\n"
            }
          },
          {
            "Hy-2sae8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst JavaScript = require('./parsers/javascript/');\n\nclass Parser {\n  constructor(options) {\n    this.options = options;\n  }\n  factory() {\n    switch (this.options.parser.language) {\n      case 'js':\n      case 'javascript':\n        return (new JavaScript(this.options));\n      default:\n        return null;\n    }\n  }\n}\nmodule.exports = Parser;\n"
            }
          },
          {
            "Skfhjpl8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "extension.js",
                "ext": ".js",
                "name": "extension"
              },
              "source": "'use strict';\n\nclass Extension {\n  static find(language) {\n    return Extension.extensions()[language];\n  }\n  static extensions() {\n    return {\n      js: '.js',\n      javascript: '.js',\n      json: '.json',\n      html: '.html',\n      typescript: '.ts',\n    };\n  }\n}\n\nmodule.exports = Extension;\n"
            }
          },
          {
            "H17hjpxU": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "fs.js",
                "ext": ".js",
                "name": "fs"
              },
              "source": "'use strict';\nconst Path = require('path');\nconst Extension = require('./extension');\nconst isGlob = require('is-glob');\nconst _ = require('lodash');\n\nclass FS {\n  static normalize(path, options) {\n    // Check if the path is not in glob pattern.\n    if (!isGlob(path)) {\n      // Assume that Glob is used.\n      let isFile = false;\n      // Make sure the path is resolved.\n      let str = Path.resolve(options.mrdoc.cwd, path).replace('/', Path.sep);\n      // Check if the path is a file or directory.\n      if (_.isEmpty(Path.parse(path).ext)) {\n        // Check if the path has a '/' at the end.\n        str = str[str.length - 1] === Path.sep ?\n        str : `${str}${Path.sep}`;\n      } else isFile = true;\n      // Make sure the file or directory exists;\n      if (File.existsSync(str)) {\n        if (!isFile) {\n          // Check if the directory has sub-directories.\n          const hasSubDirs = File.readdirSync(str)\n          .filter(file =>\n            File.statSync(Path.join(str, file)).isDirectory()).length > 1;\n          // Get the file extension.\n          const extension = Extension.find(options.parser.language);\n          // Set the glob pattern based on 'hasSubDirs'.\n          str = hasSubDirs ?\n          `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\n        }\n      } else return null;\n      return str;\n    }\n    return path;\n  }\n}\n\nmodule.exports = FS;\n"
            }
          },
          {
            "H1V3i6xL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "log.js",
                "ext": ".js",
                "name": "log"
              },
              "source": "/* eslint-env node */\n'use strict';\n\n/* eslint-env node */\nconst Utils = require('mr-doc-utils');\nconst log = new Utils.Log();\nconst _ = require('lodash');\n\nclass Log {\n  constructor(options) {\n    if (options.silent) {\n      log.on('error', () => { /* NOOP */});\n      return log;\n    }\n    this.levels(options.level)\n    .forEach(level => {\n      if (level === 'error') this.error();\n      else this.other(level);\n    });\n    return log;\n  }\n  levels(level) {\n    const levels = _.isString(level) ? level.split(',') : level;\n    return levels\n    .map(i => i.replace(/\\s/g, ''));\n  }\n  error() {\n    log.on('error', function error() {\n      /* eslint-disable no-console */\n      const args = Array.prototype.slice.call(arguments);\n      args.unshift(log.color.cyan('mrdoc'));\n      console.log.apply(console, args.map(i => log.color.red(i)));\n      /* eslint-enable no-console */\n    });\n  }\n  other(level) {\n    log.on(level, function logger() {\n      /* eslint-disable no-console */\n      const args = Array.prototype.slice.call(arguments);\n      args.unshift(log.color.cyan('mrdoc'));\n      console.log.apply(console, args);\n      /* eslint-enable no-console */\n    });\n  }\n  /**\n   * Get the global instance of Log.\n   * @return {Log} - An instance of Log.\n   */\n  static global() {\n    log.color = Utils.Log.color;\n    return log;\n  }\n}\n\nmodule.exports = Log;\n"
            }
          },
          {
            "B1BhjpeL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "output.js",
                "ext": ".js",
                "name": "output"
              },
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nclass Output {\n  static handler(buffer, options) {\n    return function (callback) {\n      Output.format(buffer, options).forEach(Output.toStream(this, options));\n      callback();\n    };\n  }\n  static format(buffer, options) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler.file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n  static toBuffer(buffer) {\n    return (file, enc, callback) => {\n      buffer.push(file);\n      callback();\n    };\n  }\n  static toStream(context, options) {\n    const file = options.compiler.file;\n    return function (f) {\n      if (file.format === 'json' || file.format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (file.format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "BJUhiTxI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "source.js",
                "ext": ".js",
                "name": "source"
              },
              "source": "'use strict';\nconst ShortID = require('shortid');\nconst File = require('fs-extra');\nconst _ = require('lodash');\nconst Path = require('path');\n\nclass Source {\n  static create(files) {\n    // Process the files.\n    const result = files\n    .map(file => Source.processFile(file));\n    // Create references for each file.\n    const references = result\n    .map(file => Source.createReference(file));\n    // Process the references and attach it to each file.\n    return result\n    .map(file => Source.processReference(file, references));\n  }\n  static processFile(file) {\n    return {\n      id: ShortID.generate(),\n      cwd: file.cwd,\n      base: file.base.replace(file.cwd + Path.sep, ''),\n      path: Path.parse(file.path.replace(file.cwd + Path.sep, '')),\n      source: File.readFileSync(file.path, 'utf8'),\n      comments: undefined,\n    };\n  }\n  static createReference(file) {\n    return {\n      id: file.id,\n      cwd: file.cwd,\n      base: file.base,\n      path: file.path,\n      source: file.source,\n      comments: file.comments,\n    };\n  }\n  static processReference(file, references) {\n    return _.merge(file, {\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\n    });\n  }\n}\n\nmodule.exports = Source;\n"
            }
          },
          {
            "S1vnspgI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/engines",
                "base": "javascript.js",
                "ext": ".js",
                "name": "javascript"
              },
              "source": "'use strict';\n\nconst Babylon = require('babylon');\nconst Acorn = require('acorn');\nconst Espree = require('espree');\nconst ESCodeGen = require('escodegen');\nconst ESTraverse = require('estraverse');\nconst traverse = require('babel-traverse').default;\n\nconst opts = {\n  acorn: (version, comments, tokens) => ({\n    ecmaVersion: version,\n    locations: true,\n    onComment: comments,\n    onToken: tokens,\n    ranges: true,\n  }),\n  babylon: () => ({\n    allowImportExportEverywhere: true,\n    plugins: [\n      'jsx',\n      'flow',\n      'asyncFunctions',\n      'classConstructorCall',\n      'doExpressions',\n      'trailingFunctionCommas',\n      'objectRestSpread',\n      'decorators',\n      'classProperties',\n      'exportExtensions',\n      'exponentiationOperator',\n      'asyncGenerators',\n      'functionBind',\n      'functionSent',\n    ],\n    sourceType: 'module',\n  }),\n  espree: (version) => ({\n    attachComment: true,\n    comment: true,\n    ecmaFeatures: {\n      experimentalObjectRestSpread: true,\n      globalReturn: true,\n      impliedStrict: true,\n      jsx: true,\n    },\n    ecmaVersion: version,\n    loc: true,\n    range: true,\n    sourceType: 'module',\n    tokens: true,\n  }),\n};\n\nclass Engine {\n  constructor(options) {\n    this.options = options;\n    switch (this.options.engine) {\n      case 'acorn':\n        this.engine = Acorn;\n        break;\n      case 'espree':\n        this.engine = Espree;\n        break;\n      default:\n        this.engine = Babylon;\n        break;\n    }\n  }\n  parse(file) {\n    const comments = [];\n    const tokens = [];\n    try {\n      switch (this.options.engine) {\n        case 'acorn':\n          return ESCodeGen\n          .attachComments(this.engine.parse(file.source,\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\n        case 'espree':\n          return this.engine.parse(file.source, opts.espree(this.options.version));\n        default:\n          return this.engine.parse(file.source, opts.babylon());\n      }\n    } catch (error) {\n      throw (new Error(error));\n    }\n  }\n  static traverse(options, ast, callback) {\n    switch (options.engine) {\n      case 'babylon':\n        traverse(ast, {\n          enter: (path) => {\n            const node = path.node;\n            callback(node);\n          } });\n        break;\n      default:\n        ESTraverse.traverse(ast, {\n          /* eslint-disable no-param-reassign */\n          enter: (node) => {\n            if (node.type === 'Program') {\n              node = node.body[0];\n            }\n            callback(node);\n          } });\n          /* eslint-enable no-param-reassign */\n        break;\n    }\n  }\n}\nmodule.exports = Engine;\n"
            }
          },
          {
            "r1OhoagI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "SyY2jagI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass IParser {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser;\n  }\n  /**\n   * Parses the sources' comments into the desired output.\n   * @param  {Array<Object>} results - The files to parse.\n   * @return {Array<Object>} - The parsed comments.\n   */\n  /* eslint-disable no-unused-vars */\n  parse(sources) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = IParser;\n"
            }
          },
          {
            "Bk5nsalU": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/html",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\n\nclass HTML extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.comments = comments;\n  }\n}\nmodule.exports = HTML;\n"
            }
          },
          {
            "rJi2iTgI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/json",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "SJn3oplI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers/javascript",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n"
            }
          },
          {
            "Bkphopx8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers/javascript",
                "base": "synonyms.js",
                "ext": ".js",
                "name": "synonyms"
              },
              "source": "module.exports = {\n  arg: 'param',\n  argument: 'param',\n  constructor: 'class',\n  const: 'constant',\n  defaultvalue: 'default',\n  desc: 'description',\n  emits: 'fires',\n  exception: 'throws',\n  fileoverview: 'file',\n  func: 'function',\n  host: 'external',\n  linkcode: 'link',\n  linkplain: 'link',\n  virtual: 'abstract',\n  method: 'function',\n  overview: 'file',\n  prop: 'property',\n  return: 'returns',\n  var: 'member',\n};\n"
            }
          },
          {
            "H1R3spgL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/html/engines",
                "base": "theme.js",
                "ext": ".js",
                "name": "theme"
              },
              "source": "'use strict';\n\nclass Theme {\n  // constructor() {\n  //\n  // }\n  compile() {\n\n  }\n}\n\nmodule.exports = Theme;\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 110,
          "column": 2
        },
        "end": {
          "line": 115,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          110,
          115
        ]
      }
    }
  },
  {
    "description": "Normalize the comment tags.",
    "tags": [
      {
        "title": "param",
        "description": "The comment to normalize.",
        "lineNumber": 2,
        "type": null,
        "name": "Array"
      },
      {
        "title": "returns",
        "description": "The comment containing normalized tags.",
        "lineNumber": 3,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      }
    ],
    "loc": {
      "start": {
        "line": 116,
        "column": 2
      },
      "end": {
        "line": 120,
        "column": 5
      }
    },
    "context": {
      "code": "static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }",
      "file": {
        "id": "SJn3oplI",
        "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
        "base": "src/",
        "path": {
          "root": "",
          "dir": "src/parser/parsers/javascript",
          "base": "index.js",
          "ext": ".js",
          "name": "index"
        },
        "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n",
        "ref": [
          {
            "BJ2i6eL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/cli",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "/* eslint-env node */\n'use strict';\n\nconst FS = require('../utils/fs');\nconst Log = require('../utils/log');\nconst Liftoff = require('liftoff');\nconst Option = require('mr-doc-utils').Option;\nconst Promise = require('bluebird');\nconst Yargs = require('yargs');\nconst ViynlFS = require('vinyl-fs');\nconst _ = require('lodash');\nconst log = Log.global();\nconst pkg = require('../../package.json');\nconst rc = require('rc');\n\nclass CLI {\n  /**\n   * Parse the CLI arguments.\n   * @static\n   */\n  static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli)\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }\n  /**\n   * Create the CLI.\n   * @static\n   * @return {Liftoff} - An instance of Liftoff.\n   */\n  static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }\n  /**\n   * Launch the cli.\n   * @static\n   * @param {Object} - The parsed CLI arguments.\n   * @return {Promise<Stream>} - A promise to the stream.\n   */\n  static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }\n  /**\n   * Handles the result from the CLI.\n   * @static\n   */\n  static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const sources = source.split(',')\n      .map(path => path.trim())\n      .map(path => FS.normalize(path, rc('mrdoc', options)));\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: options.cwd }), options });\n    });\n  }\n}\n\nmodule.exports = CLI;\n"
            }
          },
          {
            "BJxhiTlL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst JSONC = require('./compilers/json/');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\n// const HTML = require('./compilers/html');\n\nclass Compiler {\n  constructor(options) {\n    this.options = options;\n  }\n  factory() {\n    const format = this.options.compiler.file.format;\n    // DEBUG: Compiler format\n    log.debug(Log.color.blue('Compiler format:'), format);\n    switch (format) {\n      case 'json':\n        return (new JSONC(this.options));\n      case 'html':\n        // return (new HTML(this.options));\n      default:\n        return null;\n    }\n  }\n}\nmodule.exports = Compiler;\n"
            }
          },
          {
            "Hy-2sae8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst JavaScript = require('./parsers/javascript/');\n\nclass Parser {\n  constructor(options) {\n    this.options = options;\n  }\n  factory() {\n    switch (this.options.parser.language) {\n      case 'js':\n      case 'javascript':\n        return (new JavaScript(this.options));\n      default:\n        return null;\n    }\n  }\n}\nmodule.exports = Parser;\n"
            }
          },
          {
            "Skfhjpl8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "extension.js",
                "ext": ".js",
                "name": "extension"
              },
              "source": "'use strict';\n\nclass Extension {\n  static find(language) {\n    return Extension.extensions()[language];\n  }\n  static extensions() {\n    return {\n      js: '.js',\n      javascript: '.js',\n      json: '.json',\n      html: '.html',\n      typescript: '.ts',\n    };\n  }\n}\n\nmodule.exports = Extension;\n"
            }
          },
          {
            "H17hjpxU": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "fs.js",
                "ext": ".js",
                "name": "fs"
              },
              "source": "'use strict';\nconst Path = require('path');\nconst Extension = require('./extension');\nconst isGlob = require('is-glob');\nconst _ = require('lodash');\n\nclass FS {\n  static normalize(path, options) {\n    // Check if the path is not in glob pattern.\n    if (!isGlob(path)) {\n      // Assume that Glob is used.\n      let isFile = false;\n      // Make sure the path is resolved.\n      let str = Path.resolve(options.mrdoc.cwd, path).replace('/', Path.sep);\n      // Check if the path is a file or directory.\n      if (_.isEmpty(Path.parse(path).ext)) {\n        // Check if the path has a '/' at the end.\n        str = str[str.length - 1] === Path.sep ?\n        str : `${str}${Path.sep}`;\n      } else isFile = true;\n      // Make sure the file or directory exists;\n      if (File.existsSync(str)) {\n        if (!isFile) {\n          // Check if the directory has sub-directories.\n          const hasSubDirs = File.readdirSync(str)\n          .filter(file =>\n            File.statSync(Path.join(str, file)).isDirectory()).length > 1;\n          // Get the file extension.\n          const extension = Extension.find(options.parser.language);\n          // Set the glob pattern based on 'hasSubDirs'.\n          str = hasSubDirs ?\n          `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\n        }\n      } else return null;\n      return str;\n    }\n    return path;\n  }\n}\n\nmodule.exports = FS;\n"
            }
          },
          {
            "H1V3i6xL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "log.js",
                "ext": ".js",
                "name": "log"
              },
              "source": "/* eslint-env node */\n'use strict';\n\n/* eslint-env node */\nconst Utils = require('mr-doc-utils');\nconst log = new Utils.Log();\nconst _ = require('lodash');\n\nclass Log {\n  constructor(options) {\n    if (options.silent) {\n      log.on('error', () => { /* NOOP */});\n      return log;\n    }\n    this.levels(options.level)\n    .forEach(level => {\n      if (level === 'error') this.error();\n      else this.other(level);\n    });\n    return log;\n  }\n  levels(level) {\n    const levels = _.isString(level) ? level.split(',') : level;\n    return levels\n    .map(i => i.replace(/\\s/g, ''));\n  }\n  error() {\n    log.on('error', function error() {\n      /* eslint-disable no-console */\n      const args = Array.prototype.slice.call(arguments);\n      args.unshift(log.color.cyan('mrdoc'));\n      console.log.apply(console, args.map(i => log.color.red(i)));\n      /* eslint-enable no-console */\n    });\n  }\n  other(level) {\n    log.on(level, function logger() {\n      /* eslint-disable no-console */\n      const args = Array.prototype.slice.call(arguments);\n      args.unshift(log.color.cyan('mrdoc'));\n      console.log.apply(console, args);\n      /* eslint-enable no-console */\n    });\n  }\n  /**\n   * Get the global instance of Log.\n   * @return {Log} - An instance of Log.\n   */\n  static global() {\n    log.color = Utils.Log.color;\n    return log;\n  }\n}\n\nmodule.exports = Log;\n"
            }
          },
          {
            "B1BhjpeL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "output.js",
                "ext": ".js",
                "name": "output"
              },
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nclass Output {\n  static handler(buffer, options) {\n    return function (callback) {\n      Output.format(buffer, options).forEach(Output.toStream(this, options));\n      callback();\n    };\n  }\n  static format(buffer, options) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler.file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n  static toBuffer(buffer) {\n    return (file, enc, callback) => {\n      buffer.push(file);\n      callback();\n    };\n  }\n  static toStream(context, options) {\n    const file = options.compiler.file;\n    return function (f) {\n      if (file.format === 'json' || file.format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (file.format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "BJUhiTxI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/utils",
                "base": "source.js",
                "ext": ".js",
                "name": "source"
              },
              "source": "'use strict';\nconst ShortID = require('shortid');\nconst File = require('fs-extra');\nconst _ = require('lodash');\nconst Path = require('path');\n\nclass Source {\n  static create(files) {\n    // Process the files.\n    const result = files\n    .map(file => Source.processFile(file));\n    // Create references for each file.\n    const references = result\n    .map(file => Source.createReference(file));\n    // Process the references and attach it to each file.\n    return result\n    .map(file => Source.processReference(file, references));\n  }\n  static processFile(file) {\n    return {\n      id: ShortID.generate(),\n      cwd: file.cwd,\n      base: file.base.replace(file.cwd + Path.sep, ''),\n      path: Path.parse(file.path.replace(file.cwd + Path.sep, '')),\n      source: File.readFileSync(file.path, 'utf8'),\n      comments: undefined,\n    };\n  }\n  static createReference(file) {\n    return {\n      id: file.id,\n      cwd: file.cwd,\n      base: file.base,\n      path: file.path,\n      source: file.source,\n      comments: file.comments,\n    };\n  }\n  static processReference(file, references) {\n    return _.merge(file, {\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\n    });\n  }\n}\n\nmodule.exports = Source;\n"
            }
          },
          {
            "S1vnspgI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/engines",
                "base": "javascript.js",
                "ext": ".js",
                "name": "javascript"
              },
              "source": "'use strict';\n\nconst Babylon = require('babylon');\nconst Acorn = require('acorn');\nconst Espree = require('espree');\nconst ESCodeGen = require('escodegen');\nconst ESTraverse = require('estraverse');\nconst traverse = require('babel-traverse').default;\n\nconst opts = {\n  acorn: (version, comments, tokens) => ({\n    ecmaVersion: version,\n    locations: true,\n    onComment: comments,\n    onToken: tokens,\n    ranges: true,\n  }),\n  babylon: () => ({\n    allowImportExportEverywhere: true,\n    plugins: [\n      'jsx',\n      'flow',\n      'asyncFunctions',\n      'classConstructorCall',\n      'doExpressions',\n      'trailingFunctionCommas',\n      'objectRestSpread',\n      'decorators',\n      'classProperties',\n      'exportExtensions',\n      'exponentiationOperator',\n      'asyncGenerators',\n      'functionBind',\n      'functionSent',\n    ],\n    sourceType: 'module',\n  }),\n  espree: (version) => ({\n    attachComment: true,\n    comment: true,\n    ecmaFeatures: {\n      experimentalObjectRestSpread: true,\n      globalReturn: true,\n      impliedStrict: true,\n      jsx: true,\n    },\n    ecmaVersion: version,\n    loc: true,\n    range: true,\n    sourceType: 'module',\n    tokens: true,\n  }),\n};\n\nclass Engine {\n  constructor(options) {\n    this.options = options;\n    switch (this.options.engine) {\n      case 'acorn':\n        this.engine = Acorn;\n        break;\n      case 'espree':\n        this.engine = Espree;\n        break;\n      default:\n        this.engine = Babylon;\n        break;\n    }\n  }\n  parse(file) {\n    const comments = [];\n    const tokens = [];\n    try {\n      switch (this.options.engine) {\n        case 'acorn':\n          return ESCodeGen\n          .attachComments(this.engine.parse(file.source,\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\n        case 'espree':\n          return this.engine.parse(file.source, opts.espree(this.options.version));\n        default:\n          return this.engine.parse(file.source, opts.babylon());\n      }\n    } catch (error) {\n      throw (new Error(error));\n    }\n  }\n  static traverse(options, ast, callback) {\n    switch (options.engine) {\n      case 'babylon':\n        traverse(ast, {\n          enter: (path) => {\n            const node = path.node;\n            callback(node);\n          } });\n        break;\n      default:\n        ESTraverse.traverse(ast, {\n          /* eslint-disable no-param-reassign */\n          enter: (node) => {\n            if (node.type === 'Program') {\n              node = node.body[0];\n            }\n            callback(node);\n          } });\n          /* eslint-enable no-param-reassign */\n        break;\n    }\n  }\n}\nmodule.exports = Engine;\n"
            }
          },
          {
            "r1OhoagI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "SyY2jagI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass IParser {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser;\n  }\n  /**\n   * Parses the sources' comments into the desired output.\n   * @param  {Array<Object>} results - The files to parse.\n   * @return {Array<Object>} - The parsed comments.\n   */\n  /* eslint-disable no-unused-vars */\n  parse(sources) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = IParser;\n"
            }
          },
          {
            "Bk5nsalU": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/html",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\n\nclass HTML extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.comments = comments;\n  }\n}\nmodule.exports = HTML;\n"
            }
          },
          {
            "rJi2iTgI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/json",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "SJn3oplI": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers/javascript",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n"
            }
          },
          {
            "Bkphopx8": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/parser/parsers/javascript",
                "base": "synonyms.js",
                "ext": ".js",
                "name": "synonyms"
              },
              "source": "module.exports = {\n  arg: 'param',\n  argument: 'param',\n  constructor: 'class',\n  const: 'constant',\n  defaultvalue: 'default',\n  desc: 'description',\n  emits: 'fires',\n  exception: 'throws',\n  fileoverview: 'file',\n  func: 'function',\n  host: 'external',\n  linkcode: 'link',\n  linkplain: 'link',\n  virtual: 'abstract',\n  method: 'function',\n  overview: 'file',\n  prop: 'property',\n  return: 'returns',\n  var: 'member',\n};\n"
            }
          },
          {
            "H1R3spgL": {
              "cwd": "/Users/iwatakeshi/Documents/GitHub/mr-doc",
              "base": "src/",
              "path": {
                "root": "",
                "dir": "src/compiler/compilers/html/engines",
                "base": "theme.js",
                "ext": ".js",
                "name": "theme"
              },
              "source": "'use strict';\n\nclass Theme {\n  // constructor() {\n  //\n  // }\n  compile() {\n\n  }\n}\n\nmodule.exports = Theme;\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 121,
          "column": 2
        },
        "end": {
          "line": 140,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          121,
          140
        ]
      }
    }
  }
]