[
  {
    "description": "Parse the CLI arguments.",
    "tags": [
      {
        "title": "static",
        "description": null,
        "lineNumber": 2
      }
    ],
    "loc": {
      "start": {
        "line": 20,
        "column": 2
      },
      "end": {
        "line": 23,
        "column": 5
      }
    },
    "context": {
      "code": "static parse() {\r\n    return Yargs\r\n    .usage('Usage: mrdoc [options]', Option.cli())\r\n    .showHelpOnFail(false, 'Specify --help for available options')\r\n    .help('help', log.color.gray('Show help.'))\r\n    .alias('help', 'h')\r\n    .argv;\r\n  }",
      "file": {
        "id": "E1_QbLZRx",
        "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
        "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
        "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\cli\\index.js",
        "source": "/* eslint-env node */\r\n'use strict';\r\n\r\nconst Extension = require('../utils/extension');\r\nconst File = require('fs-extra');\r\nconst Log = require('../utils/log');\r\nconst Liftoff = require('liftoff');\r\nconst Option = require('mr-doc-utils').Option;\r\nconst Path = require('path');\r\nconst Promise = require('bluebird');\r\nconst Yargs = require('yargs');\r\nconst ViynlFS = require('vinyl-fs');\r\nconst isGlob = require('is-glob');\r\nconst log = Log.global();\r\nconst pkg = require('../../package.json');\r\nconst rc = require('rc');\r\nconst _ = require('lodash');\r\n\r\nclass CLI {\r\n  /**\r\n   * Parse the CLI arguments.\r\n   * @static\r\n   */\r\n  static parse() {\r\n    return Yargs\r\n    .usage('Usage: mrdoc [options]', Option.cli())\r\n    .showHelpOnFail(false, 'Specify --help for available options')\r\n    .help('help', log.color.gray('Show help.'))\r\n    .alias('help', 'h')\r\n    .argv;\r\n  }\r\n  /**\r\n   * Create the CLI.\r\n   * @static\r\n   * @return {Liftoff} - An instance of Liftoff.\r\n   */\r\n  static get rocket() {\r\n    // Create the CLI.\r\n    return new Liftoff({\r\n      name: 'mrdoc',\r\n      processTitle: 'mrdoc',\r\n      v8flags: require('v8flags'),\r\n    });\r\n  }\r\n  /**\r\n   * Launch the cli.\r\n   * @static\r\n   * @param {Object} - The parsed CLI arguments.\r\n   * @return {Promise<Stream>} - A promise to the stream.\r\n   */\r\n  static launch(argv) {\r\n    return new Promise((resolve, reject) => {\r\n      // Launch the CLI!\r\n      CLI.rocket.launch({\r\n        cwd: argv.cwd,\r\n        configPath: argv.mrdocrc,\r\n      }, env => CLI.handler(env, argv)\r\n      .then(stream => resolve(stream))\r\n      .catch(error => reject(error)));\r\n    });\r\n  }\r\n  /**\r\n   * Handles the result from the CLI.\r\n   * @static\r\n   */\r\n  static handler(env, options) {\r\n    const version = options.version || options.v;\r\n    const source = options.source || options.s;\r\n    if (version) {\r\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\r\n      process.exit();\r\n    }\r\n    if (_.isEmpty(source) && version === false) {\r\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\r\n      process.exit();\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      // Get the options.\r\n      const opts = rc('mrdoc', Option.merge(options));\r\n      const sources = opts.mrdoc.source.split(',')\r\n      .map(path => path.trim())\r\n      .map(path => {\r\n        // Check if the path is not in glob pattern.\r\n        if (!isGlob(path)) {\r\n          // Make sure the path is resolved.\r\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\r\n          // Check if the path is a file or directory.\r\n          if (_.isEmpty(Path.parse(path).ext)) {\r\n            // Check if the path has a '/' at the end.\r\n            str = str[str.length - 1] === Path.sep ?\r\n            str : `${str}${Path.sep}`;\r\n          }\r\n          // Make sure the file or directory exists;\r\n          if (File.existsSync(str)) {\r\n            // Check if the directory has sub-directories.\r\n            const hasSubDirs = File.readdirSync(str)\r\n            .filter(file =>\r\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\r\n            // Get the file extension.\r\n            const extension = Extension.find(opts.parser.language);\r\n            // Set the glob pattern based on 'hasSubDirs'.\r\n            str = hasSubDirs ?\r\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\r\n          } else return null;\r\n          return str;\r\n        }\r\n        return path;\r\n      });\r\n      // DEBUG: Sources\r\n      log.debug(log.color.blue('Sources:'), sources);\r\n      if (sources.indexOf(null) > -1) {\r\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\r\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = CLI;\r\n",
        "ref": [
          {
            "E1_QbLZRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\cli\\index.js",
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\nconst Extension = require('../utils/extension');\r\nconst File = require('fs-extra');\r\nconst Log = require('../utils/log');\r\nconst Liftoff = require('liftoff');\r\nconst Option = require('mr-doc-utils').Option;\r\nconst Path = require('path');\r\nconst Promise = require('bluebird');\r\nconst Yargs = require('yargs');\r\nconst ViynlFS = require('vinyl-fs');\r\nconst isGlob = require('is-glob');\r\nconst log = Log.global();\r\nconst pkg = require('../../package.json');\r\nconst rc = require('rc');\r\nconst _ = require('lodash');\r\n\r\nclass CLI {\r\n  /**\r\n   * Parse the CLI arguments.\r\n   * @static\r\n   */\r\n  static parse() {\r\n    return Yargs\r\n    .usage('Usage: mrdoc [options]', Option.cli())\r\n    .showHelpOnFail(false, 'Specify --help for available options')\r\n    .help('help', log.color.gray('Show help.'))\r\n    .alias('help', 'h')\r\n    .argv;\r\n  }\r\n  /**\r\n   * Create the CLI.\r\n   * @static\r\n   * @return {Liftoff} - An instance of Liftoff.\r\n   */\r\n  static get rocket() {\r\n    // Create the CLI.\r\n    return new Liftoff({\r\n      name: 'mrdoc',\r\n      processTitle: 'mrdoc',\r\n      v8flags: require('v8flags'),\r\n    });\r\n  }\r\n  /**\r\n   * Launch the cli.\r\n   * @static\r\n   * @param {Object} - The parsed CLI arguments.\r\n   * @return {Promise<Stream>} - A promise to the stream.\r\n   */\r\n  static launch(argv) {\r\n    return new Promise((resolve, reject) => {\r\n      // Launch the CLI!\r\n      CLI.rocket.launch({\r\n        cwd: argv.cwd,\r\n        configPath: argv.mrdocrc,\r\n      }, env => CLI.handler(env, argv)\r\n      .then(stream => resolve(stream))\r\n      .catch(error => reject(error)));\r\n    });\r\n  }\r\n  /**\r\n   * Handles the result from the CLI.\r\n   * @static\r\n   */\r\n  static handler(env, options) {\r\n    const version = options.version || options.v;\r\n    const source = options.source || options.s;\r\n    if (version) {\r\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\r\n      process.exit();\r\n    }\r\n    if (_.isEmpty(source) && version === false) {\r\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\r\n      process.exit();\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      // Get the options.\r\n      const opts = rc('mrdoc', Option.merge(options));\r\n      const sources = opts.mrdoc.source.split(',')\r\n      .map(path => path.trim())\r\n      .map(path => {\r\n        // Check if the path is not in glob pattern.\r\n        if (!isGlob(path)) {\r\n          // Make sure the path is resolved.\r\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\r\n          // Check if the path is a file or directory.\r\n          if (_.isEmpty(Path.parse(path).ext)) {\r\n            // Check if the path has a '/' at the end.\r\n            str = str[str.length - 1] === Path.sep ?\r\n            str : `${str}${Path.sep}`;\r\n          }\r\n          // Make sure the file or directory exists;\r\n          if (File.existsSync(str)) {\r\n            // Check if the directory has sub-directories.\r\n            const hasSubDirs = File.readdirSync(str)\r\n            .filter(file =>\r\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\r\n            // Get the file extension.\r\n            const extension = Extension.find(opts.parser.language);\r\n            // Set the glob pattern based on 'hasSubDirs'.\r\n            str = hasSubDirs ?\r\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\r\n          } else return null;\r\n          return str;\r\n        }\r\n        return path;\r\n      });\r\n      // DEBUG: Sources\r\n      log.debug(log.color.blue('Sources:'), sources);\r\n      if (sources.indexOf(null) > -1) {\r\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\r\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = CLI;\r\n"
            }
          },
          {
            "EkedmbI-Rg": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\index.js",
              "source": "'use strict';\r\nconst JSONC = require('./compilers/json/');\r\n// const HTML = require('./compilers/html');\r\n\r\nclass Compiler {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.compiler().file.format) {\r\n      case 'json':\r\n        return (new JSONC(this.options));\r\n      case 'html':\r\n        // return (new HTML(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Compiler;\r\n"
            }
          },
          {
            "VJZdXZU-Ae": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\index.js",
              "source": "'use strict';\r\nconst JavaScript = require('./parsers/javascript/');\r\n\r\nclass Parser {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.parser().language) {\r\n      case 'js':\r\n      case 'javascript':\r\n        return (new JavaScript(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Parser;\r\n"
            }
          },
          {
            "VkzumbIW0x": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\extension.js",
              "source": "'use strict';\r\n\r\nclass Extension {\r\n  static find(language) {\r\n    return Extension.extensions()[language];\r\n  }\r\n  static extensions() {\r\n    return {\r\n      js: '.js',\r\n      javascript: '.js',\r\n      json: '.json',\r\n      html: '.html',\r\n      typescript: '.ts',\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = Extension;\r\n"
            }
          },
          {
            "EJ7uQ-L-Al": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\log.js",
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\n/* eslint-env node */\r\nconst Utils = require('mr-doc-utils');\r\nconst log = new Utils.Log();\r\nconst _ = require('lodash');\r\n\r\nclass Log {\r\n  constructor(options) {\r\n    if (options.silent) {\r\n      log.on('error', () => { /* NOOP */});\r\n      return log;\r\n    }\r\n    this.levels(options.level)\r\n    .forEach(level => {\r\n      if (level === 'error') this.error();\r\n      else this.other(level);\r\n    });\r\n    return log;\r\n  }\r\n  levels(level) {\r\n    const levels = _.isString(level) ? level.split(',') : level;\r\n    return levels\r\n    .map(i => i.replace(/\\s/g, ''));\r\n  }\r\n  error() {\r\n    log.on('error', function error() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args.map(i => log.color.red(i)));\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  other(level) {\r\n    log.on(level, function logger() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args);\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  /**\r\n   * Get the global instance of Log.\r\n   * @return {Log} - An instance of Log.\r\n   */\r\n  static global() {\r\n    log.color = Utils.Log.color;\r\n    return log;\r\n  }\r\n}\r\n\r\nmodule.exports = Log;\r\n"
            }
          },
          {
            "V1V_7WIWAg": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\output.js",
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nconst Option = require('mr-doc-utils').Option;\n\nclass Output {\n  static handler(options, buffer) {\n    const opt = (new Option(options)).options();\n    return function (callback) {\n      Output.format(opt, buffer).forEach(Output.toStream(opt, this));\n      callback();\n    };\n  }\n  static format(options, buffer) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler().file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n\n  static toStream(options, context) {\n    const format = options.compiler().file.format;\n    const file = options.compiler().file;\n    return function (f) {\n      if (format === 'json' || format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "EJSdQZI-Ce": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\source.js",
              "source": "'use strict';\r\nconst ShortID = require('shortid');\r\nconst File = require('fs-extra');\r\nconst _ = require('lodash');\r\n\r\nclass Source {\r\n  static create(files) {\r\n    // Process the files.\r\n    const result = files\r\n    .map(file => Source.processFile(file));\r\n    // Create references for each file.\r\n    const references = result\r\n    .map(file => Source.createReference(file));\r\n    // Process the references and attach it to each file.\r\n    return result\r\n    .map(file => Source.processReference(file, references));\r\n  }\r\n  static processFile(file) {\r\n    return {\r\n      id: ShortID.generate(),\r\n      cwd: file.cwd,\r\n      base: file.base,\r\n      path: file.path,\r\n      source: File.readFileSync(file.path, 'utf8'),\r\n      comments: undefined,\r\n    };\r\n  }\r\n  static createReference(file) {\r\n    return {\r\n      id: file.id,\r\n      cwd: file.cwd,\r\n      base: file.base,\r\n      path: file.path,\r\n      source: file.source,\r\n      comments: file.comments,\r\n    };\r\n  }\r\n  static processReference(file, references) {\r\n    return _.merge(file, {\r\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = Source;\r\n"
            }
          },
          {
            "VJU_QZUb0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\compilers\\interface.js",
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.compiler() : options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "VyPuX-LbCx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\engines\\javascript.engine.js",
              "source": "'use strict';\r\n\r\nconst Babylon = require('babylon');\r\nconst Acorn = require('acorn');\r\nconst Espree = require('espree');\r\nconst ESCodeGen = require('escodegen');\r\nconst ESTraverse = require('estraverse');\r\nconst traverse = require('babel-traverse').default;\r\n\r\nconst opts = {\r\n  acorn: (version, comments, tokens) => ({\r\n    ecmaVersion: version,\r\n    locations: true,\r\n    onComment: comments,\r\n    onToken: tokens,\r\n    ranges: true,\r\n  }),\r\n  babylon: () => ({\r\n    allowImportExportEverywhere: true,\r\n    plugins: [\r\n      'jsx',\r\n      'flow',\r\n      'asyncFunctions',\r\n      'classConstructorCall',\r\n      'doExpressions',\r\n      'trailingFunctionCommas',\r\n      'objectRestSpread',\r\n      'decorators',\r\n      'classProperties',\r\n      'exportExtensions',\r\n      'exponentiationOperator',\r\n      'asyncGenerators',\r\n      'functionBind',\r\n      'functionSent',\r\n    ],\r\n    sourceType: 'module',\r\n  }),\r\n  espree: (version) => ({\r\n    attachComment: true,\r\n    comment: true,\r\n    ecmaFeatures: {\r\n      experimentalObjectRestSpread: true,\r\n      globalReturn: true,\r\n      impliedStrict: true,\r\n      jsx: true,\r\n    },\r\n    ecmaVersion: version,\r\n    loc: true,\r\n    range: true,\r\n    sourceType: 'module',\r\n    tokens: true,\r\n  }),\r\n};\r\n\r\nclass Engine {\r\n  constructor(options) {\r\n    this.options = options;\r\n    switch (this.options.engine) {\r\n      case 'acorn':\r\n        this.engine = Acorn;\r\n        break;\r\n      case 'espree':\r\n        this.engine = Espree;\r\n        break;\r\n      default:\r\n        this.engine = Babylon;\r\n        break;\r\n    }\r\n  }\r\n  parse(file) {\r\n    const comments = [];\r\n    const tokens = [];\r\n    try {\r\n      switch (this.options.engine) {\r\n        case 'acorn':\r\n          return ESCodeGen\r\n          .attachComments(this.engine.parse(file.source,\r\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\r\n        case 'espree':\r\n          return this.engine.parse(file.source, opts.espree(this.options.version));\r\n        default:\r\n          return this.engine.parse(file.source, opts.babylon());\r\n      }\r\n    } catch (error) {\r\n      throw (new Error(error));\r\n    }\r\n  }\r\n  static traverse(options, ast, callback) {\r\n    switch (options.engine) {\r\n      case 'babylon':\r\n        traverse(ast, {\r\n          enter: (path) => {\r\n            const node = path.node;\r\n            callback(node);\r\n          } });\r\n        break;\r\n      default:\r\n        ESTraverse.traverse(ast, {\r\n          /* eslint-disable no-param-reassign */\r\n          enter: (node) => {\r\n            if (node.type === 'Program') {\r\n              node = node.body[0];\r\n            }\r\n            callback(node);\r\n          } });\r\n          /* eslint-enable no-param-reassign */\r\n        break;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Engine;\r\n"
            }
          },
          {
            "EyudQbUb0e": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\interface.js",
              "source": "'use strict';\r\nclass IParser {\r\n  /**\r\n   * @constructor\r\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\r\n   */\r\n  constructor(options) {\r\n    this.options = options.parser ? options.parser() : options;\r\n  }\r\n  /**\r\n   * Parses the sources' comments into the desired output.\r\n   * @param  {Array<Object>} results - The files to parse.\r\n   * @return {Array<Object>} - The parsed comments.\r\n   */\r\n  /* eslint-disable no-unused-vars */\r\n  parse(sources) {\r\n    // ...\r\n  }\r\n  /* eslint-enable no-unused-vars */\r\n}\r\n\r\nmodule.exports = IParser;\r\n"
            }
          },
          {
            "4JF_XW8Z0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\compilers\\json\\index.js",
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "4yc_7bIZ0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\javascript\\index.js",
              "source": "'use strict';\r\n\r\nconst Doctrine = require('doctrine');\r\nconst IParser = require('../interface');\r\nconst Engine = require('../../engines/javascript.engine.js');\r\nconst _ = require('lodash');\r\nconst Log = require('mr-doc-utils').Log;\r\nconst log = new Log();\r\nconst synonyms = require('./synonyms.js');\r\n\r\nclass JavaScript extends IParser {\r\n  constructor(options) {\r\n    super(options);\r\n    this.visited = {};\r\n    this.engine = new Engine(this.options);\r\n    this.comments = [];\r\n    this.results = [];\r\n  }\r\n  /**\r\n   * Parse the file.\r\n   * @param {Object} - The file to parse.\r\n   */\r\n  parse(file) {\r\n    this.file = file;\r\n    this.ast = this.engine.parse(this.file);\r\n    // DEBUG: AST\r\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\r\n    [\r\n      { type: 'leadingComments', context: true },\r\n      { type: 'innerComments', context: false },\r\n      { type: 'trailingComments', context: false },\r\n    ].forEach(comment => this.walkComments(comment));\r\n    return this.results;\r\n  }\r\n  /**\r\n   * Walk the comments.\r\n   * @param {Object} - The comment type and context to walk.\r\n   */\r\n  walkComments(comment) {\r\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\r\n        .filter(this.isJSDocComment)\r\n        .forEach(this.parseComment(node, comment.context)));\r\n  }\r\n  /**\r\n   * Parse the comment.\r\n   * @param {Node} - The current node.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseComment(node, includeContext) {\r\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\r\n    range = !range ? node.range : range;\r\n    range = !range ? [node.start, node.end] : range;\r\n    const context = {\r\n      code: null,\r\n      file: this.file,\r\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\r\n      range: {\r\n        column: [node.loc.start.column, node.loc.end.column],\r\n        line: [node.loc.start.line, node.loc.end.line],\r\n      },\r\n    };\r\n    return (comment) => {\r\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\r\n      if (!this.visited[key]) {\r\n        this.visited[key] = true;\r\n        if (includeContext) {\r\n          Object.defineProperty(context, 'ast', {\r\n            enumerable: false,\r\n            value: node,\r\n          });\r\n          context.code = this.file.source.substring.apply(this.file.source, range);\r\n        }\r\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\r\n      }\r\n    };\r\n  }\r\n  /**\r\n   * Parse the JSDoc comment.\r\n   * @param {String} - The comment to parse.\r\n   * @param {Location} - The comment location.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseJSDoc(comment, loc, context) {\r\n    const result = Doctrine.parse(comment, {\r\n      lineNumbers: true,\r\n      recoverable: true,\r\n      sloppy: true,\r\n      unwrap: true,\r\n    });\r\n    result.loc = loc;\r\n    result.context = context;\r\n    result.errors = [];\r\n    let i = 0;\r\n    while (i < result.tags.length) {\r\n      const tag = result.tags[i];\r\n      if (tag.errors) {\r\n        for (let j = 0; j < tag.errors.length; j++) {\r\n          result.errors.push({ message: tag.errors[j] });\r\n        }\r\n        result.tags.splice(i, 1);\r\n      } else i++;\r\n    }\r\n    return JavaScript.normalize(result);\r\n  }\r\n  /**\r\n   * Determine whether the comment is normalized.\r\n   * @param {String} - The comment to determine.\r\n   * @return {Boolean} - The truth value.\r\n   */\r\n  isJSDocComment(comment) {\r\n    const asterisks = comment.value.match(/^(\\*+)/);\r\n    return (comment.type === 'CommentBlock' ||\r\n      comment.type === 'Block')\r\n      && asterisks && asterisks[1].length === 1;\r\n  }\r\n  /**\r\n   * Normalize the comment tags.\r\n   * @param {Array} - The comment to normalize.\r\n   * @return {Array} - The comment containing normalized tags.\r\n   */\r\n  static normalize(comment) {\r\n    return _.assignIn({}, comment, {\r\n      tags: comment.tags.map(tag => {\r\n        let title = tag.title.toLowerCase();\r\n        const canonical = synonyms[title];\r\n        if (!canonical) {\r\n          switch (title[0]) {\r\n            case 'e':\r\n              if (title === 'extend') title = 'extends';\r\n              break;\r\n            case 'j':\r\n              if (title === 'jsfiddles') title = 'jsfiddle';\r\n              break;\r\n            default: break;\r\n          }\r\n        }\r\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\r\n      }),\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = JavaScript;\r\n"
            }
          },
          {
            "VkjOmWLbAl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\javascript\\synonyms.js",
              "source": "module.exports = {\r\n  arg: 'param',\r\n  argument: 'param',\r\n  constructor: 'class',\r\n  const: 'constant',\r\n  defaultvalue: 'default',\r\n  desc: 'description',\r\n  emits: 'fires',\r\n  exception: 'throws',\r\n  fileoverview: 'file',\r\n  func: 'function',\r\n  host: 'external',\r\n  linkcode: 'link',\r\n  linkplain: 'link',\r\n  virtual: 'abstract',\r\n  method: 'function',\r\n  overview: 'file',\r\n  prop: 'property',\r\n  return: 'returns',\r\n  var: 'member',\r\n};\r\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 24,
          "column": 2
        },
        "end": {
          "line": 31,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          24,
          31
        ]
      }
    }
  },
  {
    "description": "Create the CLI.",
    "tags": [
      {
        "title": "static",
        "description": null,
        "lineNumber": 2
      },
      {
        "title": "returns",
        "description": "An instance of Liftoff.",
        "lineNumber": 3,
        "type": {
          "type": "NameExpression",
          "name": "Liftoff"
        }
      }
    ],
    "loc": {
      "start": {
        "line": 32,
        "column": 2
      },
      "end": {
        "line": 36,
        "column": 5
      }
    },
    "context": {
      "code": "static get rocket() {\r\n    // Create the CLI.\r\n    return new Liftoff({\r\n      name: 'mrdoc',\r\n      processTitle: 'mrdoc',\r\n      v8flags: require('v8flags'),\r\n    });\r\n  }",
      "file": {
        "id": "E1_QbLZRx",
        "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
        "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
        "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\cli\\index.js",
        "source": "/* eslint-env node */\r\n'use strict';\r\n\r\nconst Extension = require('../utils/extension');\r\nconst File = require('fs-extra');\r\nconst Log = require('../utils/log');\r\nconst Liftoff = require('liftoff');\r\nconst Option = require('mr-doc-utils').Option;\r\nconst Path = require('path');\r\nconst Promise = require('bluebird');\r\nconst Yargs = require('yargs');\r\nconst ViynlFS = require('vinyl-fs');\r\nconst isGlob = require('is-glob');\r\nconst log = Log.global();\r\nconst pkg = require('../../package.json');\r\nconst rc = require('rc');\r\nconst _ = require('lodash');\r\n\r\nclass CLI {\r\n  /**\r\n   * Parse the CLI arguments.\r\n   * @static\r\n   */\r\n  static parse() {\r\n    return Yargs\r\n    .usage('Usage: mrdoc [options]', Option.cli())\r\n    .showHelpOnFail(false, 'Specify --help for available options')\r\n    .help('help', log.color.gray('Show help.'))\r\n    .alias('help', 'h')\r\n    .argv;\r\n  }\r\n  /**\r\n   * Create the CLI.\r\n   * @static\r\n   * @return {Liftoff} - An instance of Liftoff.\r\n   */\r\n  static get rocket() {\r\n    // Create the CLI.\r\n    return new Liftoff({\r\n      name: 'mrdoc',\r\n      processTitle: 'mrdoc',\r\n      v8flags: require('v8flags'),\r\n    });\r\n  }\r\n  /**\r\n   * Launch the cli.\r\n   * @static\r\n   * @param {Object} - The parsed CLI arguments.\r\n   * @return {Promise<Stream>} - A promise to the stream.\r\n   */\r\n  static launch(argv) {\r\n    return new Promise((resolve, reject) => {\r\n      // Launch the CLI!\r\n      CLI.rocket.launch({\r\n        cwd: argv.cwd,\r\n        configPath: argv.mrdocrc,\r\n      }, env => CLI.handler(env, argv)\r\n      .then(stream => resolve(stream))\r\n      .catch(error => reject(error)));\r\n    });\r\n  }\r\n  /**\r\n   * Handles the result from the CLI.\r\n   * @static\r\n   */\r\n  static handler(env, options) {\r\n    const version = options.version || options.v;\r\n    const source = options.source || options.s;\r\n    if (version) {\r\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\r\n      process.exit();\r\n    }\r\n    if (_.isEmpty(source) && version === false) {\r\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\r\n      process.exit();\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      // Get the options.\r\n      const opts = rc('mrdoc', Option.merge(options));\r\n      const sources = opts.mrdoc.source.split(',')\r\n      .map(path => path.trim())\r\n      .map(path => {\r\n        // Check if the path is not in glob pattern.\r\n        if (!isGlob(path)) {\r\n          // Make sure the path is resolved.\r\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\r\n          // Check if the path is a file or directory.\r\n          if (_.isEmpty(Path.parse(path).ext)) {\r\n            // Check if the path has a '/' at the end.\r\n            str = str[str.length - 1] === Path.sep ?\r\n            str : `${str}${Path.sep}`;\r\n          }\r\n          // Make sure the file or directory exists;\r\n          if (File.existsSync(str)) {\r\n            // Check if the directory has sub-directories.\r\n            const hasSubDirs = File.readdirSync(str)\r\n            .filter(file =>\r\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\r\n            // Get the file extension.\r\n            const extension = Extension.find(opts.parser.language);\r\n            // Set the glob pattern based on 'hasSubDirs'.\r\n            str = hasSubDirs ?\r\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\r\n          } else return null;\r\n          return str;\r\n        }\r\n        return path;\r\n      });\r\n      // DEBUG: Sources\r\n      log.debug(log.color.blue('Sources:'), sources);\r\n      if (sources.indexOf(null) > -1) {\r\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\r\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = CLI;\r\n",
        "ref": [
          {
            "E1_QbLZRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\cli\\index.js",
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\nconst Extension = require('../utils/extension');\r\nconst File = require('fs-extra');\r\nconst Log = require('../utils/log');\r\nconst Liftoff = require('liftoff');\r\nconst Option = require('mr-doc-utils').Option;\r\nconst Path = require('path');\r\nconst Promise = require('bluebird');\r\nconst Yargs = require('yargs');\r\nconst ViynlFS = require('vinyl-fs');\r\nconst isGlob = require('is-glob');\r\nconst log = Log.global();\r\nconst pkg = require('../../package.json');\r\nconst rc = require('rc');\r\nconst _ = require('lodash');\r\n\r\nclass CLI {\r\n  /**\r\n   * Parse the CLI arguments.\r\n   * @static\r\n   */\r\n  static parse() {\r\n    return Yargs\r\n    .usage('Usage: mrdoc [options]', Option.cli())\r\n    .showHelpOnFail(false, 'Specify --help for available options')\r\n    .help('help', log.color.gray('Show help.'))\r\n    .alias('help', 'h')\r\n    .argv;\r\n  }\r\n  /**\r\n   * Create the CLI.\r\n   * @static\r\n   * @return {Liftoff} - An instance of Liftoff.\r\n   */\r\n  static get rocket() {\r\n    // Create the CLI.\r\n    return new Liftoff({\r\n      name: 'mrdoc',\r\n      processTitle: 'mrdoc',\r\n      v8flags: require('v8flags'),\r\n    });\r\n  }\r\n  /**\r\n   * Launch the cli.\r\n   * @static\r\n   * @param {Object} - The parsed CLI arguments.\r\n   * @return {Promise<Stream>} - A promise to the stream.\r\n   */\r\n  static launch(argv) {\r\n    return new Promise((resolve, reject) => {\r\n      // Launch the CLI!\r\n      CLI.rocket.launch({\r\n        cwd: argv.cwd,\r\n        configPath: argv.mrdocrc,\r\n      }, env => CLI.handler(env, argv)\r\n      .then(stream => resolve(stream))\r\n      .catch(error => reject(error)));\r\n    });\r\n  }\r\n  /**\r\n   * Handles the result from the CLI.\r\n   * @static\r\n   */\r\n  static handler(env, options) {\r\n    const version = options.version || options.v;\r\n    const source = options.source || options.s;\r\n    if (version) {\r\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\r\n      process.exit();\r\n    }\r\n    if (_.isEmpty(source) && version === false) {\r\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\r\n      process.exit();\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      // Get the options.\r\n      const opts = rc('mrdoc', Option.merge(options));\r\n      const sources = opts.mrdoc.source.split(',')\r\n      .map(path => path.trim())\r\n      .map(path => {\r\n        // Check if the path is not in glob pattern.\r\n        if (!isGlob(path)) {\r\n          // Make sure the path is resolved.\r\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\r\n          // Check if the path is a file or directory.\r\n          if (_.isEmpty(Path.parse(path).ext)) {\r\n            // Check if the path has a '/' at the end.\r\n            str = str[str.length - 1] === Path.sep ?\r\n            str : `${str}${Path.sep}`;\r\n          }\r\n          // Make sure the file or directory exists;\r\n          if (File.existsSync(str)) {\r\n            // Check if the directory has sub-directories.\r\n            const hasSubDirs = File.readdirSync(str)\r\n            .filter(file =>\r\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\r\n            // Get the file extension.\r\n            const extension = Extension.find(opts.parser.language);\r\n            // Set the glob pattern based on 'hasSubDirs'.\r\n            str = hasSubDirs ?\r\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\r\n          } else return null;\r\n          return str;\r\n        }\r\n        return path;\r\n      });\r\n      // DEBUG: Sources\r\n      log.debug(log.color.blue('Sources:'), sources);\r\n      if (sources.indexOf(null) > -1) {\r\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\r\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = CLI;\r\n"
            }
          },
          {
            "EkedmbI-Rg": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\index.js",
              "source": "'use strict';\r\nconst JSONC = require('./compilers/json/');\r\n// const HTML = require('./compilers/html');\r\n\r\nclass Compiler {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.compiler().file.format) {\r\n      case 'json':\r\n        return (new JSONC(this.options));\r\n      case 'html':\r\n        // return (new HTML(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Compiler;\r\n"
            }
          },
          {
            "VJZdXZU-Ae": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\index.js",
              "source": "'use strict';\r\nconst JavaScript = require('./parsers/javascript/');\r\n\r\nclass Parser {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.parser().language) {\r\n      case 'js':\r\n      case 'javascript':\r\n        return (new JavaScript(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Parser;\r\n"
            }
          },
          {
            "VkzumbIW0x": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\extension.js",
              "source": "'use strict';\r\n\r\nclass Extension {\r\n  static find(language) {\r\n    return Extension.extensions()[language];\r\n  }\r\n  static extensions() {\r\n    return {\r\n      js: '.js',\r\n      javascript: '.js',\r\n      json: '.json',\r\n      html: '.html',\r\n      typescript: '.ts',\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = Extension;\r\n"
            }
          },
          {
            "EJ7uQ-L-Al": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\log.js",
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\n/* eslint-env node */\r\nconst Utils = require('mr-doc-utils');\r\nconst log = new Utils.Log();\r\nconst _ = require('lodash');\r\n\r\nclass Log {\r\n  constructor(options) {\r\n    if (options.silent) {\r\n      log.on('error', () => { /* NOOP */});\r\n      return log;\r\n    }\r\n    this.levels(options.level)\r\n    .forEach(level => {\r\n      if (level === 'error') this.error();\r\n      else this.other(level);\r\n    });\r\n    return log;\r\n  }\r\n  levels(level) {\r\n    const levels = _.isString(level) ? level.split(',') : level;\r\n    return levels\r\n    .map(i => i.replace(/\\s/g, ''));\r\n  }\r\n  error() {\r\n    log.on('error', function error() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args.map(i => log.color.red(i)));\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  other(level) {\r\n    log.on(level, function logger() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args);\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  /**\r\n   * Get the global instance of Log.\r\n   * @return {Log} - An instance of Log.\r\n   */\r\n  static global() {\r\n    log.color = Utils.Log.color;\r\n    return log;\r\n  }\r\n}\r\n\r\nmodule.exports = Log;\r\n"
            }
          },
          {
            "V1V_7WIWAg": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\output.js",
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nconst Option = require('mr-doc-utils').Option;\n\nclass Output {\n  static handler(options, buffer) {\n    const opt = (new Option(options)).options();\n    return function (callback) {\n      Output.format(opt, buffer).forEach(Output.toStream(opt, this));\n      callback();\n    };\n  }\n  static format(options, buffer) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler().file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n\n  static toStream(options, context) {\n    const format = options.compiler().file.format;\n    const file = options.compiler().file;\n    return function (f) {\n      if (format === 'json' || format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "EJSdQZI-Ce": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\source.js",
              "source": "'use strict';\r\nconst ShortID = require('shortid');\r\nconst File = require('fs-extra');\r\nconst _ = require('lodash');\r\n\r\nclass Source {\r\n  static create(files) {\r\n    // Process the files.\r\n    const result = files\r\n    .map(file => Source.processFile(file));\r\n    // Create references for each file.\r\n    const references = result\r\n    .map(file => Source.createReference(file));\r\n    // Process the references and attach it to each file.\r\n    return result\r\n    .map(file => Source.processReference(file, references));\r\n  }\r\n  static processFile(file) {\r\n    return {\r\n      id: ShortID.generate(),\r\n      cwd: file.cwd,\r\n      base: file.base,\r\n      path: file.path,\r\n      source: File.readFileSync(file.path, 'utf8'),\r\n      comments: undefined,\r\n    };\r\n  }\r\n  static createReference(file) {\r\n    return {\r\n      id: file.id,\r\n      cwd: file.cwd,\r\n      base: file.base,\r\n      path: file.path,\r\n      source: file.source,\r\n      comments: file.comments,\r\n    };\r\n  }\r\n  static processReference(file, references) {\r\n    return _.merge(file, {\r\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = Source;\r\n"
            }
          },
          {
            "VJU_QZUb0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\compilers\\interface.js",
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.compiler() : options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "VyPuX-LbCx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\engines\\javascript.engine.js",
              "source": "'use strict';\r\n\r\nconst Babylon = require('babylon');\r\nconst Acorn = require('acorn');\r\nconst Espree = require('espree');\r\nconst ESCodeGen = require('escodegen');\r\nconst ESTraverse = require('estraverse');\r\nconst traverse = require('babel-traverse').default;\r\n\r\nconst opts = {\r\n  acorn: (version, comments, tokens) => ({\r\n    ecmaVersion: version,\r\n    locations: true,\r\n    onComment: comments,\r\n    onToken: tokens,\r\n    ranges: true,\r\n  }),\r\n  babylon: () => ({\r\n    allowImportExportEverywhere: true,\r\n    plugins: [\r\n      'jsx',\r\n      'flow',\r\n      'asyncFunctions',\r\n      'classConstructorCall',\r\n      'doExpressions',\r\n      'trailingFunctionCommas',\r\n      'objectRestSpread',\r\n      'decorators',\r\n      'classProperties',\r\n      'exportExtensions',\r\n      'exponentiationOperator',\r\n      'asyncGenerators',\r\n      'functionBind',\r\n      'functionSent',\r\n    ],\r\n    sourceType: 'module',\r\n  }),\r\n  espree: (version) => ({\r\n    attachComment: true,\r\n    comment: true,\r\n    ecmaFeatures: {\r\n      experimentalObjectRestSpread: true,\r\n      globalReturn: true,\r\n      impliedStrict: true,\r\n      jsx: true,\r\n    },\r\n    ecmaVersion: version,\r\n    loc: true,\r\n    range: true,\r\n    sourceType: 'module',\r\n    tokens: true,\r\n  }),\r\n};\r\n\r\nclass Engine {\r\n  constructor(options) {\r\n    this.options = options;\r\n    switch (this.options.engine) {\r\n      case 'acorn':\r\n        this.engine = Acorn;\r\n        break;\r\n      case 'espree':\r\n        this.engine = Espree;\r\n        break;\r\n      default:\r\n        this.engine = Babylon;\r\n        break;\r\n    }\r\n  }\r\n  parse(file) {\r\n    const comments = [];\r\n    const tokens = [];\r\n    try {\r\n      switch (this.options.engine) {\r\n        case 'acorn':\r\n          return ESCodeGen\r\n          .attachComments(this.engine.parse(file.source,\r\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\r\n        case 'espree':\r\n          return this.engine.parse(file.source, opts.espree(this.options.version));\r\n        default:\r\n          return this.engine.parse(file.source, opts.babylon());\r\n      }\r\n    } catch (error) {\r\n      throw (new Error(error));\r\n    }\r\n  }\r\n  static traverse(options, ast, callback) {\r\n    switch (options.engine) {\r\n      case 'babylon':\r\n        traverse(ast, {\r\n          enter: (path) => {\r\n            const node = path.node;\r\n            callback(node);\r\n          } });\r\n        break;\r\n      default:\r\n        ESTraverse.traverse(ast, {\r\n          /* eslint-disable no-param-reassign */\r\n          enter: (node) => {\r\n            if (node.type === 'Program') {\r\n              node = node.body[0];\r\n            }\r\n            callback(node);\r\n          } });\r\n          /* eslint-enable no-param-reassign */\r\n        break;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Engine;\r\n"
            }
          },
          {
            "EyudQbUb0e": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\interface.js",
              "source": "'use strict';\r\nclass IParser {\r\n  /**\r\n   * @constructor\r\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\r\n   */\r\n  constructor(options) {\r\n    this.options = options.parser ? options.parser() : options;\r\n  }\r\n  /**\r\n   * Parses the sources' comments into the desired output.\r\n   * @param  {Array<Object>} results - The files to parse.\r\n   * @return {Array<Object>} - The parsed comments.\r\n   */\r\n  /* eslint-disable no-unused-vars */\r\n  parse(sources) {\r\n    // ...\r\n  }\r\n  /* eslint-enable no-unused-vars */\r\n}\r\n\r\nmodule.exports = IParser;\r\n"
            }
          },
          {
            "4JF_XW8Z0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\compilers\\json\\index.js",
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "4yc_7bIZ0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\javascript\\index.js",
              "source": "'use strict';\r\n\r\nconst Doctrine = require('doctrine');\r\nconst IParser = require('../interface');\r\nconst Engine = require('../../engines/javascript.engine.js');\r\nconst _ = require('lodash');\r\nconst Log = require('mr-doc-utils').Log;\r\nconst log = new Log();\r\nconst synonyms = require('./synonyms.js');\r\n\r\nclass JavaScript extends IParser {\r\n  constructor(options) {\r\n    super(options);\r\n    this.visited = {};\r\n    this.engine = new Engine(this.options);\r\n    this.comments = [];\r\n    this.results = [];\r\n  }\r\n  /**\r\n   * Parse the file.\r\n   * @param {Object} - The file to parse.\r\n   */\r\n  parse(file) {\r\n    this.file = file;\r\n    this.ast = this.engine.parse(this.file);\r\n    // DEBUG: AST\r\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\r\n    [\r\n      { type: 'leadingComments', context: true },\r\n      { type: 'innerComments', context: false },\r\n      { type: 'trailingComments', context: false },\r\n    ].forEach(comment => this.walkComments(comment));\r\n    return this.results;\r\n  }\r\n  /**\r\n   * Walk the comments.\r\n   * @param {Object} - The comment type and context to walk.\r\n   */\r\n  walkComments(comment) {\r\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\r\n        .filter(this.isJSDocComment)\r\n        .forEach(this.parseComment(node, comment.context)));\r\n  }\r\n  /**\r\n   * Parse the comment.\r\n   * @param {Node} - The current node.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseComment(node, includeContext) {\r\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\r\n    range = !range ? node.range : range;\r\n    range = !range ? [node.start, node.end] : range;\r\n    const context = {\r\n      code: null,\r\n      file: this.file,\r\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\r\n      range: {\r\n        column: [node.loc.start.column, node.loc.end.column],\r\n        line: [node.loc.start.line, node.loc.end.line],\r\n      },\r\n    };\r\n    return (comment) => {\r\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\r\n      if (!this.visited[key]) {\r\n        this.visited[key] = true;\r\n        if (includeContext) {\r\n          Object.defineProperty(context, 'ast', {\r\n            enumerable: false,\r\n            value: node,\r\n          });\r\n          context.code = this.file.source.substring.apply(this.file.source, range);\r\n        }\r\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\r\n      }\r\n    };\r\n  }\r\n  /**\r\n   * Parse the JSDoc comment.\r\n   * @param {String} - The comment to parse.\r\n   * @param {Location} - The comment location.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseJSDoc(comment, loc, context) {\r\n    const result = Doctrine.parse(comment, {\r\n      lineNumbers: true,\r\n      recoverable: true,\r\n      sloppy: true,\r\n      unwrap: true,\r\n    });\r\n    result.loc = loc;\r\n    result.context = context;\r\n    result.errors = [];\r\n    let i = 0;\r\n    while (i < result.tags.length) {\r\n      const tag = result.tags[i];\r\n      if (tag.errors) {\r\n        for (let j = 0; j < tag.errors.length; j++) {\r\n          result.errors.push({ message: tag.errors[j] });\r\n        }\r\n        result.tags.splice(i, 1);\r\n      } else i++;\r\n    }\r\n    return JavaScript.normalize(result);\r\n  }\r\n  /**\r\n   * Determine whether the comment is normalized.\r\n   * @param {String} - The comment to determine.\r\n   * @return {Boolean} - The truth value.\r\n   */\r\n  isJSDocComment(comment) {\r\n    const asterisks = comment.value.match(/^(\\*+)/);\r\n    return (comment.type === 'CommentBlock' ||\r\n      comment.type === 'Block')\r\n      && asterisks && asterisks[1].length === 1;\r\n  }\r\n  /**\r\n   * Normalize the comment tags.\r\n   * @param {Array} - The comment to normalize.\r\n   * @return {Array} - The comment containing normalized tags.\r\n   */\r\n  static normalize(comment) {\r\n    return _.assignIn({}, comment, {\r\n      tags: comment.tags.map(tag => {\r\n        let title = tag.title.toLowerCase();\r\n        const canonical = synonyms[title];\r\n        if (!canonical) {\r\n          switch (title[0]) {\r\n            case 'e':\r\n              if (title === 'extend') title = 'extends';\r\n              break;\r\n            case 'j':\r\n              if (title === 'jsfiddles') title = 'jsfiddle';\r\n              break;\r\n            default: break;\r\n          }\r\n        }\r\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\r\n      }),\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = JavaScript;\r\n"
            }
          },
          {
            "VkjOmWLbAl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\javascript\\synonyms.js",
              "source": "module.exports = {\r\n  arg: 'param',\r\n  argument: 'param',\r\n  constructor: 'class',\r\n  const: 'constant',\r\n  defaultvalue: 'default',\r\n  desc: 'description',\r\n  emits: 'fires',\r\n  exception: 'throws',\r\n  fileoverview: 'file',\r\n  func: 'function',\r\n  host: 'external',\r\n  linkcode: 'link',\r\n  linkplain: 'link',\r\n  virtual: 'abstract',\r\n  method: 'function',\r\n  overview: 'file',\r\n  prop: 'property',\r\n  return: 'returns',\r\n  var: 'member',\r\n};\r\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 37,
          "column": 2
        },
        "end": {
          "line": 44,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          37,
          44
        ]
      }
    }
  },
  {
    "description": "Launch the cli.",
    "tags": [
      {
        "title": "static",
        "description": null,
        "lineNumber": 2
      },
      {
        "title": "param",
        "description": "The parsed CLI arguments.",
        "lineNumber": 3,
        "type": null,
        "name": "Object"
      },
      {
        "title": "returns",
        "description": "A promise to the stream.",
        "lineNumber": 4,
        "type": {
          "type": "TypeApplication",
          "expression": {
            "type": "NameExpression",
            "name": "Promise"
          },
          "applications": [
            {
              "type": "NameExpression",
              "name": "Stream"
            }
          ]
        }
      }
    ],
    "loc": {
      "start": {
        "line": 45,
        "column": 2
      },
      "end": {
        "line": 50,
        "column": 5
      }
    },
    "context": {
      "code": "static launch(argv) {\r\n    return new Promise((resolve, reject) => {\r\n      // Launch the CLI!\r\n      CLI.rocket.launch({\r\n        cwd: argv.cwd,\r\n        configPath: argv.mrdocrc,\r\n      }, env => CLI.handler(env, argv)\r\n      .then(stream => resolve(stream))\r\n      .catch(error => reject(error)));\r\n    });\r\n  }",
      "file": {
        "id": "E1_QbLZRx",
        "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
        "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
        "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\cli\\index.js",
        "source": "/* eslint-env node */\r\n'use strict';\r\n\r\nconst Extension = require('../utils/extension');\r\nconst File = require('fs-extra');\r\nconst Log = require('../utils/log');\r\nconst Liftoff = require('liftoff');\r\nconst Option = require('mr-doc-utils').Option;\r\nconst Path = require('path');\r\nconst Promise = require('bluebird');\r\nconst Yargs = require('yargs');\r\nconst ViynlFS = require('vinyl-fs');\r\nconst isGlob = require('is-glob');\r\nconst log = Log.global();\r\nconst pkg = require('../../package.json');\r\nconst rc = require('rc');\r\nconst _ = require('lodash');\r\n\r\nclass CLI {\r\n  /**\r\n   * Parse the CLI arguments.\r\n   * @static\r\n   */\r\n  static parse() {\r\n    return Yargs\r\n    .usage('Usage: mrdoc [options]', Option.cli())\r\n    .showHelpOnFail(false, 'Specify --help for available options')\r\n    .help('help', log.color.gray('Show help.'))\r\n    .alias('help', 'h')\r\n    .argv;\r\n  }\r\n  /**\r\n   * Create the CLI.\r\n   * @static\r\n   * @return {Liftoff} - An instance of Liftoff.\r\n   */\r\n  static get rocket() {\r\n    // Create the CLI.\r\n    return new Liftoff({\r\n      name: 'mrdoc',\r\n      processTitle: 'mrdoc',\r\n      v8flags: require('v8flags'),\r\n    });\r\n  }\r\n  /**\r\n   * Launch the cli.\r\n   * @static\r\n   * @param {Object} - The parsed CLI arguments.\r\n   * @return {Promise<Stream>} - A promise to the stream.\r\n   */\r\n  static launch(argv) {\r\n    return new Promise((resolve, reject) => {\r\n      // Launch the CLI!\r\n      CLI.rocket.launch({\r\n        cwd: argv.cwd,\r\n        configPath: argv.mrdocrc,\r\n      }, env => CLI.handler(env, argv)\r\n      .then(stream => resolve(stream))\r\n      .catch(error => reject(error)));\r\n    });\r\n  }\r\n  /**\r\n   * Handles the result from the CLI.\r\n   * @static\r\n   */\r\n  static handler(env, options) {\r\n    const version = options.version || options.v;\r\n    const source = options.source || options.s;\r\n    if (version) {\r\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\r\n      process.exit();\r\n    }\r\n    if (_.isEmpty(source) && version === false) {\r\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\r\n      process.exit();\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      // Get the options.\r\n      const opts = rc('mrdoc', Option.merge(options));\r\n      const sources = opts.mrdoc.source.split(',')\r\n      .map(path => path.trim())\r\n      .map(path => {\r\n        // Check if the path is not in glob pattern.\r\n        if (!isGlob(path)) {\r\n          // Make sure the path is resolved.\r\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\r\n          // Check if the path is a file or directory.\r\n          if (_.isEmpty(Path.parse(path).ext)) {\r\n            // Check if the path has a '/' at the end.\r\n            str = str[str.length - 1] === Path.sep ?\r\n            str : `${str}${Path.sep}`;\r\n          }\r\n          // Make sure the file or directory exists;\r\n          if (File.existsSync(str)) {\r\n            // Check if the directory has sub-directories.\r\n            const hasSubDirs = File.readdirSync(str)\r\n            .filter(file =>\r\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\r\n            // Get the file extension.\r\n            const extension = Extension.find(opts.parser.language);\r\n            // Set the glob pattern based on 'hasSubDirs'.\r\n            str = hasSubDirs ?\r\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\r\n          } else return null;\r\n          return str;\r\n        }\r\n        return path;\r\n      });\r\n      // DEBUG: Sources\r\n      log.debug(log.color.blue('Sources:'), sources);\r\n      if (sources.indexOf(null) > -1) {\r\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\r\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = CLI;\r\n",
        "ref": [
          {
            "E1_QbLZRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\cli\\index.js",
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\nconst Extension = require('../utils/extension');\r\nconst File = require('fs-extra');\r\nconst Log = require('../utils/log');\r\nconst Liftoff = require('liftoff');\r\nconst Option = require('mr-doc-utils').Option;\r\nconst Path = require('path');\r\nconst Promise = require('bluebird');\r\nconst Yargs = require('yargs');\r\nconst ViynlFS = require('vinyl-fs');\r\nconst isGlob = require('is-glob');\r\nconst log = Log.global();\r\nconst pkg = require('../../package.json');\r\nconst rc = require('rc');\r\nconst _ = require('lodash');\r\n\r\nclass CLI {\r\n  /**\r\n   * Parse the CLI arguments.\r\n   * @static\r\n   */\r\n  static parse() {\r\n    return Yargs\r\n    .usage('Usage: mrdoc [options]', Option.cli())\r\n    .showHelpOnFail(false, 'Specify --help for available options')\r\n    .help('help', log.color.gray('Show help.'))\r\n    .alias('help', 'h')\r\n    .argv;\r\n  }\r\n  /**\r\n   * Create the CLI.\r\n   * @static\r\n   * @return {Liftoff} - An instance of Liftoff.\r\n   */\r\n  static get rocket() {\r\n    // Create the CLI.\r\n    return new Liftoff({\r\n      name: 'mrdoc',\r\n      processTitle: 'mrdoc',\r\n      v8flags: require('v8flags'),\r\n    });\r\n  }\r\n  /**\r\n   * Launch the cli.\r\n   * @static\r\n   * @param {Object} - The parsed CLI arguments.\r\n   * @return {Promise<Stream>} - A promise to the stream.\r\n   */\r\n  static launch(argv) {\r\n    return new Promise((resolve, reject) => {\r\n      // Launch the CLI!\r\n      CLI.rocket.launch({\r\n        cwd: argv.cwd,\r\n        configPath: argv.mrdocrc,\r\n      }, env => CLI.handler(env, argv)\r\n      .then(stream => resolve(stream))\r\n      .catch(error => reject(error)));\r\n    });\r\n  }\r\n  /**\r\n   * Handles the result from the CLI.\r\n   * @static\r\n   */\r\n  static handler(env, options) {\r\n    const version = options.version || options.v;\r\n    const source = options.source || options.s;\r\n    if (version) {\r\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\r\n      process.exit();\r\n    }\r\n    if (_.isEmpty(source) && version === false) {\r\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\r\n      process.exit();\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      // Get the options.\r\n      const opts = rc('mrdoc', Option.merge(options));\r\n      const sources = opts.mrdoc.source.split(',')\r\n      .map(path => path.trim())\r\n      .map(path => {\r\n        // Check if the path is not in glob pattern.\r\n        if (!isGlob(path)) {\r\n          // Make sure the path is resolved.\r\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\r\n          // Check if the path is a file or directory.\r\n          if (_.isEmpty(Path.parse(path).ext)) {\r\n            // Check if the path has a '/' at the end.\r\n            str = str[str.length - 1] === Path.sep ?\r\n            str : `${str}${Path.sep}`;\r\n          }\r\n          // Make sure the file or directory exists;\r\n          if (File.existsSync(str)) {\r\n            // Check if the directory has sub-directories.\r\n            const hasSubDirs = File.readdirSync(str)\r\n            .filter(file =>\r\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\r\n            // Get the file extension.\r\n            const extension = Extension.find(opts.parser.language);\r\n            // Set the glob pattern based on 'hasSubDirs'.\r\n            str = hasSubDirs ?\r\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\r\n          } else return null;\r\n          return str;\r\n        }\r\n        return path;\r\n      });\r\n      // DEBUG: Sources\r\n      log.debug(log.color.blue('Sources:'), sources);\r\n      if (sources.indexOf(null) > -1) {\r\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\r\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = CLI;\r\n"
            }
          },
          {
            "EkedmbI-Rg": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\index.js",
              "source": "'use strict';\r\nconst JSONC = require('./compilers/json/');\r\n// const HTML = require('./compilers/html');\r\n\r\nclass Compiler {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.compiler().file.format) {\r\n      case 'json':\r\n        return (new JSONC(this.options));\r\n      case 'html':\r\n        // return (new HTML(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Compiler;\r\n"
            }
          },
          {
            "VJZdXZU-Ae": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\index.js",
              "source": "'use strict';\r\nconst JavaScript = require('./parsers/javascript/');\r\n\r\nclass Parser {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.parser().language) {\r\n      case 'js':\r\n      case 'javascript':\r\n        return (new JavaScript(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Parser;\r\n"
            }
          },
          {
            "VkzumbIW0x": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\extension.js",
              "source": "'use strict';\r\n\r\nclass Extension {\r\n  static find(language) {\r\n    return Extension.extensions()[language];\r\n  }\r\n  static extensions() {\r\n    return {\r\n      js: '.js',\r\n      javascript: '.js',\r\n      json: '.json',\r\n      html: '.html',\r\n      typescript: '.ts',\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = Extension;\r\n"
            }
          },
          {
            "EJ7uQ-L-Al": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\log.js",
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\n/* eslint-env node */\r\nconst Utils = require('mr-doc-utils');\r\nconst log = new Utils.Log();\r\nconst _ = require('lodash');\r\n\r\nclass Log {\r\n  constructor(options) {\r\n    if (options.silent) {\r\n      log.on('error', () => { /* NOOP */});\r\n      return log;\r\n    }\r\n    this.levels(options.level)\r\n    .forEach(level => {\r\n      if (level === 'error') this.error();\r\n      else this.other(level);\r\n    });\r\n    return log;\r\n  }\r\n  levels(level) {\r\n    const levels = _.isString(level) ? level.split(',') : level;\r\n    return levels\r\n    .map(i => i.replace(/\\s/g, ''));\r\n  }\r\n  error() {\r\n    log.on('error', function error() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args.map(i => log.color.red(i)));\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  other(level) {\r\n    log.on(level, function logger() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args);\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  /**\r\n   * Get the global instance of Log.\r\n   * @return {Log} - An instance of Log.\r\n   */\r\n  static global() {\r\n    log.color = Utils.Log.color;\r\n    return log;\r\n  }\r\n}\r\n\r\nmodule.exports = Log;\r\n"
            }
          },
          {
            "V1V_7WIWAg": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\output.js",
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nconst Option = require('mr-doc-utils').Option;\n\nclass Output {\n  static handler(options, buffer) {\n    const opt = (new Option(options)).options();\n    return function (callback) {\n      Output.format(opt, buffer).forEach(Output.toStream(opt, this));\n      callback();\n    };\n  }\n  static format(options, buffer) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler().file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n\n  static toStream(options, context) {\n    const format = options.compiler().file.format;\n    const file = options.compiler().file;\n    return function (f) {\n      if (format === 'json' || format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "EJSdQZI-Ce": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\source.js",
              "source": "'use strict';\r\nconst ShortID = require('shortid');\r\nconst File = require('fs-extra');\r\nconst _ = require('lodash');\r\n\r\nclass Source {\r\n  static create(files) {\r\n    // Process the files.\r\n    const result = files\r\n    .map(file => Source.processFile(file));\r\n    // Create references for each file.\r\n    const references = result\r\n    .map(file => Source.createReference(file));\r\n    // Process the references and attach it to each file.\r\n    return result\r\n    .map(file => Source.processReference(file, references));\r\n  }\r\n  static processFile(file) {\r\n    return {\r\n      id: ShortID.generate(),\r\n      cwd: file.cwd,\r\n      base: file.base,\r\n      path: file.path,\r\n      source: File.readFileSync(file.path, 'utf8'),\r\n      comments: undefined,\r\n    };\r\n  }\r\n  static createReference(file) {\r\n    return {\r\n      id: file.id,\r\n      cwd: file.cwd,\r\n      base: file.base,\r\n      path: file.path,\r\n      source: file.source,\r\n      comments: file.comments,\r\n    };\r\n  }\r\n  static processReference(file, references) {\r\n    return _.merge(file, {\r\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = Source;\r\n"
            }
          },
          {
            "VJU_QZUb0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\compilers\\interface.js",
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.compiler() : options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "VyPuX-LbCx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\engines\\javascript.engine.js",
              "source": "'use strict';\r\n\r\nconst Babylon = require('babylon');\r\nconst Acorn = require('acorn');\r\nconst Espree = require('espree');\r\nconst ESCodeGen = require('escodegen');\r\nconst ESTraverse = require('estraverse');\r\nconst traverse = require('babel-traverse').default;\r\n\r\nconst opts = {\r\n  acorn: (version, comments, tokens) => ({\r\n    ecmaVersion: version,\r\n    locations: true,\r\n    onComment: comments,\r\n    onToken: tokens,\r\n    ranges: true,\r\n  }),\r\n  babylon: () => ({\r\n    allowImportExportEverywhere: true,\r\n    plugins: [\r\n      'jsx',\r\n      'flow',\r\n      'asyncFunctions',\r\n      'classConstructorCall',\r\n      'doExpressions',\r\n      'trailingFunctionCommas',\r\n      'objectRestSpread',\r\n      'decorators',\r\n      'classProperties',\r\n      'exportExtensions',\r\n      'exponentiationOperator',\r\n      'asyncGenerators',\r\n      'functionBind',\r\n      'functionSent',\r\n    ],\r\n    sourceType: 'module',\r\n  }),\r\n  espree: (version) => ({\r\n    attachComment: true,\r\n    comment: true,\r\n    ecmaFeatures: {\r\n      experimentalObjectRestSpread: true,\r\n      globalReturn: true,\r\n      impliedStrict: true,\r\n      jsx: true,\r\n    },\r\n    ecmaVersion: version,\r\n    loc: true,\r\n    range: true,\r\n    sourceType: 'module',\r\n    tokens: true,\r\n  }),\r\n};\r\n\r\nclass Engine {\r\n  constructor(options) {\r\n    this.options = options;\r\n    switch (this.options.engine) {\r\n      case 'acorn':\r\n        this.engine = Acorn;\r\n        break;\r\n      case 'espree':\r\n        this.engine = Espree;\r\n        break;\r\n      default:\r\n        this.engine = Babylon;\r\n        break;\r\n    }\r\n  }\r\n  parse(file) {\r\n    const comments = [];\r\n    const tokens = [];\r\n    try {\r\n      switch (this.options.engine) {\r\n        case 'acorn':\r\n          return ESCodeGen\r\n          .attachComments(this.engine.parse(file.source,\r\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\r\n        case 'espree':\r\n          return this.engine.parse(file.source, opts.espree(this.options.version));\r\n        default:\r\n          return this.engine.parse(file.source, opts.babylon());\r\n      }\r\n    } catch (error) {\r\n      throw (new Error(error));\r\n    }\r\n  }\r\n  static traverse(options, ast, callback) {\r\n    switch (options.engine) {\r\n      case 'babylon':\r\n        traverse(ast, {\r\n          enter: (path) => {\r\n            const node = path.node;\r\n            callback(node);\r\n          } });\r\n        break;\r\n      default:\r\n        ESTraverse.traverse(ast, {\r\n          /* eslint-disable no-param-reassign */\r\n          enter: (node) => {\r\n            if (node.type === 'Program') {\r\n              node = node.body[0];\r\n            }\r\n            callback(node);\r\n          } });\r\n          /* eslint-enable no-param-reassign */\r\n        break;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Engine;\r\n"
            }
          },
          {
            "EyudQbUb0e": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\interface.js",
              "source": "'use strict';\r\nclass IParser {\r\n  /**\r\n   * @constructor\r\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\r\n   */\r\n  constructor(options) {\r\n    this.options = options.parser ? options.parser() : options;\r\n  }\r\n  /**\r\n   * Parses the sources' comments into the desired output.\r\n   * @param  {Array<Object>} results - The files to parse.\r\n   * @return {Array<Object>} - The parsed comments.\r\n   */\r\n  /* eslint-disable no-unused-vars */\r\n  parse(sources) {\r\n    // ...\r\n  }\r\n  /* eslint-enable no-unused-vars */\r\n}\r\n\r\nmodule.exports = IParser;\r\n"
            }
          },
          {
            "4JF_XW8Z0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\compilers\\json\\index.js",
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "4yc_7bIZ0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\javascript\\index.js",
              "source": "'use strict';\r\n\r\nconst Doctrine = require('doctrine');\r\nconst IParser = require('../interface');\r\nconst Engine = require('../../engines/javascript.engine.js');\r\nconst _ = require('lodash');\r\nconst Log = require('mr-doc-utils').Log;\r\nconst log = new Log();\r\nconst synonyms = require('./synonyms.js');\r\n\r\nclass JavaScript extends IParser {\r\n  constructor(options) {\r\n    super(options);\r\n    this.visited = {};\r\n    this.engine = new Engine(this.options);\r\n    this.comments = [];\r\n    this.results = [];\r\n  }\r\n  /**\r\n   * Parse the file.\r\n   * @param {Object} - The file to parse.\r\n   */\r\n  parse(file) {\r\n    this.file = file;\r\n    this.ast = this.engine.parse(this.file);\r\n    // DEBUG: AST\r\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\r\n    [\r\n      { type: 'leadingComments', context: true },\r\n      { type: 'innerComments', context: false },\r\n      { type: 'trailingComments', context: false },\r\n    ].forEach(comment => this.walkComments(comment));\r\n    return this.results;\r\n  }\r\n  /**\r\n   * Walk the comments.\r\n   * @param {Object} - The comment type and context to walk.\r\n   */\r\n  walkComments(comment) {\r\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\r\n        .filter(this.isJSDocComment)\r\n        .forEach(this.parseComment(node, comment.context)));\r\n  }\r\n  /**\r\n   * Parse the comment.\r\n   * @param {Node} - The current node.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseComment(node, includeContext) {\r\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\r\n    range = !range ? node.range : range;\r\n    range = !range ? [node.start, node.end] : range;\r\n    const context = {\r\n      code: null,\r\n      file: this.file,\r\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\r\n      range: {\r\n        column: [node.loc.start.column, node.loc.end.column],\r\n        line: [node.loc.start.line, node.loc.end.line],\r\n      },\r\n    };\r\n    return (comment) => {\r\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\r\n      if (!this.visited[key]) {\r\n        this.visited[key] = true;\r\n        if (includeContext) {\r\n          Object.defineProperty(context, 'ast', {\r\n            enumerable: false,\r\n            value: node,\r\n          });\r\n          context.code = this.file.source.substring.apply(this.file.source, range);\r\n        }\r\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\r\n      }\r\n    };\r\n  }\r\n  /**\r\n   * Parse the JSDoc comment.\r\n   * @param {String} - The comment to parse.\r\n   * @param {Location} - The comment location.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseJSDoc(comment, loc, context) {\r\n    const result = Doctrine.parse(comment, {\r\n      lineNumbers: true,\r\n      recoverable: true,\r\n      sloppy: true,\r\n      unwrap: true,\r\n    });\r\n    result.loc = loc;\r\n    result.context = context;\r\n    result.errors = [];\r\n    let i = 0;\r\n    while (i < result.tags.length) {\r\n      const tag = result.tags[i];\r\n      if (tag.errors) {\r\n        for (let j = 0; j < tag.errors.length; j++) {\r\n          result.errors.push({ message: tag.errors[j] });\r\n        }\r\n        result.tags.splice(i, 1);\r\n      } else i++;\r\n    }\r\n    return JavaScript.normalize(result);\r\n  }\r\n  /**\r\n   * Determine whether the comment is normalized.\r\n   * @param {String} - The comment to determine.\r\n   * @return {Boolean} - The truth value.\r\n   */\r\n  isJSDocComment(comment) {\r\n    const asterisks = comment.value.match(/^(\\*+)/);\r\n    return (comment.type === 'CommentBlock' ||\r\n      comment.type === 'Block')\r\n      && asterisks && asterisks[1].length === 1;\r\n  }\r\n  /**\r\n   * Normalize the comment tags.\r\n   * @param {Array} - The comment to normalize.\r\n   * @return {Array} - The comment containing normalized tags.\r\n   */\r\n  static normalize(comment) {\r\n    return _.assignIn({}, comment, {\r\n      tags: comment.tags.map(tag => {\r\n        let title = tag.title.toLowerCase();\r\n        const canonical = synonyms[title];\r\n        if (!canonical) {\r\n          switch (title[0]) {\r\n            case 'e':\r\n              if (title === 'extend') title = 'extends';\r\n              break;\r\n            case 'j':\r\n              if (title === 'jsfiddles') title = 'jsfiddle';\r\n              break;\r\n            default: break;\r\n          }\r\n        }\r\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\r\n      }),\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = JavaScript;\r\n"
            }
          },
          {
            "VkjOmWLbAl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\javascript\\synonyms.js",
              "source": "module.exports = {\r\n  arg: 'param',\r\n  argument: 'param',\r\n  constructor: 'class',\r\n  const: 'constant',\r\n  defaultvalue: 'default',\r\n  desc: 'description',\r\n  emits: 'fires',\r\n  exception: 'throws',\r\n  fileoverview: 'file',\r\n  func: 'function',\r\n  host: 'external',\r\n  linkcode: 'link',\r\n  linkplain: 'link',\r\n  virtual: 'abstract',\r\n  method: 'function',\r\n  overview: 'file',\r\n  prop: 'property',\r\n  return: 'returns',\r\n  var: 'member',\r\n};\r\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 51,
          "column": 2
        },
        "end": {
          "line": 61,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          51,
          61
        ]
      }
    }
  },
  {
    "description": "Handles the result from the CLI.",
    "tags": [
      {
        "title": "static",
        "description": null,
        "lineNumber": 2
      }
    ],
    "loc": {
      "start": {
        "line": 62,
        "column": 2
      },
      "end": {
        "line": 65,
        "column": 5
      }
    },
    "context": {
      "code": "static handler(env, options) {\r\n    const version = options.version || options.v;\r\n    const source = options.source || options.s;\r\n    if (version) {\r\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\r\n      process.exit();\r\n    }\r\n    if (_.isEmpty(source) && version === false) {\r\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\r\n      process.exit();\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      // Get the options.\r\n      const opts = rc('mrdoc', Option.merge(options));\r\n      const sources = opts.mrdoc.source.split(',')\r\n      .map(path => path.trim())\r\n      .map(path => {\r\n        // Check if the path is not in glob pattern.\r\n        if (!isGlob(path)) {\r\n          // Make sure the path is resolved.\r\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\r\n          // Check if the path is a file or directory.\r\n          if (_.isEmpty(Path.parse(path).ext)) {\r\n            // Check if the path has a '/' at the end.\r\n            str = str[str.length - 1] === Path.sep ?\r\n            str : `${str}${Path.sep}`;\r\n          }\r\n          // Make sure the file or directory exists;\r\n          if (File.existsSync(str)) {\r\n            // Check if the directory has sub-directories.\r\n            const hasSubDirs = File.readdirSync(str)\r\n            .filter(file =>\r\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\r\n            // Get the file extension.\r\n            const extension = Extension.find(opts.parser.language);\r\n            // Set the glob pattern based on 'hasSubDirs'.\r\n            str = hasSubDirs ?\r\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\r\n          } else return null;\r\n          return str;\r\n        }\r\n        return path;\r\n      });\r\n      // DEBUG: Sources\r\n      log.debug(log.color.blue('Sources:'), sources);\r\n      if (sources.indexOf(null) > -1) {\r\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\r\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\r\n    });\r\n  }",
      "file": {
        "id": "E1_QbLZRx",
        "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
        "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
        "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\cli\\index.js",
        "source": "/* eslint-env node */\r\n'use strict';\r\n\r\nconst Extension = require('../utils/extension');\r\nconst File = require('fs-extra');\r\nconst Log = require('../utils/log');\r\nconst Liftoff = require('liftoff');\r\nconst Option = require('mr-doc-utils').Option;\r\nconst Path = require('path');\r\nconst Promise = require('bluebird');\r\nconst Yargs = require('yargs');\r\nconst ViynlFS = require('vinyl-fs');\r\nconst isGlob = require('is-glob');\r\nconst log = Log.global();\r\nconst pkg = require('../../package.json');\r\nconst rc = require('rc');\r\nconst _ = require('lodash');\r\n\r\nclass CLI {\r\n  /**\r\n   * Parse the CLI arguments.\r\n   * @static\r\n   */\r\n  static parse() {\r\n    return Yargs\r\n    .usage('Usage: mrdoc [options]', Option.cli())\r\n    .showHelpOnFail(false, 'Specify --help for available options')\r\n    .help('help', log.color.gray('Show help.'))\r\n    .alias('help', 'h')\r\n    .argv;\r\n  }\r\n  /**\r\n   * Create the CLI.\r\n   * @static\r\n   * @return {Liftoff} - An instance of Liftoff.\r\n   */\r\n  static get rocket() {\r\n    // Create the CLI.\r\n    return new Liftoff({\r\n      name: 'mrdoc',\r\n      processTitle: 'mrdoc',\r\n      v8flags: require('v8flags'),\r\n    });\r\n  }\r\n  /**\r\n   * Launch the cli.\r\n   * @static\r\n   * @param {Object} - The parsed CLI arguments.\r\n   * @return {Promise<Stream>} - A promise to the stream.\r\n   */\r\n  static launch(argv) {\r\n    return new Promise((resolve, reject) => {\r\n      // Launch the CLI!\r\n      CLI.rocket.launch({\r\n        cwd: argv.cwd,\r\n        configPath: argv.mrdocrc,\r\n      }, env => CLI.handler(env, argv)\r\n      .then(stream => resolve(stream))\r\n      .catch(error => reject(error)));\r\n    });\r\n  }\r\n  /**\r\n   * Handles the result from the CLI.\r\n   * @static\r\n   */\r\n  static handler(env, options) {\r\n    const version = options.version || options.v;\r\n    const source = options.source || options.s;\r\n    if (version) {\r\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\r\n      process.exit();\r\n    }\r\n    if (_.isEmpty(source) && version === false) {\r\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\r\n      process.exit();\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      // Get the options.\r\n      const opts = rc('mrdoc', Option.merge(options));\r\n      const sources = opts.mrdoc.source.split(',')\r\n      .map(path => path.trim())\r\n      .map(path => {\r\n        // Check if the path is not in glob pattern.\r\n        if (!isGlob(path)) {\r\n          // Make sure the path is resolved.\r\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\r\n          // Check if the path is a file or directory.\r\n          if (_.isEmpty(Path.parse(path).ext)) {\r\n            // Check if the path has a '/' at the end.\r\n            str = str[str.length - 1] === Path.sep ?\r\n            str : `${str}${Path.sep}`;\r\n          }\r\n          // Make sure the file or directory exists;\r\n          if (File.existsSync(str)) {\r\n            // Check if the directory has sub-directories.\r\n            const hasSubDirs = File.readdirSync(str)\r\n            .filter(file =>\r\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\r\n            // Get the file extension.\r\n            const extension = Extension.find(opts.parser.language);\r\n            // Set the glob pattern based on 'hasSubDirs'.\r\n            str = hasSubDirs ?\r\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\r\n          } else return null;\r\n          return str;\r\n        }\r\n        return path;\r\n      });\r\n      // DEBUG: Sources\r\n      log.debug(log.color.blue('Sources:'), sources);\r\n      if (sources.indexOf(null) > -1) {\r\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\r\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = CLI;\r\n",
        "ref": [
          {
            "E1_QbLZRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\cli\\index.js",
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\nconst Extension = require('../utils/extension');\r\nconst File = require('fs-extra');\r\nconst Log = require('../utils/log');\r\nconst Liftoff = require('liftoff');\r\nconst Option = require('mr-doc-utils').Option;\r\nconst Path = require('path');\r\nconst Promise = require('bluebird');\r\nconst Yargs = require('yargs');\r\nconst ViynlFS = require('vinyl-fs');\r\nconst isGlob = require('is-glob');\r\nconst log = Log.global();\r\nconst pkg = require('../../package.json');\r\nconst rc = require('rc');\r\nconst _ = require('lodash');\r\n\r\nclass CLI {\r\n  /**\r\n   * Parse the CLI arguments.\r\n   * @static\r\n   */\r\n  static parse() {\r\n    return Yargs\r\n    .usage('Usage: mrdoc [options]', Option.cli())\r\n    .showHelpOnFail(false, 'Specify --help for available options')\r\n    .help('help', log.color.gray('Show help.'))\r\n    .alias('help', 'h')\r\n    .argv;\r\n  }\r\n  /**\r\n   * Create the CLI.\r\n   * @static\r\n   * @return {Liftoff} - An instance of Liftoff.\r\n   */\r\n  static get rocket() {\r\n    // Create the CLI.\r\n    return new Liftoff({\r\n      name: 'mrdoc',\r\n      processTitle: 'mrdoc',\r\n      v8flags: require('v8flags'),\r\n    });\r\n  }\r\n  /**\r\n   * Launch the cli.\r\n   * @static\r\n   * @param {Object} - The parsed CLI arguments.\r\n   * @return {Promise<Stream>} - A promise to the stream.\r\n   */\r\n  static launch(argv) {\r\n    return new Promise((resolve, reject) => {\r\n      // Launch the CLI!\r\n      CLI.rocket.launch({\r\n        cwd: argv.cwd,\r\n        configPath: argv.mrdocrc,\r\n      }, env => CLI.handler(env, argv)\r\n      .then(stream => resolve(stream))\r\n      .catch(error => reject(error)));\r\n    });\r\n  }\r\n  /**\r\n   * Handles the result from the CLI.\r\n   * @static\r\n   */\r\n  static handler(env, options) {\r\n    const version = options.version || options.v;\r\n    const source = options.source || options.s;\r\n    if (version) {\r\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\r\n      process.exit();\r\n    }\r\n    if (_.isEmpty(source) && version === false) {\r\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\r\n      process.exit();\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      // Get the options.\r\n      const opts = rc('mrdoc', Option.merge(options));\r\n      const sources = opts.mrdoc.source.split(',')\r\n      .map(path => path.trim())\r\n      .map(path => {\r\n        // Check if the path is not in glob pattern.\r\n        if (!isGlob(path)) {\r\n          // Make sure the path is resolved.\r\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\r\n          // Check if the path is a file or directory.\r\n          if (_.isEmpty(Path.parse(path).ext)) {\r\n            // Check if the path has a '/' at the end.\r\n            str = str[str.length - 1] === Path.sep ?\r\n            str : `${str}${Path.sep}`;\r\n          }\r\n          // Make sure the file or directory exists;\r\n          if (File.existsSync(str)) {\r\n            // Check if the directory has sub-directories.\r\n            const hasSubDirs = File.readdirSync(str)\r\n            .filter(file =>\r\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\r\n            // Get the file extension.\r\n            const extension = Extension.find(opts.parser.language);\r\n            // Set the glob pattern based on 'hasSubDirs'.\r\n            str = hasSubDirs ?\r\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\r\n          } else return null;\r\n          return str;\r\n        }\r\n        return path;\r\n      });\r\n      // DEBUG: Sources\r\n      log.debug(log.color.blue('Sources:'), sources);\r\n      if (sources.indexOf(null) > -1) {\r\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\r\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = CLI;\r\n"
            }
          },
          {
            "EkedmbI-Rg": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\index.js",
              "source": "'use strict';\r\nconst JSONC = require('./compilers/json/');\r\n// const HTML = require('./compilers/html');\r\n\r\nclass Compiler {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.compiler().file.format) {\r\n      case 'json':\r\n        return (new JSONC(this.options));\r\n      case 'html':\r\n        // return (new HTML(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Compiler;\r\n"
            }
          },
          {
            "VJZdXZU-Ae": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\index.js",
              "source": "'use strict';\r\nconst JavaScript = require('./parsers/javascript/');\r\n\r\nclass Parser {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.parser().language) {\r\n      case 'js':\r\n      case 'javascript':\r\n        return (new JavaScript(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Parser;\r\n"
            }
          },
          {
            "VkzumbIW0x": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\extension.js",
              "source": "'use strict';\r\n\r\nclass Extension {\r\n  static find(language) {\r\n    return Extension.extensions()[language];\r\n  }\r\n  static extensions() {\r\n    return {\r\n      js: '.js',\r\n      javascript: '.js',\r\n      json: '.json',\r\n      html: '.html',\r\n      typescript: '.ts',\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = Extension;\r\n"
            }
          },
          {
            "EJ7uQ-L-Al": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\log.js",
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\n/* eslint-env node */\r\nconst Utils = require('mr-doc-utils');\r\nconst log = new Utils.Log();\r\nconst _ = require('lodash');\r\n\r\nclass Log {\r\n  constructor(options) {\r\n    if (options.silent) {\r\n      log.on('error', () => { /* NOOP */});\r\n      return log;\r\n    }\r\n    this.levels(options.level)\r\n    .forEach(level => {\r\n      if (level === 'error') this.error();\r\n      else this.other(level);\r\n    });\r\n    return log;\r\n  }\r\n  levels(level) {\r\n    const levels = _.isString(level) ? level.split(',') : level;\r\n    return levels\r\n    .map(i => i.replace(/\\s/g, ''));\r\n  }\r\n  error() {\r\n    log.on('error', function error() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args.map(i => log.color.red(i)));\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  other(level) {\r\n    log.on(level, function logger() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args);\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  /**\r\n   * Get the global instance of Log.\r\n   * @return {Log} - An instance of Log.\r\n   */\r\n  static global() {\r\n    log.color = Utils.Log.color;\r\n    return log;\r\n  }\r\n}\r\n\r\nmodule.exports = Log;\r\n"
            }
          },
          {
            "V1V_7WIWAg": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\output.js",
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nconst Option = require('mr-doc-utils').Option;\n\nclass Output {\n  static handler(options, buffer) {\n    const opt = (new Option(options)).options();\n    return function (callback) {\n      Output.format(opt, buffer).forEach(Output.toStream(opt, this));\n      callback();\n    };\n  }\n  static format(options, buffer) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler().file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n\n  static toStream(options, context) {\n    const format = options.compiler().file.format;\n    const file = options.compiler().file;\n    return function (f) {\n      if (format === 'json' || format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "EJSdQZI-Ce": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\source.js",
              "source": "'use strict';\r\nconst ShortID = require('shortid');\r\nconst File = require('fs-extra');\r\nconst _ = require('lodash');\r\n\r\nclass Source {\r\n  static create(files) {\r\n    // Process the files.\r\n    const result = files\r\n    .map(file => Source.processFile(file));\r\n    // Create references for each file.\r\n    const references = result\r\n    .map(file => Source.createReference(file));\r\n    // Process the references and attach it to each file.\r\n    return result\r\n    .map(file => Source.processReference(file, references));\r\n  }\r\n  static processFile(file) {\r\n    return {\r\n      id: ShortID.generate(),\r\n      cwd: file.cwd,\r\n      base: file.base,\r\n      path: file.path,\r\n      source: File.readFileSync(file.path, 'utf8'),\r\n      comments: undefined,\r\n    };\r\n  }\r\n  static createReference(file) {\r\n    return {\r\n      id: file.id,\r\n      cwd: file.cwd,\r\n      base: file.base,\r\n      path: file.path,\r\n      source: file.source,\r\n      comments: file.comments,\r\n    };\r\n  }\r\n  static processReference(file, references) {\r\n    return _.merge(file, {\r\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = Source;\r\n"
            }
          },
          {
            "VJU_QZUb0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\compilers\\interface.js",
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.compiler() : options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "VyPuX-LbCx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\engines\\javascript.engine.js",
              "source": "'use strict';\r\n\r\nconst Babylon = require('babylon');\r\nconst Acorn = require('acorn');\r\nconst Espree = require('espree');\r\nconst ESCodeGen = require('escodegen');\r\nconst ESTraverse = require('estraverse');\r\nconst traverse = require('babel-traverse').default;\r\n\r\nconst opts = {\r\n  acorn: (version, comments, tokens) => ({\r\n    ecmaVersion: version,\r\n    locations: true,\r\n    onComment: comments,\r\n    onToken: tokens,\r\n    ranges: true,\r\n  }),\r\n  babylon: () => ({\r\n    allowImportExportEverywhere: true,\r\n    plugins: [\r\n      'jsx',\r\n      'flow',\r\n      'asyncFunctions',\r\n      'classConstructorCall',\r\n      'doExpressions',\r\n      'trailingFunctionCommas',\r\n      'objectRestSpread',\r\n      'decorators',\r\n      'classProperties',\r\n      'exportExtensions',\r\n      'exponentiationOperator',\r\n      'asyncGenerators',\r\n      'functionBind',\r\n      'functionSent',\r\n    ],\r\n    sourceType: 'module',\r\n  }),\r\n  espree: (version) => ({\r\n    attachComment: true,\r\n    comment: true,\r\n    ecmaFeatures: {\r\n      experimentalObjectRestSpread: true,\r\n      globalReturn: true,\r\n      impliedStrict: true,\r\n      jsx: true,\r\n    },\r\n    ecmaVersion: version,\r\n    loc: true,\r\n    range: true,\r\n    sourceType: 'module',\r\n    tokens: true,\r\n  }),\r\n};\r\n\r\nclass Engine {\r\n  constructor(options) {\r\n    this.options = options;\r\n    switch (this.options.engine) {\r\n      case 'acorn':\r\n        this.engine = Acorn;\r\n        break;\r\n      case 'espree':\r\n        this.engine = Espree;\r\n        break;\r\n      default:\r\n        this.engine = Babylon;\r\n        break;\r\n    }\r\n  }\r\n  parse(file) {\r\n    const comments = [];\r\n    const tokens = [];\r\n    try {\r\n      switch (this.options.engine) {\r\n        case 'acorn':\r\n          return ESCodeGen\r\n          .attachComments(this.engine.parse(file.source,\r\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\r\n        case 'espree':\r\n          return this.engine.parse(file.source, opts.espree(this.options.version));\r\n        default:\r\n          return this.engine.parse(file.source, opts.babylon());\r\n      }\r\n    } catch (error) {\r\n      throw (new Error(error));\r\n    }\r\n  }\r\n  static traverse(options, ast, callback) {\r\n    switch (options.engine) {\r\n      case 'babylon':\r\n        traverse(ast, {\r\n          enter: (path) => {\r\n            const node = path.node;\r\n            callback(node);\r\n          } });\r\n        break;\r\n      default:\r\n        ESTraverse.traverse(ast, {\r\n          /* eslint-disable no-param-reassign */\r\n          enter: (node) => {\r\n            if (node.type === 'Program') {\r\n              node = node.body[0];\r\n            }\r\n            callback(node);\r\n          } });\r\n          /* eslint-enable no-param-reassign */\r\n        break;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Engine;\r\n"
            }
          },
          {
            "EyudQbUb0e": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\interface.js",
              "source": "'use strict';\r\nclass IParser {\r\n  /**\r\n   * @constructor\r\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\r\n   */\r\n  constructor(options) {\r\n    this.options = options.parser ? options.parser() : options;\r\n  }\r\n  /**\r\n   * Parses the sources' comments into the desired output.\r\n   * @param  {Array<Object>} results - The files to parse.\r\n   * @return {Array<Object>} - The parsed comments.\r\n   */\r\n  /* eslint-disable no-unused-vars */\r\n  parse(sources) {\r\n    // ...\r\n  }\r\n  /* eslint-enable no-unused-vars */\r\n}\r\n\r\nmodule.exports = IParser;\r\n"
            }
          },
          {
            "4JF_XW8Z0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\compilers\\json\\index.js",
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "4yc_7bIZ0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\javascript\\index.js",
              "source": "'use strict';\r\n\r\nconst Doctrine = require('doctrine');\r\nconst IParser = require('../interface');\r\nconst Engine = require('../../engines/javascript.engine.js');\r\nconst _ = require('lodash');\r\nconst Log = require('mr-doc-utils').Log;\r\nconst log = new Log();\r\nconst synonyms = require('./synonyms.js');\r\n\r\nclass JavaScript extends IParser {\r\n  constructor(options) {\r\n    super(options);\r\n    this.visited = {};\r\n    this.engine = new Engine(this.options);\r\n    this.comments = [];\r\n    this.results = [];\r\n  }\r\n  /**\r\n   * Parse the file.\r\n   * @param {Object} - The file to parse.\r\n   */\r\n  parse(file) {\r\n    this.file = file;\r\n    this.ast = this.engine.parse(this.file);\r\n    // DEBUG: AST\r\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\r\n    [\r\n      { type: 'leadingComments', context: true },\r\n      { type: 'innerComments', context: false },\r\n      { type: 'trailingComments', context: false },\r\n    ].forEach(comment => this.walkComments(comment));\r\n    return this.results;\r\n  }\r\n  /**\r\n   * Walk the comments.\r\n   * @param {Object} - The comment type and context to walk.\r\n   */\r\n  walkComments(comment) {\r\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\r\n        .filter(this.isJSDocComment)\r\n        .forEach(this.parseComment(node, comment.context)));\r\n  }\r\n  /**\r\n   * Parse the comment.\r\n   * @param {Node} - The current node.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseComment(node, includeContext) {\r\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\r\n    range = !range ? node.range : range;\r\n    range = !range ? [node.start, node.end] : range;\r\n    const context = {\r\n      code: null,\r\n      file: this.file,\r\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\r\n      range: {\r\n        column: [node.loc.start.column, node.loc.end.column],\r\n        line: [node.loc.start.line, node.loc.end.line],\r\n      },\r\n    };\r\n    return (comment) => {\r\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\r\n      if (!this.visited[key]) {\r\n        this.visited[key] = true;\r\n        if (includeContext) {\r\n          Object.defineProperty(context, 'ast', {\r\n            enumerable: false,\r\n            value: node,\r\n          });\r\n          context.code = this.file.source.substring.apply(this.file.source, range);\r\n        }\r\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\r\n      }\r\n    };\r\n  }\r\n  /**\r\n   * Parse the JSDoc comment.\r\n   * @param {String} - The comment to parse.\r\n   * @param {Location} - The comment location.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseJSDoc(comment, loc, context) {\r\n    const result = Doctrine.parse(comment, {\r\n      lineNumbers: true,\r\n      recoverable: true,\r\n      sloppy: true,\r\n      unwrap: true,\r\n    });\r\n    result.loc = loc;\r\n    result.context = context;\r\n    result.errors = [];\r\n    let i = 0;\r\n    while (i < result.tags.length) {\r\n      const tag = result.tags[i];\r\n      if (tag.errors) {\r\n        for (let j = 0; j < tag.errors.length; j++) {\r\n          result.errors.push({ message: tag.errors[j] });\r\n        }\r\n        result.tags.splice(i, 1);\r\n      } else i++;\r\n    }\r\n    return JavaScript.normalize(result);\r\n  }\r\n  /**\r\n   * Determine whether the comment is normalized.\r\n   * @param {String} - The comment to determine.\r\n   * @return {Boolean} - The truth value.\r\n   */\r\n  isJSDocComment(comment) {\r\n    const asterisks = comment.value.match(/^(\\*+)/);\r\n    return (comment.type === 'CommentBlock' ||\r\n      comment.type === 'Block')\r\n      && asterisks && asterisks[1].length === 1;\r\n  }\r\n  /**\r\n   * Normalize the comment tags.\r\n   * @param {Array} - The comment to normalize.\r\n   * @return {Array} - The comment containing normalized tags.\r\n   */\r\n  static normalize(comment) {\r\n    return _.assignIn({}, comment, {\r\n      tags: comment.tags.map(tag => {\r\n        let title = tag.title.toLowerCase();\r\n        const canonical = synonyms[title];\r\n        if (!canonical) {\r\n          switch (title[0]) {\r\n            case 'e':\r\n              if (title === 'extend') title = 'extends';\r\n              break;\r\n            case 'j':\r\n              if (title === 'jsfiddles') title = 'jsfiddle';\r\n              break;\r\n            default: break;\r\n          }\r\n        }\r\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\r\n      }),\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = JavaScript;\r\n"
            }
          },
          {
            "VkjOmWLbAl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\javascript\\synonyms.js",
              "source": "module.exports = {\r\n  arg: 'param',\r\n  argument: 'param',\r\n  constructor: 'class',\r\n  const: 'constant',\r\n  defaultvalue: 'default',\r\n  desc: 'description',\r\n  emits: 'fires',\r\n  exception: 'throws',\r\n  fileoverview: 'file',\r\n  func: 'function',\r\n  host: 'external',\r\n  linkcode: 'link',\r\n  linkplain: 'link',\r\n  virtual: 'abstract',\r\n  method: 'function',\r\n  overview: 'file',\r\n  prop: 'property',\r\n  return: 'returns',\r\n  var: 'member',\r\n};\r\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 66,
          "column": 2
        },
        "end": {
          "line": 115,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          66,
          115
        ]
      }
    }
  },
  {
    "description": "Get the global instance of Log.",
    "tags": [
      {
        "title": "returns",
        "description": "An instance of Log.",
        "lineNumber": 2,
        "type": {
          "type": "NameExpression",
          "name": "Log"
        }
      }
    ],
    "loc": {
      "start": {
        "line": 45,
        "column": 2
      },
      "end": {
        "line": 48,
        "column": 5
      }
    },
    "context": {
      "code": "static global() {\r\n    log.color = Utils.Log.color;\r\n    return log;\r\n  }",
      "file": {
        "id": "EJ7uQ-L-Al",
        "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
        "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
        "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\log.js",
        "source": "/* eslint-env node */\r\n'use strict';\r\n\r\n/* eslint-env node */\r\nconst Utils = require('mr-doc-utils');\r\nconst log = new Utils.Log();\r\nconst _ = require('lodash');\r\n\r\nclass Log {\r\n  constructor(options) {\r\n    if (options.silent) {\r\n      log.on('error', () => { /* NOOP */});\r\n      return log;\r\n    }\r\n    this.levels(options.level)\r\n    .forEach(level => {\r\n      if (level === 'error') this.error();\r\n      else this.other(level);\r\n    });\r\n    return log;\r\n  }\r\n  levels(level) {\r\n    const levels = _.isString(level) ? level.split(',') : level;\r\n    return levels\r\n    .map(i => i.replace(/\\s/g, ''));\r\n  }\r\n  error() {\r\n    log.on('error', function error() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args.map(i => log.color.red(i)));\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  other(level) {\r\n    log.on(level, function logger() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args);\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  /**\r\n   * Get the global instance of Log.\r\n   * @return {Log} - An instance of Log.\r\n   */\r\n  static global() {\r\n    log.color = Utils.Log.color;\r\n    return log;\r\n  }\r\n}\r\n\r\nmodule.exports = Log;\r\n",
        "ref": [
          {
            "E1_QbLZRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\cli\\index.js",
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\nconst Extension = require('../utils/extension');\r\nconst File = require('fs-extra');\r\nconst Log = require('../utils/log');\r\nconst Liftoff = require('liftoff');\r\nconst Option = require('mr-doc-utils').Option;\r\nconst Path = require('path');\r\nconst Promise = require('bluebird');\r\nconst Yargs = require('yargs');\r\nconst ViynlFS = require('vinyl-fs');\r\nconst isGlob = require('is-glob');\r\nconst log = Log.global();\r\nconst pkg = require('../../package.json');\r\nconst rc = require('rc');\r\nconst _ = require('lodash');\r\n\r\nclass CLI {\r\n  /**\r\n   * Parse the CLI arguments.\r\n   * @static\r\n   */\r\n  static parse() {\r\n    return Yargs\r\n    .usage('Usage: mrdoc [options]', Option.cli())\r\n    .showHelpOnFail(false, 'Specify --help for available options')\r\n    .help('help', log.color.gray('Show help.'))\r\n    .alias('help', 'h')\r\n    .argv;\r\n  }\r\n  /**\r\n   * Create the CLI.\r\n   * @static\r\n   * @return {Liftoff} - An instance of Liftoff.\r\n   */\r\n  static get rocket() {\r\n    // Create the CLI.\r\n    return new Liftoff({\r\n      name: 'mrdoc',\r\n      processTitle: 'mrdoc',\r\n      v8flags: require('v8flags'),\r\n    });\r\n  }\r\n  /**\r\n   * Launch the cli.\r\n   * @static\r\n   * @param {Object} - The parsed CLI arguments.\r\n   * @return {Promise<Stream>} - A promise to the stream.\r\n   */\r\n  static launch(argv) {\r\n    return new Promise((resolve, reject) => {\r\n      // Launch the CLI!\r\n      CLI.rocket.launch({\r\n        cwd: argv.cwd,\r\n        configPath: argv.mrdocrc,\r\n      }, env => CLI.handler(env, argv)\r\n      .then(stream => resolve(stream))\r\n      .catch(error => reject(error)));\r\n    });\r\n  }\r\n  /**\r\n   * Handles the result from the CLI.\r\n   * @static\r\n   */\r\n  static handler(env, options) {\r\n    const version = options.version || options.v;\r\n    const source = options.source || options.s;\r\n    if (version) {\r\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\r\n      process.exit();\r\n    }\r\n    if (_.isEmpty(source) && version === false) {\r\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\r\n      process.exit();\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      // Get the options.\r\n      const opts = rc('mrdoc', Option.merge(options));\r\n      const sources = opts.mrdoc.source.split(',')\r\n      .map(path => path.trim())\r\n      .map(path => {\r\n        // Check if the path is not in glob pattern.\r\n        if (!isGlob(path)) {\r\n          // Make sure the path is resolved.\r\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\r\n          // Check if the path is a file or directory.\r\n          if (_.isEmpty(Path.parse(path).ext)) {\r\n            // Check if the path has a '/' at the end.\r\n            str = str[str.length - 1] === Path.sep ?\r\n            str : `${str}${Path.sep}`;\r\n          }\r\n          // Make sure the file or directory exists;\r\n          if (File.existsSync(str)) {\r\n            // Check if the directory has sub-directories.\r\n            const hasSubDirs = File.readdirSync(str)\r\n            .filter(file =>\r\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\r\n            // Get the file extension.\r\n            const extension = Extension.find(opts.parser.language);\r\n            // Set the glob pattern based on 'hasSubDirs'.\r\n            str = hasSubDirs ?\r\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\r\n          } else return null;\r\n          return str;\r\n        }\r\n        return path;\r\n      });\r\n      // DEBUG: Sources\r\n      log.debug(log.color.blue('Sources:'), sources);\r\n      if (sources.indexOf(null) > -1) {\r\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\r\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = CLI;\r\n"
            }
          },
          {
            "EkedmbI-Rg": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\index.js",
              "source": "'use strict';\r\nconst JSONC = require('./compilers/json/');\r\n// const HTML = require('./compilers/html');\r\n\r\nclass Compiler {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.compiler().file.format) {\r\n      case 'json':\r\n        return (new JSONC(this.options));\r\n      case 'html':\r\n        // return (new HTML(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Compiler;\r\n"
            }
          },
          {
            "VJZdXZU-Ae": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\index.js",
              "source": "'use strict';\r\nconst JavaScript = require('./parsers/javascript/');\r\n\r\nclass Parser {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.parser().language) {\r\n      case 'js':\r\n      case 'javascript':\r\n        return (new JavaScript(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Parser;\r\n"
            }
          },
          {
            "VkzumbIW0x": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\extension.js",
              "source": "'use strict';\r\n\r\nclass Extension {\r\n  static find(language) {\r\n    return Extension.extensions()[language];\r\n  }\r\n  static extensions() {\r\n    return {\r\n      js: '.js',\r\n      javascript: '.js',\r\n      json: '.json',\r\n      html: '.html',\r\n      typescript: '.ts',\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = Extension;\r\n"
            }
          },
          {
            "EJ7uQ-L-Al": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\log.js",
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\n/* eslint-env node */\r\nconst Utils = require('mr-doc-utils');\r\nconst log = new Utils.Log();\r\nconst _ = require('lodash');\r\n\r\nclass Log {\r\n  constructor(options) {\r\n    if (options.silent) {\r\n      log.on('error', () => { /* NOOP */});\r\n      return log;\r\n    }\r\n    this.levels(options.level)\r\n    .forEach(level => {\r\n      if (level === 'error') this.error();\r\n      else this.other(level);\r\n    });\r\n    return log;\r\n  }\r\n  levels(level) {\r\n    const levels = _.isString(level) ? level.split(',') : level;\r\n    return levels\r\n    .map(i => i.replace(/\\s/g, ''));\r\n  }\r\n  error() {\r\n    log.on('error', function error() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args.map(i => log.color.red(i)));\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  other(level) {\r\n    log.on(level, function logger() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args);\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  /**\r\n   * Get the global instance of Log.\r\n   * @return {Log} - An instance of Log.\r\n   */\r\n  static global() {\r\n    log.color = Utils.Log.color;\r\n    return log;\r\n  }\r\n}\r\n\r\nmodule.exports = Log;\r\n"
            }
          },
          {
            "V1V_7WIWAg": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\output.js",
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nconst Option = require('mr-doc-utils').Option;\n\nclass Output {\n  static handler(options, buffer) {\n    const opt = (new Option(options)).options();\n    return function (callback) {\n      Output.format(opt, buffer).forEach(Output.toStream(opt, this));\n      callback();\n    };\n  }\n  static format(options, buffer) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler().file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n\n  static toStream(options, context) {\n    const format = options.compiler().file.format;\n    const file = options.compiler().file;\n    return function (f) {\n      if (format === 'json' || format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "EJSdQZI-Ce": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\source.js",
              "source": "'use strict';\r\nconst ShortID = require('shortid');\r\nconst File = require('fs-extra');\r\nconst _ = require('lodash');\r\n\r\nclass Source {\r\n  static create(files) {\r\n    // Process the files.\r\n    const result = files\r\n    .map(file => Source.processFile(file));\r\n    // Create references for each file.\r\n    const references = result\r\n    .map(file => Source.createReference(file));\r\n    // Process the references and attach it to each file.\r\n    return result\r\n    .map(file => Source.processReference(file, references));\r\n  }\r\n  static processFile(file) {\r\n    return {\r\n      id: ShortID.generate(),\r\n      cwd: file.cwd,\r\n      base: file.base,\r\n      path: file.path,\r\n      source: File.readFileSync(file.path, 'utf8'),\r\n      comments: undefined,\r\n    };\r\n  }\r\n  static createReference(file) {\r\n    return {\r\n      id: file.id,\r\n      cwd: file.cwd,\r\n      base: file.base,\r\n      path: file.path,\r\n      source: file.source,\r\n      comments: file.comments,\r\n    };\r\n  }\r\n  static processReference(file, references) {\r\n    return _.merge(file, {\r\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = Source;\r\n"
            }
          },
          {
            "VJU_QZUb0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\compilers\\interface.js",
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.compiler() : options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "VyPuX-LbCx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\engines\\javascript.engine.js",
              "source": "'use strict';\r\n\r\nconst Babylon = require('babylon');\r\nconst Acorn = require('acorn');\r\nconst Espree = require('espree');\r\nconst ESCodeGen = require('escodegen');\r\nconst ESTraverse = require('estraverse');\r\nconst traverse = require('babel-traverse').default;\r\n\r\nconst opts = {\r\n  acorn: (version, comments, tokens) => ({\r\n    ecmaVersion: version,\r\n    locations: true,\r\n    onComment: comments,\r\n    onToken: tokens,\r\n    ranges: true,\r\n  }),\r\n  babylon: () => ({\r\n    allowImportExportEverywhere: true,\r\n    plugins: [\r\n      'jsx',\r\n      'flow',\r\n      'asyncFunctions',\r\n      'classConstructorCall',\r\n      'doExpressions',\r\n      'trailingFunctionCommas',\r\n      'objectRestSpread',\r\n      'decorators',\r\n      'classProperties',\r\n      'exportExtensions',\r\n      'exponentiationOperator',\r\n      'asyncGenerators',\r\n      'functionBind',\r\n      'functionSent',\r\n    ],\r\n    sourceType: 'module',\r\n  }),\r\n  espree: (version) => ({\r\n    attachComment: true,\r\n    comment: true,\r\n    ecmaFeatures: {\r\n      experimentalObjectRestSpread: true,\r\n      globalReturn: true,\r\n      impliedStrict: true,\r\n      jsx: true,\r\n    },\r\n    ecmaVersion: version,\r\n    loc: true,\r\n    range: true,\r\n    sourceType: 'module',\r\n    tokens: true,\r\n  }),\r\n};\r\n\r\nclass Engine {\r\n  constructor(options) {\r\n    this.options = options;\r\n    switch (this.options.engine) {\r\n      case 'acorn':\r\n        this.engine = Acorn;\r\n        break;\r\n      case 'espree':\r\n        this.engine = Espree;\r\n        break;\r\n      default:\r\n        this.engine = Babylon;\r\n        break;\r\n    }\r\n  }\r\n  parse(file) {\r\n    const comments = [];\r\n    const tokens = [];\r\n    try {\r\n      switch (this.options.engine) {\r\n        case 'acorn':\r\n          return ESCodeGen\r\n          .attachComments(this.engine.parse(file.source,\r\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\r\n        case 'espree':\r\n          return this.engine.parse(file.source, opts.espree(this.options.version));\r\n        default:\r\n          return this.engine.parse(file.source, opts.babylon());\r\n      }\r\n    } catch (error) {\r\n      throw (new Error(error));\r\n    }\r\n  }\r\n  static traverse(options, ast, callback) {\r\n    switch (options.engine) {\r\n      case 'babylon':\r\n        traverse(ast, {\r\n          enter: (path) => {\r\n            const node = path.node;\r\n            callback(node);\r\n          } });\r\n        break;\r\n      default:\r\n        ESTraverse.traverse(ast, {\r\n          /* eslint-disable no-param-reassign */\r\n          enter: (node) => {\r\n            if (node.type === 'Program') {\r\n              node = node.body[0];\r\n            }\r\n            callback(node);\r\n          } });\r\n          /* eslint-enable no-param-reassign */\r\n        break;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Engine;\r\n"
            }
          },
          {
            "EyudQbUb0e": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\interface.js",
              "source": "'use strict';\r\nclass IParser {\r\n  /**\r\n   * @constructor\r\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\r\n   */\r\n  constructor(options) {\r\n    this.options = options.parser ? options.parser() : options;\r\n  }\r\n  /**\r\n   * Parses the sources' comments into the desired output.\r\n   * @param  {Array<Object>} results - The files to parse.\r\n   * @return {Array<Object>} - The parsed comments.\r\n   */\r\n  /* eslint-disable no-unused-vars */\r\n  parse(sources) {\r\n    // ...\r\n  }\r\n  /* eslint-enable no-unused-vars */\r\n}\r\n\r\nmodule.exports = IParser;\r\n"
            }
          },
          {
            "4JF_XW8Z0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\compilers\\json\\index.js",
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "4yc_7bIZ0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\javascript\\index.js",
              "source": "'use strict';\r\n\r\nconst Doctrine = require('doctrine');\r\nconst IParser = require('../interface');\r\nconst Engine = require('../../engines/javascript.engine.js');\r\nconst _ = require('lodash');\r\nconst Log = require('mr-doc-utils').Log;\r\nconst log = new Log();\r\nconst synonyms = require('./synonyms.js');\r\n\r\nclass JavaScript extends IParser {\r\n  constructor(options) {\r\n    super(options);\r\n    this.visited = {};\r\n    this.engine = new Engine(this.options);\r\n    this.comments = [];\r\n    this.results = [];\r\n  }\r\n  /**\r\n   * Parse the file.\r\n   * @param {Object} - The file to parse.\r\n   */\r\n  parse(file) {\r\n    this.file = file;\r\n    this.ast = this.engine.parse(this.file);\r\n    // DEBUG: AST\r\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\r\n    [\r\n      { type: 'leadingComments', context: true },\r\n      { type: 'innerComments', context: false },\r\n      { type: 'trailingComments', context: false },\r\n    ].forEach(comment => this.walkComments(comment));\r\n    return this.results;\r\n  }\r\n  /**\r\n   * Walk the comments.\r\n   * @param {Object} - The comment type and context to walk.\r\n   */\r\n  walkComments(comment) {\r\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\r\n        .filter(this.isJSDocComment)\r\n        .forEach(this.parseComment(node, comment.context)));\r\n  }\r\n  /**\r\n   * Parse the comment.\r\n   * @param {Node} - The current node.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseComment(node, includeContext) {\r\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\r\n    range = !range ? node.range : range;\r\n    range = !range ? [node.start, node.end] : range;\r\n    const context = {\r\n      code: null,\r\n      file: this.file,\r\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\r\n      range: {\r\n        column: [node.loc.start.column, node.loc.end.column],\r\n        line: [node.loc.start.line, node.loc.end.line],\r\n      },\r\n    };\r\n    return (comment) => {\r\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\r\n      if (!this.visited[key]) {\r\n        this.visited[key] = true;\r\n        if (includeContext) {\r\n          Object.defineProperty(context, 'ast', {\r\n            enumerable: false,\r\n            value: node,\r\n          });\r\n          context.code = this.file.source.substring.apply(this.file.source, range);\r\n        }\r\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\r\n      }\r\n    };\r\n  }\r\n  /**\r\n   * Parse the JSDoc comment.\r\n   * @param {String} - The comment to parse.\r\n   * @param {Location} - The comment location.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseJSDoc(comment, loc, context) {\r\n    const result = Doctrine.parse(comment, {\r\n      lineNumbers: true,\r\n      recoverable: true,\r\n      sloppy: true,\r\n      unwrap: true,\r\n    });\r\n    result.loc = loc;\r\n    result.context = context;\r\n    result.errors = [];\r\n    let i = 0;\r\n    while (i < result.tags.length) {\r\n      const tag = result.tags[i];\r\n      if (tag.errors) {\r\n        for (let j = 0; j < tag.errors.length; j++) {\r\n          result.errors.push({ message: tag.errors[j] });\r\n        }\r\n        result.tags.splice(i, 1);\r\n      } else i++;\r\n    }\r\n    return JavaScript.normalize(result);\r\n  }\r\n  /**\r\n   * Determine whether the comment is normalized.\r\n   * @param {String} - The comment to determine.\r\n   * @return {Boolean} - The truth value.\r\n   */\r\n  isJSDocComment(comment) {\r\n    const asterisks = comment.value.match(/^(\\*+)/);\r\n    return (comment.type === 'CommentBlock' ||\r\n      comment.type === 'Block')\r\n      && asterisks && asterisks[1].length === 1;\r\n  }\r\n  /**\r\n   * Normalize the comment tags.\r\n   * @param {Array} - The comment to normalize.\r\n   * @return {Array} - The comment containing normalized tags.\r\n   */\r\n  static normalize(comment) {\r\n    return _.assignIn({}, comment, {\r\n      tags: comment.tags.map(tag => {\r\n        let title = tag.title.toLowerCase();\r\n        const canonical = synonyms[title];\r\n        if (!canonical) {\r\n          switch (title[0]) {\r\n            case 'e':\r\n              if (title === 'extend') title = 'extends';\r\n              break;\r\n            case 'j':\r\n              if (title === 'jsfiddles') title = 'jsfiddle';\r\n              break;\r\n            default: break;\r\n          }\r\n        }\r\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\r\n      }),\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = JavaScript;\r\n"
            }
          },
          {
            "VkjOmWLbAl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\javascript\\synonyms.js",
              "source": "module.exports = {\r\n  arg: 'param',\r\n  argument: 'param',\r\n  constructor: 'class',\r\n  const: 'constant',\r\n  defaultvalue: 'default',\r\n  desc: 'description',\r\n  emits: 'fires',\r\n  exception: 'throws',\r\n  fileoverview: 'file',\r\n  func: 'function',\r\n  host: 'external',\r\n  linkcode: 'link',\r\n  linkplain: 'link',\r\n  virtual: 'abstract',\r\n  method: 'function',\r\n  overview: 'file',\r\n  prop: 'property',\r\n  return: 'returns',\r\n  var: 'member',\r\n};\r\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 49,
          "column": 2
        },
        "end": {
          "line": 52,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          49,
          52
        ]
      }
    }
  },
  {
    "description": "",
    "tags": [
      {
        "title": "class",
        "description": null,
        "lineNumber": 1,
        "type": null,
        "name": null
      },
      {
        "title": "param",
        "description": "The options for the compiler provided by mr-doc-utils/options",
        "lineNumber": 2,
        "type": {
          "type": "NameExpression",
          "name": "Object"
        },
        "name": "options"
      }
    ],
    "loc": {
      "start": {
        "line": 3,
        "column": 2
      },
      "end": {
        "line": 6,
        "column": 5
      }
    },
    "context": {
      "code": "constructor(options) {\n    this.options = options.parser ? options.compiler() : options;\n  }",
      "file": {
        "id": "VJU_QZUb0l",
        "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
        "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
        "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\compilers\\interface.js",
        "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.compiler() : options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n",
        "ref": [
          {
            "E1_QbLZRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\cli\\index.js",
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\nconst Extension = require('../utils/extension');\r\nconst File = require('fs-extra');\r\nconst Log = require('../utils/log');\r\nconst Liftoff = require('liftoff');\r\nconst Option = require('mr-doc-utils').Option;\r\nconst Path = require('path');\r\nconst Promise = require('bluebird');\r\nconst Yargs = require('yargs');\r\nconst ViynlFS = require('vinyl-fs');\r\nconst isGlob = require('is-glob');\r\nconst log = Log.global();\r\nconst pkg = require('../../package.json');\r\nconst rc = require('rc');\r\nconst _ = require('lodash');\r\n\r\nclass CLI {\r\n  /**\r\n   * Parse the CLI arguments.\r\n   * @static\r\n   */\r\n  static parse() {\r\n    return Yargs\r\n    .usage('Usage: mrdoc [options]', Option.cli())\r\n    .showHelpOnFail(false, 'Specify --help for available options')\r\n    .help('help', log.color.gray('Show help.'))\r\n    .alias('help', 'h')\r\n    .argv;\r\n  }\r\n  /**\r\n   * Create the CLI.\r\n   * @static\r\n   * @return {Liftoff} - An instance of Liftoff.\r\n   */\r\n  static get rocket() {\r\n    // Create the CLI.\r\n    return new Liftoff({\r\n      name: 'mrdoc',\r\n      processTitle: 'mrdoc',\r\n      v8flags: require('v8flags'),\r\n    });\r\n  }\r\n  /**\r\n   * Launch the cli.\r\n   * @static\r\n   * @param {Object} - The parsed CLI arguments.\r\n   * @return {Promise<Stream>} - A promise to the stream.\r\n   */\r\n  static launch(argv) {\r\n    return new Promise((resolve, reject) => {\r\n      // Launch the CLI!\r\n      CLI.rocket.launch({\r\n        cwd: argv.cwd,\r\n        configPath: argv.mrdocrc,\r\n      }, env => CLI.handler(env, argv)\r\n      .then(stream => resolve(stream))\r\n      .catch(error => reject(error)));\r\n    });\r\n  }\r\n  /**\r\n   * Handles the result from the CLI.\r\n   * @static\r\n   */\r\n  static handler(env, options) {\r\n    const version = options.version || options.v;\r\n    const source = options.source || options.s;\r\n    if (version) {\r\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\r\n      process.exit();\r\n    }\r\n    if (_.isEmpty(source) && version === false) {\r\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\r\n      process.exit();\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      // Get the options.\r\n      const opts = rc('mrdoc', Option.merge(options));\r\n      const sources = opts.mrdoc.source.split(',')\r\n      .map(path => path.trim())\r\n      .map(path => {\r\n        // Check if the path is not in glob pattern.\r\n        if (!isGlob(path)) {\r\n          // Make sure the path is resolved.\r\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\r\n          // Check if the path is a file or directory.\r\n          if (_.isEmpty(Path.parse(path).ext)) {\r\n            // Check if the path has a '/' at the end.\r\n            str = str[str.length - 1] === Path.sep ?\r\n            str : `${str}${Path.sep}`;\r\n          }\r\n          // Make sure the file or directory exists;\r\n          if (File.existsSync(str)) {\r\n            // Check if the directory has sub-directories.\r\n            const hasSubDirs = File.readdirSync(str)\r\n            .filter(file =>\r\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\r\n            // Get the file extension.\r\n            const extension = Extension.find(opts.parser.language);\r\n            // Set the glob pattern based on 'hasSubDirs'.\r\n            str = hasSubDirs ?\r\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\r\n          } else return null;\r\n          return str;\r\n        }\r\n        return path;\r\n      });\r\n      // DEBUG: Sources\r\n      log.debug(log.color.blue('Sources:'), sources);\r\n      if (sources.indexOf(null) > -1) {\r\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\r\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = CLI;\r\n"
            }
          },
          {
            "EkedmbI-Rg": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\index.js",
              "source": "'use strict';\r\nconst JSONC = require('./compilers/json/');\r\n// const HTML = require('./compilers/html');\r\n\r\nclass Compiler {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.compiler().file.format) {\r\n      case 'json':\r\n        return (new JSONC(this.options));\r\n      case 'html':\r\n        // return (new HTML(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Compiler;\r\n"
            }
          },
          {
            "VJZdXZU-Ae": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\index.js",
              "source": "'use strict';\r\nconst JavaScript = require('./parsers/javascript/');\r\n\r\nclass Parser {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.parser().language) {\r\n      case 'js':\r\n      case 'javascript':\r\n        return (new JavaScript(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Parser;\r\n"
            }
          },
          {
            "VkzumbIW0x": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\extension.js",
              "source": "'use strict';\r\n\r\nclass Extension {\r\n  static find(language) {\r\n    return Extension.extensions()[language];\r\n  }\r\n  static extensions() {\r\n    return {\r\n      js: '.js',\r\n      javascript: '.js',\r\n      json: '.json',\r\n      html: '.html',\r\n      typescript: '.ts',\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = Extension;\r\n"
            }
          },
          {
            "EJ7uQ-L-Al": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\log.js",
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\n/* eslint-env node */\r\nconst Utils = require('mr-doc-utils');\r\nconst log = new Utils.Log();\r\nconst _ = require('lodash');\r\n\r\nclass Log {\r\n  constructor(options) {\r\n    if (options.silent) {\r\n      log.on('error', () => { /* NOOP */});\r\n      return log;\r\n    }\r\n    this.levels(options.level)\r\n    .forEach(level => {\r\n      if (level === 'error') this.error();\r\n      else this.other(level);\r\n    });\r\n    return log;\r\n  }\r\n  levels(level) {\r\n    const levels = _.isString(level) ? level.split(',') : level;\r\n    return levels\r\n    .map(i => i.replace(/\\s/g, ''));\r\n  }\r\n  error() {\r\n    log.on('error', function error() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args.map(i => log.color.red(i)));\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  other(level) {\r\n    log.on(level, function logger() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args);\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  /**\r\n   * Get the global instance of Log.\r\n   * @return {Log} - An instance of Log.\r\n   */\r\n  static global() {\r\n    log.color = Utils.Log.color;\r\n    return log;\r\n  }\r\n}\r\n\r\nmodule.exports = Log;\r\n"
            }
          },
          {
            "V1V_7WIWAg": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\output.js",
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nconst Option = require('mr-doc-utils').Option;\n\nclass Output {\n  static handler(options, buffer) {\n    const opt = (new Option(options)).options();\n    return function (callback) {\n      Output.format(opt, buffer).forEach(Output.toStream(opt, this));\n      callback();\n    };\n  }\n  static format(options, buffer) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler().file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n\n  static toStream(options, context) {\n    const format = options.compiler().file.format;\n    const file = options.compiler().file;\n    return function (f) {\n      if (format === 'json' || format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "EJSdQZI-Ce": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\source.js",
              "source": "'use strict';\r\nconst ShortID = require('shortid');\r\nconst File = require('fs-extra');\r\nconst _ = require('lodash');\r\n\r\nclass Source {\r\n  static create(files) {\r\n    // Process the files.\r\n    const result = files\r\n    .map(file => Source.processFile(file));\r\n    // Create references for each file.\r\n    const references = result\r\n    .map(file => Source.createReference(file));\r\n    // Process the references and attach it to each file.\r\n    return result\r\n    .map(file => Source.processReference(file, references));\r\n  }\r\n  static processFile(file) {\r\n    return {\r\n      id: ShortID.generate(),\r\n      cwd: file.cwd,\r\n      base: file.base,\r\n      path: file.path,\r\n      source: File.readFileSync(file.path, 'utf8'),\r\n      comments: undefined,\r\n    };\r\n  }\r\n  static createReference(file) {\r\n    return {\r\n      id: file.id,\r\n      cwd: file.cwd,\r\n      base: file.base,\r\n      path: file.path,\r\n      source: file.source,\r\n      comments: file.comments,\r\n    };\r\n  }\r\n  static processReference(file, references) {\r\n    return _.merge(file, {\r\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = Source;\r\n"
            }
          },
          {
            "VJU_QZUb0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\compilers\\interface.js",
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.compiler() : options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "VyPuX-LbCx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\engines\\javascript.engine.js",
              "source": "'use strict';\r\n\r\nconst Babylon = require('babylon');\r\nconst Acorn = require('acorn');\r\nconst Espree = require('espree');\r\nconst ESCodeGen = require('escodegen');\r\nconst ESTraverse = require('estraverse');\r\nconst traverse = require('babel-traverse').default;\r\n\r\nconst opts = {\r\n  acorn: (version, comments, tokens) => ({\r\n    ecmaVersion: version,\r\n    locations: true,\r\n    onComment: comments,\r\n    onToken: tokens,\r\n    ranges: true,\r\n  }),\r\n  babylon: () => ({\r\n    allowImportExportEverywhere: true,\r\n    plugins: [\r\n      'jsx',\r\n      'flow',\r\n      'asyncFunctions',\r\n      'classConstructorCall',\r\n      'doExpressions',\r\n      'trailingFunctionCommas',\r\n      'objectRestSpread',\r\n      'decorators',\r\n      'classProperties',\r\n      'exportExtensions',\r\n      'exponentiationOperator',\r\n      'asyncGenerators',\r\n      'functionBind',\r\n      'functionSent',\r\n    ],\r\n    sourceType: 'module',\r\n  }),\r\n  espree: (version) => ({\r\n    attachComment: true,\r\n    comment: true,\r\n    ecmaFeatures: {\r\n      experimentalObjectRestSpread: true,\r\n      globalReturn: true,\r\n      impliedStrict: true,\r\n      jsx: true,\r\n    },\r\n    ecmaVersion: version,\r\n    loc: true,\r\n    range: true,\r\n    sourceType: 'module',\r\n    tokens: true,\r\n  }),\r\n};\r\n\r\nclass Engine {\r\n  constructor(options) {\r\n    this.options = options;\r\n    switch (this.options.engine) {\r\n      case 'acorn':\r\n        this.engine = Acorn;\r\n        break;\r\n      case 'espree':\r\n        this.engine = Espree;\r\n        break;\r\n      default:\r\n        this.engine = Babylon;\r\n        break;\r\n    }\r\n  }\r\n  parse(file) {\r\n    const comments = [];\r\n    const tokens = [];\r\n    try {\r\n      switch (this.options.engine) {\r\n        case 'acorn':\r\n          return ESCodeGen\r\n          .attachComments(this.engine.parse(file.source,\r\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\r\n        case 'espree':\r\n          return this.engine.parse(file.source, opts.espree(this.options.version));\r\n        default:\r\n          return this.engine.parse(file.source, opts.babylon());\r\n      }\r\n    } catch (error) {\r\n      throw (new Error(error));\r\n    }\r\n  }\r\n  static traverse(options, ast, callback) {\r\n    switch (options.engine) {\r\n      case 'babylon':\r\n        traverse(ast, {\r\n          enter: (path) => {\r\n            const node = path.node;\r\n            callback(node);\r\n          } });\r\n        break;\r\n      default:\r\n        ESTraverse.traverse(ast, {\r\n          /* eslint-disable no-param-reassign */\r\n          enter: (node) => {\r\n            if (node.type === 'Program') {\r\n              node = node.body[0];\r\n            }\r\n            callback(node);\r\n          } });\r\n          /* eslint-enable no-param-reassign */\r\n        break;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Engine;\r\n"
            }
          },
          {
            "EyudQbUb0e": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\interface.js",
              "source": "'use strict';\r\nclass IParser {\r\n  /**\r\n   * @constructor\r\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\r\n   */\r\n  constructor(options) {\r\n    this.options = options.parser ? options.parser() : options;\r\n  }\r\n  /**\r\n   * Parses the sources' comments into the desired output.\r\n   * @param  {Array<Object>} results - The files to parse.\r\n   * @return {Array<Object>} - The parsed comments.\r\n   */\r\n  /* eslint-disable no-unused-vars */\r\n  parse(sources) {\r\n    // ...\r\n  }\r\n  /* eslint-enable no-unused-vars */\r\n}\r\n\r\nmodule.exports = IParser;\r\n"
            }
          },
          {
            "4JF_XW8Z0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\compilers\\json\\index.js",
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "4yc_7bIZ0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\javascript\\index.js",
              "source": "'use strict';\r\n\r\nconst Doctrine = require('doctrine');\r\nconst IParser = require('../interface');\r\nconst Engine = require('../../engines/javascript.engine.js');\r\nconst _ = require('lodash');\r\nconst Log = require('mr-doc-utils').Log;\r\nconst log = new Log();\r\nconst synonyms = require('./synonyms.js');\r\n\r\nclass JavaScript extends IParser {\r\n  constructor(options) {\r\n    super(options);\r\n    this.visited = {};\r\n    this.engine = new Engine(this.options);\r\n    this.comments = [];\r\n    this.results = [];\r\n  }\r\n  /**\r\n   * Parse the file.\r\n   * @param {Object} - The file to parse.\r\n   */\r\n  parse(file) {\r\n    this.file = file;\r\n    this.ast = this.engine.parse(this.file);\r\n    // DEBUG: AST\r\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\r\n    [\r\n      { type: 'leadingComments', context: true },\r\n      { type: 'innerComments', context: false },\r\n      { type: 'trailingComments', context: false },\r\n    ].forEach(comment => this.walkComments(comment));\r\n    return this.results;\r\n  }\r\n  /**\r\n   * Walk the comments.\r\n   * @param {Object} - The comment type and context to walk.\r\n   */\r\n  walkComments(comment) {\r\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\r\n        .filter(this.isJSDocComment)\r\n        .forEach(this.parseComment(node, comment.context)));\r\n  }\r\n  /**\r\n   * Parse the comment.\r\n   * @param {Node} - The current node.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseComment(node, includeContext) {\r\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\r\n    range = !range ? node.range : range;\r\n    range = !range ? [node.start, node.end] : range;\r\n    const context = {\r\n      code: null,\r\n      file: this.file,\r\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\r\n      range: {\r\n        column: [node.loc.start.column, node.loc.end.column],\r\n        line: [node.loc.start.line, node.loc.end.line],\r\n      },\r\n    };\r\n    return (comment) => {\r\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\r\n      if (!this.visited[key]) {\r\n        this.visited[key] = true;\r\n        if (includeContext) {\r\n          Object.defineProperty(context, 'ast', {\r\n            enumerable: false,\r\n            value: node,\r\n          });\r\n          context.code = this.file.source.substring.apply(this.file.source, range);\r\n        }\r\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\r\n      }\r\n    };\r\n  }\r\n  /**\r\n   * Parse the JSDoc comment.\r\n   * @param {String} - The comment to parse.\r\n   * @param {Location} - The comment location.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseJSDoc(comment, loc, context) {\r\n    const result = Doctrine.parse(comment, {\r\n      lineNumbers: true,\r\n      recoverable: true,\r\n      sloppy: true,\r\n      unwrap: true,\r\n    });\r\n    result.loc = loc;\r\n    result.context = context;\r\n    result.errors = [];\r\n    let i = 0;\r\n    while (i < result.tags.length) {\r\n      const tag = result.tags[i];\r\n      if (tag.errors) {\r\n        for (let j = 0; j < tag.errors.length; j++) {\r\n          result.errors.push({ message: tag.errors[j] });\r\n        }\r\n        result.tags.splice(i, 1);\r\n      } else i++;\r\n    }\r\n    return JavaScript.normalize(result);\r\n  }\r\n  /**\r\n   * Determine whether the comment is normalized.\r\n   * @param {String} - The comment to determine.\r\n   * @return {Boolean} - The truth value.\r\n   */\r\n  isJSDocComment(comment) {\r\n    const asterisks = comment.value.match(/^(\\*+)/);\r\n    return (comment.type === 'CommentBlock' ||\r\n      comment.type === 'Block')\r\n      && asterisks && asterisks[1].length === 1;\r\n  }\r\n  /**\r\n   * Normalize the comment tags.\r\n   * @param {Array} - The comment to normalize.\r\n   * @return {Array} - The comment containing normalized tags.\r\n   */\r\n  static normalize(comment) {\r\n    return _.assignIn({}, comment, {\r\n      tags: comment.tags.map(tag => {\r\n        let title = tag.title.toLowerCase();\r\n        const canonical = synonyms[title];\r\n        if (!canonical) {\r\n          switch (title[0]) {\r\n            case 'e':\r\n              if (title === 'extend') title = 'extends';\r\n              break;\r\n            case 'j':\r\n              if (title === 'jsfiddles') title = 'jsfiddle';\r\n              break;\r\n            default: break;\r\n          }\r\n        }\r\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\r\n      }),\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = JavaScript;\r\n"
            }
          },
          {
            "VkjOmWLbAl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\javascript\\synonyms.js",
              "source": "module.exports = {\r\n  arg: 'param',\r\n  argument: 'param',\r\n  constructor: 'class',\r\n  const: 'constant',\r\n  defaultvalue: 'default',\r\n  desc: 'description',\r\n  emits: 'fires',\r\n  exception: 'throws',\r\n  fileoverview: 'file',\r\n  func: 'function',\r\n  host: 'external',\r\n  linkcode: 'link',\r\n  linkplain: 'link',\r\n  virtual: 'abstract',\r\n  method: 'function',\r\n  overview: 'file',\r\n  prop: 'property',\r\n  return: 'returns',\r\n  var: 'member',\r\n};\r\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 7,
          "column": 2
        },
        "end": {
          "line": 9,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          7,
          9
        ]
      }
    }
  },
  {
    "description": "Compile the comments into the desired output.",
    "tags": [
      {
        "title": "param",
        "description": "The files to compile.",
        "lineNumber": 2,
        "type": {
          "type": "TypeApplication",
          "expression": {
            "type": "NameExpression",
            "name": "Array"
          },
          "applications": [
            {
              "type": "NameExpression",
              "name": "Object"
            }
          ]
        },
        "name": "results"
      },
      {
        "title": "returns",
        "description": "The compiled files.",
        "lineNumber": 3,
        "type": {
          "type": "AllLiteral"
        }
      }
    ],
    "loc": {
      "start": {
        "line": 10,
        "column": 2
      },
      "end": {
        "line": 14,
        "column": 5
      }
    },
    "context": {
      "code": "compile(comments) {\n    // ...\n  }",
      "file": {
        "id": "VJU_QZUb0l",
        "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
        "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
        "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\compilers\\interface.js",
        "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.compiler() : options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n",
        "ref": [
          {
            "E1_QbLZRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\cli\\index.js",
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\nconst Extension = require('../utils/extension');\r\nconst File = require('fs-extra');\r\nconst Log = require('../utils/log');\r\nconst Liftoff = require('liftoff');\r\nconst Option = require('mr-doc-utils').Option;\r\nconst Path = require('path');\r\nconst Promise = require('bluebird');\r\nconst Yargs = require('yargs');\r\nconst ViynlFS = require('vinyl-fs');\r\nconst isGlob = require('is-glob');\r\nconst log = Log.global();\r\nconst pkg = require('../../package.json');\r\nconst rc = require('rc');\r\nconst _ = require('lodash');\r\n\r\nclass CLI {\r\n  /**\r\n   * Parse the CLI arguments.\r\n   * @static\r\n   */\r\n  static parse() {\r\n    return Yargs\r\n    .usage('Usage: mrdoc [options]', Option.cli())\r\n    .showHelpOnFail(false, 'Specify --help for available options')\r\n    .help('help', log.color.gray('Show help.'))\r\n    .alias('help', 'h')\r\n    .argv;\r\n  }\r\n  /**\r\n   * Create the CLI.\r\n   * @static\r\n   * @return {Liftoff} - An instance of Liftoff.\r\n   */\r\n  static get rocket() {\r\n    // Create the CLI.\r\n    return new Liftoff({\r\n      name: 'mrdoc',\r\n      processTitle: 'mrdoc',\r\n      v8flags: require('v8flags'),\r\n    });\r\n  }\r\n  /**\r\n   * Launch the cli.\r\n   * @static\r\n   * @param {Object} - The parsed CLI arguments.\r\n   * @return {Promise<Stream>} - A promise to the stream.\r\n   */\r\n  static launch(argv) {\r\n    return new Promise((resolve, reject) => {\r\n      // Launch the CLI!\r\n      CLI.rocket.launch({\r\n        cwd: argv.cwd,\r\n        configPath: argv.mrdocrc,\r\n      }, env => CLI.handler(env, argv)\r\n      .then(stream => resolve(stream))\r\n      .catch(error => reject(error)));\r\n    });\r\n  }\r\n  /**\r\n   * Handles the result from the CLI.\r\n   * @static\r\n   */\r\n  static handler(env, options) {\r\n    const version = options.version || options.v;\r\n    const source = options.source || options.s;\r\n    if (version) {\r\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\r\n      process.exit();\r\n    }\r\n    if (_.isEmpty(source) && version === false) {\r\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\r\n      process.exit();\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      // Get the options.\r\n      const opts = rc('mrdoc', Option.merge(options));\r\n      const sources = opts.mrdoc.source.split(',')\r\n      .map(path => path.trim())\r\n      .map(path => {\r\n        // Check if the path is not in glob pattern.\r\n        if (!isGlob(path)) {\r\n          // Make sure the path is resolved.\r\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\r\n          // Check if the path is a file or directory.\r\n          if (_.isEmpty(Path.parse(path).ext)) {\r\n            // Check if the path has a '/' at the end.\r\n            str = str[str.length - 1] === Path.sep ?\r\n            str : `${str}${Path.sep}`;\r\n          }\r\n          // Make sure the file or directory exists;\r\n          if (File.existsSync(str)) {\r\n            // Check if the directory has sub-directories.\r\n            const hasSubDirs = File.readdirSync(str)\r\n            .filter(file =>\r\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\r\n            // Get the file extension.\r\n            const extension = Extension.find(opts.parser.language);\r\n            // Set the glob pattern based on 'hasSubDirs'.\r\n            str = hasSubDirs ?\r\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\r\n          } else return null;\r\n          return str;\r\n        }\r\n        return path;\r\n      });\r\n      // DEBUG: Sources\r\n      log.debug(log.color.blue('Sources:'), sources);\r\n      if (sources.indexOf(null) > -1) {\r\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\r\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = CLI;\r\n"
            }
          },
          {
            "EkedmbI-Rg": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\index.js",
              "source": "'use strict';\r\nconst JSONC = require('./compilers/json/');\r\n// const HTML = require('./compilers/html');\r\n\r\nclass Compiler {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.compiler().file.format) {\r\n      case 'json':\r\n        return (new JSONC(this.options));\r\n      case 'html':\r\n        // return (new HTML(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Compiler;\r\n"
            }
          },
          {
            "VJZdXZU-Ae": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\index.js",
              "source": "'use strict';\r\nconst JavaScript = require('./parsers/javascript/');\r\n\r\nclass Parser {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.parser().language) {\r\n      case 'js':\r\n      case 'javascript':\r\n        return (new JavaScript(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Parser;\r\n"
            }
          },
          {
            "VkzumbIW0x": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\extension.js",
              "source": "'use strict';\r\n\r\nclass Extension {\r\n  static find(language) {\r\n    return Extension.extensions()[language];\r\n  }\r\n  static extensions() {\r\n    return {\r\n      js: '.js',\r\n      javascript: '.js',\r\n      json: '.json',\r\n      html: '.html',\r\n      typescript: '.ts',\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = Extension;\r\n"
            }
          },
          {
            "EJ7uQ-L-Al": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\log.js",
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\n/* eslint-env node */\r\nconst Utils = require('mr-doc-utils');\r\nconst log = new Utils.Log();\r\nconst _ = require('lodash');\r\n\r\nclass Log {\r\n  constructor(options) {\r\n    if (options.silent) {\r\n      log.on('error', () => { /* NOOP */});\r\n      return log;\r\n    }\r\n    this.levels(options.level)\r\n    .forEach(level => {\r\n      if (level === 'error') this.error();\r\n      else this.other(level);\r\n    });\r\n    return log;\r\n  }\r\n  levels(level) {\r\n    const levels = _.isString(level) ? level.split(',') : level;\r\n    return levels\r\n    .map(i => i.replace(/\\s/g, ''));\r\n  }\r\n  error() {\r\n    log.on('error', function error() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args.map(i => log.color.red(i)));\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  other(level) {\r\n    log.on(level, function logger() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args);\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  /**\r\n   * Get the global instance of Log.\r\n   * @return {Log} - An instance of Log.\r\n   */\r\n  static global() {\r\n    log.color = Utils.Log.color;\r\n    return log;\r\n  }\r\n}\r\n\r\nmodule.exports = Log;\r\n"
            }
          },
          {
            "V1V_7WIWAg": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\output.js",
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nconst Option = require('mr-doc-utils').Option;\n\nclass Output {\n  static handler(options, buffer) {\n    const opt = (new Option(options)).options();\n    return function (callback) {\n      Output.format(opt, buffer).forEach(Output.toStream(opt, this));\n      callback();\n    };\n  }\n  static format(options, buffer) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler().file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n\n  static toStream(options, context) {\n    const format = options.compiler().file.format;\n    const file = options.compiler().file;\n    return function (f) {\n      if (format === 'json' || format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "EJSdQZI-Ce": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\source.js",
              "source": "'use strict';\r\nconst ShortID = require('shortid');\r\nconst File = require('fs-extra');\r\nconst _ = require('lodash');\r\n\r\nclass Source {\r\n  static create(files) {\r\n    // Process the files.\r\n    const result = files\r\n    .map(file => Source.processFile(file));\r\n    // Create references for each file.\r\n    const references = result\r\n    .map(file => Source.createReference(file));\r\n    // Process the references and attach it to each file.\r\n    return result\r\n    .map(file => Source.processReference(file, references));\r\n  }\r\n  static processFile(file) {\r\n    return {\r\n      id: ShortID.generate(),\r\n      cwd: file.cwd,\r\n      base: file.base,\r\n      path: file.path,\r\n      source: File.readFileSync(file.path, 'utf8'),\r\n      comments: undefined,\r\n    };\r\n  }\r\n  static createReference(file) {\r\n    return {\r\n      id: file.id,\r\n      cwd: file.cwd,\r\n      base: file.base,\r\n      path: file.path,\r\n      source: file.source,\r\n      comments: file.comments,\r\n    };\r\n  }\r\n  static processReference(file, references) {\r\n    return _.merge(file, {\r\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = Source;\r\n"
            }
          },
          {
            "VJU_QZUb0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\compilers\\interface.js",
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.compiler() : options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "VyPuX-LbCx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\engines\\javascript.engine.js",
              "source": "'use strict';\r\n\r\nconst Babylon = require('babylon');\r\nconst Acorn = require('acorn');\r\nconst Espree = require('espree');\r\nconst ESCodeGen = require('escodegen');\r\nconst ESTraverse = require('estraverse');\r\nconst traverse = require('babel-traverse').default;\r\n\r\nconst opts = {\r\n  acorn: (version, comments, tokens) => ({\r\n    ecmaVersion: version,\r\n    locations: true,\r\n    onComment: comments,\r\n    onToken: tokens,\r\n    ranges: true,\r\n  }),\r\n  babylon: () => ({\r\n    allowImportExportEverywhere: true,\r\n    plugins: [\r\n      'jsx',\r\n      'flow',\r\n      'asyncFunctions',\r\n      'classConstructorCall',\r\n      'doExpressions',\r\n      'trailingFunctionCommas',\r\n      'objectRestSpread',\r\n      'decorators',\r\n      'classProperties',\r\n      'exportExtensions',\r\n      'exponentiationOperator',\r\n      'asyncGenerators',\r\n      'functionBind',\r\n      'functionSent',\r\n    ],\r\n    sourceType: 'module',\r\n  }),\r\n  espree: (version) => ({\r\n    attachComment: true,\r\n    comment: true,\r\n    ecmaFeatures: {\r\n      experimentalObjectRestSpread: true,\r\n      globalReturn: true,\r\n      impliedStrict: true,\r\n      jsx: true,\r\n    },\r\n    ecmaVersion: version,\r\n    loc: true,\r\n    range: true,\r\n    sourceType: 'module',\r\n    tokens: true,\r\n  }),\r\n};\r\n\r\nclass Engine {\r\n  constructor(options) {\r\n    this.options = options;\r\n    switch (this.options.engine) {\r\n      case 'acorn':\r\n        this.engine = Acorn;\r\n        break;\r\n      case 'espree':\r\n        this.engine = Espree;\r\n        break;\r\n      default:\r\n        this.engine = Babylon;\r\n        break;\r\n    }\r\n  }\r\n  parse(file) {\r\n    const comments = [];\r\n    const tokens = [];\r\n    try {\r\n      switch (this.options.engine) {\r\n        case 'acorn':\r\n          return ESCodeGen\r\n          .attachComments(this.engine.parse(file.source,\r\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\r\n        case 'espree':\r\n          return this.engine.parse(file.source, opts.espree(this.options.version));\r\n        default:\r\n          return this.engine.parse(file.source, opts.babylon());\r\n      }\r\n    } catch (error) {\r\n      throw (new Error(error));\r\n    }\r\n  }\r\n  static traverse(options, ast, callback) {\r\n    switch (options.engine) {\r\n      case 'babylon':\r\n        traverse(ast, {\r\n          enter: (path) => {\r\n            const node = path.node;\r\n            callback(node);\r\n          } });\r\n        break;\r\n      default:\r\n        ESTraverse.traverse(ast, {\r\n          /* eslint-disable no-param-reassign */\r\n          enter: (node) => {\r\n            if (node.type === 'Program') {\r\n              node = node.body[0];\r\n            }\r\n            callback(node);\r\n          } });\r\n          /* eslint-enable no-param-reassign */\r\n        break;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Engine;\r\n"
            }
          },
          {
            "EyudQbUb0e": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\interface.js",
              "source": "'use strict';\r\nclass IParser {\r\n  /**\r\n   * @constructor\r\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\r\n   */\r\n  constructor(options) {\r\n    this.options = options.parser ? options.parser() : options;\r\n  }\r\n  /**\r\n   * Parses the sources' comments into the desired output.\r\n   * @param  {Array<Object>} results - The files to parse.\r\n   * @return {Array<Object>} - The parsed comments.\r\n   */\r\n  /* eslint-disable no-unused-vars */\r\n  parse(sources) {\r\n    // ...\r\n  }\r\n  /* eslint-enable no-unused-vars */\r\n}\r\n\r\nmodule.exports = IParser;\r\n"
            }
          },
          {
            "4JF_XW8Z0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\compilers\\json\\index.js",
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "4yc_7bIZ0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\javascript\\index.js",
              "source": "'use strict';\r\n\r\nconst Doctrine = require('doctrine');\r\nconst IParser = require('../interface');\r\nconst Engine = require('../../engines/javascript.engine.js');\r\nconst _ = require('lodash');\r\nconst Log = require('mr-doc-utils').Log;\r\nconst log = new Log();\r\nconst synonyms = require('./synonyms.js');\r\n\r\nclass JavaScript extends IParser {\r\n  constructor(options) {\r\n    super(options);\r\n    this.visited = {};\r\n    this.engine = new Engine(this.options);\r\n    this.comments = [];\r\n    this.results = [];\r\n  }\r\n  /**\r\n   * Parse the file.\r\n   * @param {Object} - The file to parse.\r\n   */\r\n  parse(file) {\r\n    this.file = file;\r\n    this.ast = this.engine.parse(this.file);\r\n    // DEBUG: AST\r\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\r\n    [\r\n      { type: 'leadingComments', context: true },\r\n      { type: 'innerComments', context: false },\r\n      { type: 'trailingComments', context: false },\r\n    ].forEach(comment => this.walkComments(comment));\r\n    return this.results;\r\n  }\r\n  /**\r\n   * Walk the comments.\r\n   * @param {Object} - The comment type and context to walk.\r\n   */\r\n  walkComments(comment) {\r\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\r\n        .filter(this.isJSDocComment)\r\n        .forEach(this.parseComment(node, comment.context)));\r\n  }\r\n  /**\r\n   * Parse the comment.\r\n   * @param {Node} - The current node.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseComment(node, includeContext) {\r\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\r\n    range = !range ? node.range : range;\r\n    range = !range ? [node.start, node.end] : range;\r\n    const context = {\r\n      code: null,\r\n      file: this.file,\r\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\r\n      range: {\r\n        column: [node.loc.start.column, node.loc.end.column],\r\n        line: [node.loc.start.line, node.loc.end.line],\r\n      },\r\n    };\r\n    return (comment) => {\r\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\r\n      if (!this.visited[key]) {\r\n        this.visited[key] = true;\r\n        if (includeContext) {\r\n          Object.defineProperty(context, 'ast', {\r\n            enumerable: false,\r\n            value: node,\r\n          });\r\n          context.code = this.file.source.substring.apply(this.file.source, range);\r\n        }\r\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\r\n      }\r\n    };\r\n  }\r\n  /**\r\n   * Parse the JSDoc comment.\r\n   * @param {String} - The comment to parse.\r\n   * @param {Location} - The comment location.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseJSDoc(comment, loc, context) {\r\n    const result = Doctrine.parse(comment, {\r\n      lineNumbers: true,\r\n      recoverable: true,\r\n      sloppy: true,\r\n      unwrap: true,\r\n    });\r\n    result.loc = loc;\r\n    result.context = context;\r\n    result.errors = [];\r\n    let i = 0;\r\n    while (i < result.tags.length) {\r\n      const tag = result.tags[i];\r\n      if (tag.errors) {\r\n        for (let j = 0; j < tag.errors.length; j++) {\r\n          result.errors.push({ message: tag.errors[j] });\r\n        }\r\n        result.tags.splice(i, 1);\r\n      } else i++;\r\n    }\r\n    return JavaScript.normalize(result);\r\n  }\r\n  /**\r\n   * Determine whether the comment is normalized.\r\n   * @param {String} - The comment to determine.\r\n   * @return {Boolean} - The truth value.\r\n   */\r\n  isJSDocComment(comment) {\r\n    const asterisks = comment.value.match(/^(\\*+)/);\r\n    return (comment.type === 'CommentBlock' ||\r\n      comment.type === 'Block')\r\n      && asterisks && asterisks[1].length === 1;\r\n  }\r\n  /**\r\n   * Normalize the comment tags.\r\n   * @param {Array} - The comment to normalize.\r\n   * @return {Array} - The comment containing normalized tags.\r\n   */\r\n  static normalize(comment) {\r\n    return _.assignIn({}, comment, {\r\n      tags: comment.tags.map(tag => {\r\n        let title = tag.title.toLowerCase();\r\n        const canonical = synonyms[title];\r\n        if (!canonical) {\r\n          switch (title[0]) {\r\n            case 'e':\r\n              if (title === 'extend') title = 'extends';\r\n              break;\r\n            case 'j':\r\n              if (title === 'jsfiddles') title = 'jsfiddle';\r\n              break;\r\n            default: break;\r\n          }\r\n        }\r\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\r\n      }),\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = JavaScript;\r\n"
            }
          },
          {
            "VkjOmWLbAl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\javascript\\synonyms.js",
              "source": "module.exports = {\r\n  arg: 'param',\r\n  argument: 'param',\r\n  constructor: 'class',\r\n  const: 'constant',\r\n  defaultvalue: 'default',\r\n  desc: 'description',\r\n  emits: 'fires',\r\n  exception: 'throws',\r\n  fileoverview: 'file',\r\n  func: 'function',\r\n  host: 'external',\r\n  linkcode: 'link',\r\n  linkplain: 'link',\r\n  virtual: 'abstract',\r\n  method: 'function',\r\n  overview: 'file',\r\n  prop: 'property',\r\n  return: 'returns',\r\n  var: 'member',\r\n};\r\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 16,
          "column": 2
        },
        "end": {
          "line": 18,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          16,
          18
        ]
      }
    }
  },
  {
    "description": "",
    "tags": [
      {
        "title": "class",
        "description": null,
        "lineNumber": 1,
        "type": null,
        "name": null
      },
      {
        "title": "param",
        "description": "The options for the compiler provided by mr-doc-utils/options",
        "lineNumber": 2,
        "type": {
          "type": "NameExpression",
          "name": "Object"
        },
        "name": "options"
      }
    ],
    "loc": {
      "start": {
        "line": 3,
        "column": 2
      },
      "end": {
        "line": 6,
        "column": 5
      }
    },
    "context": {
      "code": "constructor(options) {\r\n    this.options = options.parser ? options.parser() : options;\r\n  }",
      "file": {
        "id": "EyudQbUb0e",
        "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
        "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
        "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\interface.js",
        "source": "'use strict';\r\nclass IParser {\r\n  /**\r\n   * @constructor\r\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\r\n   */\r\n  constructor(options) {\r\n    this.options = options.parser ? options.parser() : options;\r\n  }\r\n  /**\r\n   * Parses the sources' comments into the desired output.\r\n   * @param  {Array<Object>} results - The files to parse.\r\n   * @return {Array<Object>} - The parsed comments.\r\n   */\r\n  /* eslint-disable no-unused-vars */\r\n  parse(sources) {\r\n    // ...\r\n  }\r\n  /* eslint-enable no-unused-vars */\r\n}\r\n\r\nmodule.exports = IParser;\r\n",
        "ref": [
          {
            "E1_QbLZRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\cli\\index.js",
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\nconst Extension = require('../utils/extension');\r\nconst File = require('fs-extra');\r\nconst Log = require('../utils/log');\r\nconst Liftoff = require('liftoff');\r\nconst Option = require('mr-doc-utils').Option;\r\nconst Path = require('path');\r\nconst Promise = require('bluebird');\r\nconst Yargs = require('yargs');\r\nconst ViynlFS = require('vinyl-fs');\r\nconst isGlob = require('is-glob');\r\nconst log = Log.global();\r\nconst pkg = require('../../package.json');\r\nconst rc = require('rc');\r\nconst _ = require('lodash');\r\n\r\nclass CLI {\r\n  /**\r\n   * Parse the CLI arguments.\r\n   * @static\r\n   */\r\n  static parse() {\r\n    return Yargs\r\n    .usage('Usage: mrdoc [options]', Option.cli())\r\n    .showHelpOnFail(false, 'Specify --help for available options')\r\n    .help('help', log.color.gray('Show help.'))\r\n    .alias('help', 'h')\r\n    .argv;\r\n  }\r\n  /**\r\n   * Create the CLI.\r\n   * @static\r\n   * @return {Liftoff} - An instance of Liftoff.\r\n   */\r\n  static get rocket() {\r\n    // Create the CLI.\r\n    return new Liftoff({\r\n      name: 'mrdoc',\r\n      processTitle: 'mrdoc',\r\n      v8flags: require('v8flags'),\r\n    });\r\n  }\r\n  /**\r\n   * Launch the cli.\r\n   * @static\r\n   * @param {Object} - The parsed CLI arguments.\r\n   * @return {Promise<Stream>} - A promise to the stream.\r\n   */\r\n  static launch(argv) {\r\n    return new Promise((resolve, reject) => {\r\n      // Launch the CLI!\r\n      CLI.rocket.launch({\r\n        cwd: argv.cwd,\r\n        configPath: argv.mrdocrc,\r\n      }, env => CLI.handler(env, argv)\r\n      .then(stream => resolve(stream))\r\n      .catch(error => reject(error)));\r\n    });\r\n  }\r\n  /**\r\n   * Handles the result from the CLI.\r\n   * @static\r\n   */\r\n  static handler(env, options) {\r\n    const version = options.version || options.v;\r\n    const source = options.source || options.s;\r\n    if (version) {\r\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\r\n      process.exit();\r\n    }\r\n    if (_.isEmpty(source) && version === false) {\r\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\r\n      process.exit();\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      // Get the options.\r\n      const opts = rc('mrdoc', Option.merge(options));\r\n      const sources = opts.mrdoc.source.split(',')\r\n      .map(path => path.trim())\r\n      .map(path => {\r\n        // Check if the path is not in glob pattern.\r\n        if (!isGlob(path)) {\r\n          // Make sure the path is resolved.\r\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\r\n          // Check if the path is a file or directory.\r\n          if (_.isEmpty(Path.parse(path).ext)) {\r\n            // Check if the path has a '/' at the end.\r\n            str = str[str.length - 1] === Path.sep ?\r\n            str : `${str}${Path.sep}`;\r\n          }\r\n          // Make sure the file or directory exists;\r\n          if (File.existsSync(str)) {\r\n            // Check if the directory has sub-directories.\r\n            const hasSubDirs = File.readdirSync(str)\r\n            .filter(file =>\r\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\r\n            // Get the file extension.\r\n            const extension = Extension.find(opts.parser.language);\r\n            // Set the glob pattern based on 'hasSubDirs'.\r\n            str = hasSubDirs ?\r\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\r\n          } else return null;\r\n          return str;\r\n        }\r\n        return path;\r\n      });\r\n      // DEBUG: Sources\r\n      log.debug(log.color.blue('Sources:'), sources);\r\n      if (sources.indexOf(null) > -1) {\r\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\r\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = CLI;\r\n"
            }
          },
          {
            "EkedmbI-Rg": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\index.js",
              "source": "'use strict';\r\nconst JSONC = require('./compilers/json/');\r\n// const HTML = require('./compilers/html');\r\n\r\nclass Compiler {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.compiler().file.format) {\r\n      case 'json':\r\n        return (new JSONC(this.options));\r\n      case 'html':\r\n        // return (new HTML(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Compiler;\r\n"
            }
          },
          {
            "VJZdXZU-Ae": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\index.js",
              "source": "'use strict';\r\nconst JavaScript = require('./parsers/javascript/');\r\n\r\nclass Parser {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.parser().language) {\r\n      case 'js':\r\n      case 'javascript':\r\n        return (new JavaScript(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Parser;\r\n"
            }
          },
          {
            "VkzumbIW0x": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\extension.js",
              "source": "'use strict';\r\n\r\nclass Extension {\r\n  static find(language) {\r\n    return Extension.extensions()[language];\r\n  }\r\n  static extensions() {\r\n    return {\r\n      js: '.js',\r\n      javascript: '.js',\r\n      json: '.json',\r\n      html: '.html',\r\n      typescript: '.ts',\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = Extension;\r\n"
            }
          },
          {
            "EJ7uQ-L-Al": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\log.js",
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\n/* eslint-env node */\r\nconst Utils = require('mr-doc-utils');\r\nconst log = new Utils.Log();\r\nconst _ = require('lodash');\r\n\r\nclass Log {\r\n  constructor(options) {\r\n    if (options.silent) {\r\n      log.on('error', () => { /* NOOP */});\r\n      return log;\r\n    }\r\n    this.levels(options.level)\r\n    .forEach(level => {\r\n      if (level === 'error') this.error();\r\n      else this.other(level);\r\n    });\r\n    return log;\r\n  }\r\n  levels(level) {\r\n    const levels = _.isString(level) ? level.split(',') : level;\r\n    return levels\r\n    .map(i => i.replace(/\\s/g, ''));\r\n  }\r\n  error() {\r\n    log.on('error', function error() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args.map(i => log.color.red(i)));\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  other(level) {\r\n    log.on(level, function logger() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args);\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  /**\r\n   * Get the global instance of Log.\r\n   * @return {Log} - An instance of Log.\r\n   */\r\n  static global() {\r\n    log.color = Utils.Log.color;\r\n    return log;\r\n  }\r\n}\r\n\r\nmodule.exports = Log;\r\n"
            }
          },
          {
            "V1V_7WIWAg": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\output.js",
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nconst Option = require('mr-doc-utils').Option;\n\nclass Output {\n  static handler(options, buffer) {\n    const opt = (new Option(options)).options();\n    return function (callback) {\n      Output.format(opt, buffer).forEach(Output.toStream(opt, this));\n      callback();\n    };\n  }\n  static format(options, buffer) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler().file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n\n  static toStream(options, context) {\n    const format = options.compiler().file.format;\n    const file = options.compiler().file;\n    return function (f) {\n      if (format === 'json' || format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "EJSdQZI-Ce": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\source.js",
              "source": "'use strict';\r\nconst ShortID = require('shortid');\r\nconst File = require('fs-extra');\r\nconst _ = require('lodash');\r\n\r\nclass Source {\r\n  static create(files) {\r\n    // Process the files.\r\n    const result = files\r\n    .map(file => Source.processFile(file));\r\n    // Create references for each file.\r\n    const references = result\r\n    .map(file => Source.createReference(file));\r\n    // Process the references and attach it to each file.\r\n    return result\r\n    .map(file => Source.processReference(file, references));\r\n  }\r\n  static processFile(file) {\r\n    return {\r\n      id: ShortID.generate(),\r\n      cwd: file.cwd,\r\n      base: file.base,\r\n      path: file.path,\r\n      source: File.readFileSync(file.path, 'utf8'),\r\n      comments: undefined,\r\n    };\r\n  }\r\n  static createReference(file) {\r\n    return {\r\n      id: file.id,\r\n      cwd: file.cwd,\r\n      base: file.base,\r\n      path: file.path,\r\n      source: file.source,\r\n      comments: file.comments,\r\n    };\r\n  }\r\n  static processReference(file, references) {\r\n    return _.merge(file, {\r\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = Source;\r\n"
            }
          },
          {
            "VJU_QZUb0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\compilers\\interface.js",
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.compiler() : options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "VyPuX-LbCx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\engines\\javascript.engine.js",
              "source": "'use strict';\r\n\r\nconst Babylon = require('babylon');\r\nconst Acorn = require('acorn');\r\nconst Espree = require('espree');\r\nconst ESCodeGen = require('escodegen');\r\nconst ESTraverse = require('estraverse');\r\nconst traverse = require('babel-traverse').default;\r\n\r\nconst opts = {\r\n  acorn: (version, comments, tokens) => ({\r\n    ecmaVersion: version,\r\n    locations: true,\r\n    onComment: comments,\r\n    onToken: tokens,\r\n    ranges: true,\r\n  }),\r\n  babylon: () => ({\r\n    allowImportExportEverywhere: true,\r\n    plugins: [\r\n      'jsx',\r\n      'flow',\r\n      'asyncFunctions',\r\n      'classConstructorCall',\r\n      'doExpressions',\r\n      'trailingFunctionCommas',\r\n      'objectRestSpread',\r\n      'decorators',\r\n      'classProperties',\r\n      'exportExtensions',\r\n      'exponentiationOperator',\r\n      'asyncGenerators',\r\n      'functionBind',\r\n      'functionSent',\r\n    ],\r\n    sourceType: 'module',\r\n  }),\r\n  espree: (version) => ({\r\n    attachComment: true,\r\n    comment: true,\r\n    ecmaFeatures: {\r\n      experimentalObjectRestSpread: true,\r\n      globalReturn: true,\r\n      impliedStrict: true,\r\n      jsx: true,\r\n    },\r\n    ecmaVersion: version,\r\n    loc: true,\r\n    range: true,\r\n    sourceType: 'module',\r\n    tokens: true,\r\n  }),\r\n};\r\n\r\nclass Engine {\r\n  constructor(options) {\r\n    this.options = options;\r\n    switch (this.options.engine) {\r\n      case 'acorn':\r\n        this.engine = Acorn;\r\n        break;\r\n      case 'espree':\r\n        this.engine = Espree;\r\n        break;\r\n      default:\r\n        this.engine = Babylon;\r\n        break;\r\n    }\r\n  }\r\n  parse(file) {\r\n    const comments = [];\r\n    const tokens = [];\r\n    try {\r\n      switch (this.options.engine) {\r\n        case 'acorn':\r\n          return ESCodeGen\r\n          .attachComments(this.engine.parse(file.source,\r\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\r\n        case 'espree':\r\n          return this.engine.parse(file.source, opts.espree(this.options.version));\r\n        default:\r\n          return this.engine.parse(file.source, opts.babylon());\r\n      }\r\n    } catch (error) {\r\n      throw (new Error(error));\r\n    }\r\n  }\r\n  static traverse(options, ast, callback) {\r\n    switch (options.engine) {\r\n      case 'babylon':\r\n        traverse(ast, {\r\n          enter: (path) => {\r\n            const node = path.node;\r\n            callback(node);\r\n          } });\r\n        break;\r\n      default:\r\n        ESTraverse.traverse(ast, {\r\n          /* eslint-disable no-param-reassign */\r\n          enter: (node) => {\r\n            if (node.type === 'Program') {\r\n              node = node.body[0];\r\n            }\r\n            callback(node);\r\n          } });\r\n          /* eslint-enable no-param-reassign */\r\n        break;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Engine;\r\n"
            }
          },
          {
            "EyudQbUb0e": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\interface.js",
              "source": "'use strict';\r\nclass IParser {\r\n  /**\r\n   * @constructor\r\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\r\n   */\r\n  constructor(options) {\r\n    this.options = options.parser ? options.parser() : options;\r\n  }\r\n  /**\r\n   * Parses the sources' comments into the desired output.\r\n   * @param  {Array<Object>} results - The files to parse.\r\n   * @return {Array<Object>} - The parsed comments.\r\n   */\r\n  /* eslint-disable no-unused-vars */\r\n  parse(sources) {\r\n    // ...\r\n  }\r\n  /* eslint-enable no-unused-vars */\r\n}\r\n\r\nmodule.exports = IParser;\r\n"
            }
          },
          {
            "4JF_XW8Z0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\compilers\\json\\index.js",
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "4yc_7bIZ0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\javascript\\index.js",
              "source": "'use strict';\r\n\r\nconst Doctrine = require('doctrine');\r\nconst IParser = require('../interface');\r\nconst Engine = require('../../engines/javascript.engine.js');\r\nconst _ = require('lodash');\r\nconst Log = require('mr-doc-utils').Log;\r\nconst log = new Log();\r\nconst synonyms = require('./synonyms.js');\r\n\r\nclass JavaScript extends IParser {\r\n  constructor(options) {\r\n    super(options);\r\n    this.visited = {};\r\n    this.engine = new Engine(this.options);\r\n    this.comments = [];\r\n    this.results = [];\r\n  }\r\n  /**\r\n   * Parse the file.\r\n   * @param {Object} - The file to parse.\r\n   */\r\n  parse(file) {\r\n    this.file = file;\r\n    this.ast = this.engine.parse(this.file);\r\n    // DEBUG: AST\r\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\r\n    [\r\n      { type: 'leadingComments', context: true },\r\n      { type: 'innerComments', context: false },\r\n      { type: 'trailingComments', context: false },\r\n    ].forEach(comment => this.walkComments(comment));\r\n    return this.results;\r\n  }\r\n  /**\r\n   * Walk the comments.\r\n   * @param {Object} - The comment type and context to walk.\r\n   */\r\n  walkComments(comment) {\r\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\r\n        .filter(this.isJSDocComment)\r\n        .forEach(this.parseComment(node, comment.context)));\r\n  }\r\n  /**\r\n   * Parse the comment.\r\n   * @param {Node} - The current node.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseComment(node, includeContext) {\r\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\r\n    range = !range ? node.range : range;\r\n    range = !range ? [node.start, node.end] : range;\r\n    const context = {\r\n      code: null,\r\n      file: this.file,\r\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\r\n      range: {\r\n        column: [node.loc.start.column, node.loc.end.column],\r\n        line: [node.loc.start.line, node.loc.end.line],\r\n      },\r\n    };\r\n    return (comment) => {\r\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\r\n      if (!this.visited[key]) {\r\n        this.visited[key] = true;\r\n        if (includeContext) {\r\n          Object.defineProperty(context, 'ast', {\r\n            enumerable: false,\r\n            value: node,\r\n          });\r\n          context.code = this.file.source.substring.apply(this.file.source, range);\r\n        }\r\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\r\n      }\r\n    };\r\n  }\r\n  /**\r\n   * Parse the JSDoc comment.\r\n   * @param {String} - The comment to parse.\r\n   * @param {Location} - The comment location.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseJSDoc(comment, loc, context) {\r\n    const result = Doctrine.parse(comment, {\r\n      lineNumbers: true,\r\n      recoverable: true,\r\n      sloppy: true,\r\n      unwrap: true,\r\n    });\r\n    result.loc = loc;\r\n    result.context = context;\r\n    result.errors = [];\r\n    let i = 0;\r\n    while (i < result.tags.length) {\r\n      const tag = result.tags[i];\r\n      if (tag.errors) {\r\n        for (let j = 0; j < tag.errors.length; j++) {\r\n          result.errors.push({ message: tag.errors[j] });\r\n        }\r\n        result.tags.splice(i, 1);\r\n      } else i++;\r\n    }\r\n    return JavaScript.normalize(result);\r\n  }\r\n  /**\r\n   * Determine whether the comment is normalized.\r\n   * @param {String} - The comment to determine.\r\n   * @return {Boolean} - The truth value.\r\n   */\r\n  isJSDocComment(comment) {\r\n    const asterisks = comment.value.match(/^(\\*+)/);\r\n    return (comment.type === 'CommentBlock' ||\r\n      comment.type === 'Block')\r\n      && asterisks && asterisks[1].length === 1;\r\n  }\r\n  /**\r\n   * Normalize the comment tags.\r\n   * @param {Array} - The comment to normalize.\r\n   * @return {Array} - The comment containing normalized tags.\r\n   */\r\n  static normalize(comment) {\r\n    return _.assignIn({}, comment, {\r\n      tags: comment.tags.map(tag => {\r\n        let title = tag.title.toLowerCase();\r\n        const canonical = synonyms[title];\r\n        if (!canonical) {\r\n          switch (title[0]) {\r\n            case 'e':\r\n              if (title === 'extend') title = 'extends';\r\n              break;\r\n            case 'j':\r\n              if (title === 'jsfiddles') title = 'jsfiddle';\r\n              break;\r\n            default: break;\r\n          }\r\n        }\r\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\r\n      }),\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = JavaScript;\r\n"
            }
          },
          {
            "VkjOmWLbAl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\javascript\\synonyms.js",
              "source": "module.exports = {\r\n  arg: 'param',\r\n  argument: 'param',\r\n  constructor: 'class',\r\n  const: 'constant',\r\n  defaultvalue: 'default',\r\n  desc: 'description',\r\n  emits: 'fires',\r\n  exception: 'throws',\r\n  fileoverview: 'file',\r\n  func: 'function',\r\n  host: 'external',\r\n  linkcode: 'link',\r\n  linkplain: 'link',\r\n  virtual: 'abstract',\r\n  method: 'function',\r\n  overview: 'file',\r\n  prop: 'property',\r\n  return: 'returns',\r\n  var: 'member',\r\n};\r\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 7,
          "column": 2
        },
        "end": {
          "line": 9,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          7,
          9
        ]
      }
    }
  },
  {
    "description": "Parses the sources' comments into the desired output.",
    "tags": [
      {
        "title": "param",
        "description": "The files to parse.",
        "lineNumber": 2,
        "type": {
          "type": "TypeApplication",
          "expression": {
            "type": "NameExpression",
            "name": "Array"
          },
          "applications": [
            {
              "type": "NameExpression",
              "name": "Object"
            }
          ]
        },
        "name": "results"
      },
      {
        "title": "returns",
        "description": "The parsed comments.",
        "lineNumber": 3,
        "type": {
          "type": "TypeApplication",
          "expression": {
            "type": "NameExpression",
            "name": "Array"
          },
          "applications": [
            {
              "type": "NameExpression",
              "name": "Object"
            }
          ]
        }
      }
    ],
    "loc": {
      "start": {
        "line": 10,
        "column": 2
      },
      "end": {
        "line": 14,
        "column": 5
      }
    },
    "context": {
      "code": "parse(sources) {\r\n    // ...\r\n  }",
      "file": {
        "id": "EyudQbUb0e",
        "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
        "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
        "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\interface.js",
        "source": "'use strict';\r\nclass IParser {\r\n  /**\r\n   * @constructor\r\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\r\n   */\r\n  constructor(options) {\r\n    this.options = options.parser ? options.parser() : options;\r\n  }\r\n  /**\r\n   * Parses the sources' comments into the desired output.\r\n   * @param  {Array<Object>} results - The files to parse.\r\n   * @return {Array<Object>} - The parsed comments.\r\n   */\r\n  /* eslint-disable no-unused-vars */\r\n  parse(sources) {\r\n    // ...\r\n  }\r\n  /* eslint-enable no-unused-vars */\r\n}\r\n\r\nmodule.exports = IParser;\r\n",
        "ref": [
          {
            "E1_QbLZRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\cli\\index.js",
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\nconst Extension = require('../utils/extension');\r\nconst File = require('fs-extra');\r\nconst Log = require('../utils/log');\r\nconst Liftoff = require('liftoff');\r\nconst Option = require('mr-doc-utils').Option;\r\nconst Path = require('path');\r\nconst Promise = require('bluebird');\r\nconst Yargs = require('yargs');\r\nconst ViynlFS = require('vinyl-fs');\r\nconst isGlob = require('is-glob');\r\nconst log = Log.global();\r\nconst pkg = require('../../package.json');\r\nconst rc = require('rc');\r\nconst _ = require('lodash');\r\n\r\nclass CLI {\r\n  /**\r\n   * Parse the CLI arguments.\r\n   * @static\r\n   */\r\n  static parse() {\r\n    return Yargs\r\n    .usage('Usage: mrdoc [options]', Option.cli())\r\n    .showHelpOnFail(false, 'Specify --help for available options')\r\n    .help('help', log.color.gray('Show help.'))\r\n    .alias('help', 'h')\r\n    .argv;\r\n  }\r\n  /**\r\n   * Create the CLI.\r\n   * @static\r\n   * @return {Liftoff} - An instance of Liftoff.\r\n   */\r\n  static get rocket() {\r\n    // Create the CLI.\r\n    return new Liftoff({\r\n      name: 'mrdoc',\r\n      processTitle: 'mrdoc',\r\n      v8flags: require('v8flags'),\r\n    });\r\n  }\r\n  /**\r\n   * Launch the cli.\r\n   * @static\r\n   * @param {Object} - The parsed CLI arguments.\r\n   * @return {Promise<Stream>} - A promise to the stream.\r\n   */\r\n  static launch(argv) {\r\n    return new Promise((resolve, reject) => {\r\n      // Launch the CLI!\r\n      CLI.rocket.launch({\r\n        cwd: argv.cwd,\r\n        configPath: argv.mrdocrc,\r\n      }, env => CLI.handler(env, argv)\r\n      .then(stream => resolve(stream))\r\n      .catch(error => reject(error)));\r\n    });\r\n  }\r\n  /**\r\n   * Handles the result from the CLI.\r\n   * @static\r\n   */\r\n  static handler(env, options) {\r\n    const version = options.version || options.v;\r\n    const source = options.source || options.s;\r\n    if (version) {\r\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\r\n      process.exit();\r\n    }\r\n    if (_.isEmpty(source) && version === false) {\r\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\r\n      process.exit();\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      // Get the options.\r\n      const opts = rc('mrdoc', Option.merge(options));\r\n      const sources = opts.mrdoc.source.split(',')\r\n      .map(path => path.trim())\r\n      .map(path => {\r\n        // Check if the path is not in glob pattern.\r\n        if (!isGlob(path)) {\r\n          // Make sure the path is resolved.\r\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\r\n          // Check if the path is a file or directory.\r\n          if (_.isEmpty(Path.parse(path).ext)) {\r\n            // Check if the path has a '/' at the end.\r\n            str = str[str.length - 1] === Path.sep ?\r\n            str : `${str}${Path.sep}`;\r\n          }\r\n          // Make sure the file or directory exists;\r\n          if (File.existsSync(str)) {\r\n            // Check if the directory has sub-directories.\r\n            const hasSubDirs = File.readdirSync(str)\r\n            .filter(file =>\r\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\r\n            // Get the file extension.\r\n            const extension = Extension.find(opts.parser.language);\r\n            // Set the glob pattern based on 'hasSubDirs'.\r\n            str = hasSubDirs ?\r\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\r\n          } else return null;\r\n          return str;\r\n        }\r\n        return path;\r\n      });\r\n      // DEBUG: Sources\r\n      log.debug(log.color.blue('Sources:'), sources);\r\n      if (sources.indexOf(null) > -1) {\r\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\r\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = CLI;\r\n"
            }
          },
          {
            "EkedmbI-Rg": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\index.js",
              "source": "'use strict';\r\nconst JSONC = require('./compilers/json/');\r\n// const HTML = require('./compilers/html');\r\n\r\nclass Compiler {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.compiler().file.format) {\r\n      case 'json':\r\n        return (new JSONC(this.options));\r\n      case 'html':\r\n        // return (new HTML(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Compiler;\r\n"
            }
          },
          {
            "VJZdXZU-Ae": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\index.js",
              "source": "'use strict';\r\nconst JavaScript = require('./parsers/javascript/');\r\n\r\nclass Parser {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.parser().language) {\r\n      case 'js':\r\n      case 'javascript':\r\n        return (new JavaScript(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Parser;\r\n"
            }
          },
          {
            "VkzumbIW0x": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\extension.js",
              "source": "'use strict';\r\n\r\nclass Extension {\r\n  static find(language) {\r\n    return Extension.extensions()[language];\r\n  }\r\n  static extensions() {\r\n    return {\r\n      js: '.js',\r\n      javascript: '.js',\r\n      json: '.json',\r\n      html: '.html',\r\n      typescript: '.ts',\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = Extension;\r\n"
            }
          },
          {
            "EJ7uQ-L-Al": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\log.js",
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\n/* eslint-env node */\r\nconst Utils = require('mr-doc-utils');\r\nconst log = new Utils.Log();\r\nconst _ = require('lodash');\r\n\r\nclass Log {\r\n  constructor(options) {\r\n    if (options.silent) {\r\n      log.on('error', () => { /* NOOP */});\r\n      return log;\r\n    }\r\n    this.levels(options.level)\r\n    .forEach(level => {\r\n      if (level === 'error') this.error();\r\n      else this.other(level);\r\n    });\r\n    return log;\r\n  }\r\n  levels(level) {\r\n    const levels = _.isString(level) ? level.split(',') : level;\r\n    return levels\r\n    .map(i => i.replace(/\\s/g, ''));\r\n  }\r\n  error() {\r\n    log.on('error', function error() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args.map(i => log.color.red(i)));\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  other(level) {\r\n    log.on(level, function logger() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args);\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  /**\r\n   * Get the global instance of Log.\r\n   * @return {Log} - An instance of Log.\r\n   */\r\n  static global() {\r\n    log.color = Utils.Log.color;\r\n    return log;\r\n  }\r\n}\r\n\r\nmodule.exports = Log;\r\n"
            }
          },
          {
            "V1V_7WIWAg": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\output.js",
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nconst Option = require('mr-doc-utils').Option;\n\nclass Output {\n  static handler(options, buffer) {\n    const opt = (new Option(options)).options();\n    return function (callback) {\n      Output.format(opt, buffer).forEach(Output.toStream(opt, this));\n      callback();\n    };\n  }\n  static format(options, buffer) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler().file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n\n  static toStream(options, context) {\n    const format = options.compiler().file.format;\n    const file = options.compiler().file;\n    return function (f) {\n      if (format === 'json' || format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "EJSdQZI-Ce": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\source.js",
              "source": "'use strict';\r\nconst ShortID = require('shortid');\r\nconst File = require('fs-extra');\r\nconst _ = require('lodash');\r\n\r\nclass Source {\r\n  static create(files) {\r\n    // Process the files.\r\n    const result = files\r\n    .map(file => Source.processFile(file));\r\n    // Create references for each file.\r\n    const references = result\r\n    .map(file => Source.createReference(file));\r\n    // Process the references and attach it to each file.\r\n    return result\r\n    .map(file => Source.processReference(file, references));\r\n  }\r\n  static processFile(file) {\r\n    return {\r\n      id: ShortID.generate(),\r\n      cwd: file.cwd,\r\n      base: file.base,\r\n      path: file.path,\r\n      source: File.readFileSync(file.path, 'utf8'),\r\n      comments: undefined,\r\n    };\r\n  }\r\n  static createReference(file) {\r\n    return {\r\n      id: file.id,\r\n      cwd: file.cwd,\r\n      base: file.base,\r\n      path: file.path,\r\n      source: file.source,\r\n      comments: file.comments,\r\n    };\r\n  }\r\n  static processReference(file, references) {\r\n    return _.merge(file, {\r\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = Source;\r\n"
            }
          },
          {
            "VJU_QZUb0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\compilers\\interface.js",
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.compiler() : options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "VyPuX-LbCx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\engines\\javascript.engine.js",
              "source": "'use strict';\r\n\r\nconst Babylon = require('babylon');\r\nconst Acorn = require('acorn');\r\nconst Espree = require('espree');\r\nconst ESCodeGen = require('escodegen');\r\nconst ESTraverse = require('estraverse');\r\nconst traverse = require('babel-traverse').default;\r\n\r\nconst opts = {\r\n  acorn: (version, comments, tokens) => ({\r\n    ecmaVersion: version,\r\n    locations: true,\r\n    onComment: comments,\r\n    onToken: tokens,\r\n    ranges: true,\r\n  }),\r\n  babylon: () => ({\r\n    allowImportExportEverywhere: true,\r\n    plugins: [\r\n      'jsx',\r\n      'flow',\r\n      'asyncFunctions',\r\n      'classConstructorCall',\r\n      'doExpressions',\r\n      'trailingFunctionCommas',\r\n      'objectRestSpread',\r\n      'decorators',\r\n      'classProperties',\r\n      'exportExtensions',\r\n      'exponentiationOperator',\r\n      'asyncGenerators',\r\n      'functionBind',\r\n      'functionSent',\r\n    ],\r\n    sourceType: 'module',\r\n  }),\r\n  espree: (version) => ({\r\n    attachComment: true,\r\n    comment: true,\r\n    ecmaFeatures: {\r\n      experimentalObjectRestSpread: true,\r\n      globalReturn: true,\r\n      impliedStrict: true,\r\n      jsx: true,\r\n    },\r\n    ecmaVersion: version,\r\n    loc: true,\r\n    range: true,\r\n    sourceType: 'module',\r\n    tokens: true,\r\n  }),\r\n};\r\n\r\nclass Engine {\r\n  constructor(options) {\r\n    this.options = options;\r\n    switch (this.options.engine) {\r\n      case 'acorn':\r\n        this.engine = Acorn;\r\n        break;\r\n      case 'espree':\r\n        this.engine = Espree;\r\n        break;\r\n      default:\r\n        this.engine = Babylon;\r\n        break;\r\n    }\r\n  }\r\n  parse(file) {\r\n    const comments = [];\r\n    const tokens = [];\r\n    try {\r\n      switch (this.options.engine) {\r\n        case 'acorn':\r\n          return ESCodeGen\r\n          .attachComments(this.engine.parse(file.source,\r\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\r\n        case 'espree':\r\n          return this.engine.parse(file.source, opts.espree(this.options.version));\r\n        default:\r\n          return this.engine.parse(file.source, opts.babylon());\r\n      }\r\n    } catch (error) {\r\n      throw (new Error(error));\r\n    }\r\n  }\r\n  static traverse(options, ast, callback) {\r\n    switch (options.engine) {\r\n      case 'babylon':\r\n        traverse(ast, {\r\n          enter: (path) => {\r\n            const node = path.node;\r\n            callback(node);\r\n          } });\r\n        break;\r\n      default:\r\n        ESTraverse.traverse(ast, {\r\n          /* eslint-disable no-param-reassign */\r\n          enter: (node) => {\r\n            if (node.type === 'Program') {\r\n              node = node.body[0];\r\n            }\r\n            callback(node);\r\n          } });\r\n          /* eslint-enable no-param-reassign */\r\n        break;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Engine;\r\n"
            }
          },
          {
            "EyudQbUb0e": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\interface.js",
              "source": "'use strict';\r\nclass IParser {\r\n  /**\r\n   * @constructor\r\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\r\n   */\r\n  constructor(options) {\r\n    this.options = options.parser ? options.parser() : options;\r\n  }\r\n  /**\r\n   * Parses the sources' comments into the desired output.\r\n   * @param  {Array<Object>} results - The files to parse.\r\n   * @return {Array<Object>} - The parsed comments.\r\n   */\r\n  /* eslint-disable no-unused-vars */\r\n  parse(sources) {\r\n    // ...\r\n  }\r\n  /* eslint-enable no-unused-vars */\r\n}\r\n\r\nmodule.exports = IParser;\r\n"
            }
          },
          {
            "4JF_XW8Z0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\compilers\\json\\index.js",
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "4yc_7bIZ0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\javascript\\index.js",
              "source": "'use strict';\r\n\r\nconst Doctrine = require('doctrine');\r\nconst IParser = require('../interface');\r\nconst Engine = require('../../engines/javascript.engine.js');\r\nconst _ = require('lodash');\r\nconst Log = require('mr-doc-utils').Log;\r\nconst log = new Log();\r\nconst synonyms = require('./synonyms.js');\r\n\r\nclass JavaScript extends IParser {\r\n  constructor(options) {\r\n    super(options);\r\n    this.visited = {};\r\n    this.engine = new Engine(this.options);\r\n    this.comments = [];\r\n    this.results = [];\r\n  }\r\n  /**\r\n   * Parse the file.\r\n   * @param {Object} - The file to parse.\r\n   */\r\n  parse(file) {\r\n    this.file = file;\r\n    this.ast = this.engine.parse(this.file);\r\n    // DEBUG: AST\r\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\r\n    [\r\n      { type: 'leadingComments', context: true },\r\n      { type: 'innerComments', context: false },\r\n      { type: 'trailingComments', context: false },\r\n    ].forEach(comment => this.walkComments(comment));\r\n    return this.results;\r\n  }\r\n  /**\r\n   * Walk the comments.\r\n   * @param {Object} - The comment type and context to walk.\r\n   */\r\n  walkComments(comment) {\r\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\r\n        .filter(this.isJSDocComment)\r\n        .forEach(this.parseComment(node, comment.context)));\r\n  }\r\n  /**\r\n   * Parse the comment.\r\n   * @param {Node} - The current node.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseComment(node, includeContext) {\r\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\r\n    range = !range ? node.range : range;\r\n    range = !range ? [node.start, node.end] : range;\r\n    const context = {\r\n      code: null,\r\n      file: this.file,\r\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\r\n      range: {\r\n        column: [node.loc.start.column, node.loc.end.column],\r\n        line: [node.loc.start.line, node.loc.end.line],\r\n      },\r\n    };\r\n    return (comment) => {\r\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\r\n      if (!this.visited[key]) {\r\n        this.visited[key] = true;\r\n        if (includeContext) {\r\n          Object.defineProperty(context, 'ast', {\r\n            enumerable: false,\r\n            value: node,\r\n          });\r\n          context.code = this.file.source.substring.apply(this.file.source, range);\r\n        }\r\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\r\n      }\r\n    };\r\n  }\r\n  /**\r\n   * Parse the JSDoc comment.\r\n   * @param {String} - The comment to parse.\r\n   * @param {Location} - The comment location.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseJSDoc(comment, loc, context) {\r\n    const result = Doctrine.parse(comment, {\r\n      lineNumbers: true,\r\n      recoverable: true,\r\n      sloppy: true,\r\n      unwrap: true,\r\n    });\r\n    result.loc = loc;\r\n    result.context = context;\r\n    result.errors = [];\r\n    let i = 0;\r\n    while (i < result.tags.length) {\r\n      const tag = result.tags[i];\r\n      if (tag.errors) {\r\n        for (let j = 0; j < tag.errors.length; j++) {\r\n          result.errors.push({ message: tag.errors[j] });\r\n        }\r\n        result.tags.splice(i, 1);\r\n      } else i++;\r\n    }\r\n    return JavaScript.normalize(result);\r\n  }\r\n  /**\r\n   * Determine whether the comment is normalized.\r\n   * @param {String} - The comment to determine.\r\n   * @return {Boolean} - The truth value.\r\n   */\r\n  isJSDocComment(comment) {\r\n    const asterisks = comment.value.match(/^(\\*+)/);\r\n    return (comment.type === 'CommentBlock' ||\r\n      comment.type === 'Block')\r\n      && asterisks && asterisks[1].length === 1;\r\n  }\r\n  /**\r\n   * Normalize the comment tags.\r\n   * @param {Array} - The comment to normalize.\r\n   * @return {Array} - The comment containing normalized tags.\r\n   */\r\n  static normalize(comment) {\r\n    return _.assignIn({}, comment, {\r\n      tags: comment.tags.map(tag => {\r\n        let title = tag.title.toLowerCase();\r\n        const canonical = synonyms[title];\r\n        if (!canonical) {\r\n          switch (title[0]) {\r\n            case 'e':\r\n              if (title === 'extend') title = 'extends';\r\n              break;\r\n            case 'j':\r\n              if (title === 'jsfiddles') title = 'jsfiddle';\r\n              break;\r\n            default: break;\r\n          }\r\n        }\r\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\r\n      }),\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = JavaScript;\r\n"
            }
          },
          {
            "VkjOmWLbAl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\javascript\\synonyms.js",
              "source": "module.exports = {\r\n  arg: 'param',\r\n  argument: 'param',\r\n  constructor: 'class',\r\n  const: 'constant',\r\n  defaultvalue: 'default',\r\n  desc: 'description',\r\n  emits: 'fires',\r\n  exception: 'throws',\r\n  fileoverview: 'file',\r\n  func: 'function',\r\n  host: 'external',\r\n  linkcode: 'link',\r\n  linkplain: 'link',\r\n  virtual: 'abstract',\r\n  method: 'function',\r\n  overview: 'file',\r\n  prop: 'property',\r\n  return: 'returns',\r\n  var: 'member',\r\n};\r\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 16,
          "column": 2
        },
        "end": {
          "line": 18,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          16,
          18
        ]
      }
    }
  },
  {
    "description": "Parse the file.",
    "tags": [
      {
        "title": "param",
        "description": "The file to parse.",
        "lineNumber": 2,
        "type": null,
        "name": "Object"
      }
    ],
    "loc": {
      "start": {
        "line": 19,
        "column": 2
      },
      "end": {
        "line": 22,
        "column": 5
      }
    },
    "context": {
      "code": "parse(file) {\r\n    this.file = file;\r\n    this.ast = this.engine.parse(this.file);\r\n    // DEBUG: AST\r\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\r\n    [\r\n      { type: 'leadingComments', context: true },\r\n      { type: 'innerComments', context: false },\r\n      { type: 'trailingComments', context: false },\r\n    ].forEach(comment => this.walkComments(comment));\r\n    return this.results;\r\n  }",
      "file": {
        "id": "4yc_7bIZ0l",
        "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
        "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
        "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\javascript\\index.js",
        "source": "'use strict';\r\n\r\nconst Doctrine = require('doctrine');\r\nconst IParser = require('../interface');\r\nconst Engine = require('../../engines/javascript.engine.js');\r\nconst _ = require('lodash');\r\nconst Log = require('mr-doc-utils').Log;\r\nconst log = new Log();\r\nconst synonyms = require('./synonyms.js');\r\n\r\nclass JavaScript extends IParser {\r\n  constructor(options) {\r\n    super(options);\r\n    this.visited = {};\r\n    this.engine = new Engine(this.options);\r\n    this.comments = [];\r\n    this.results = [];\r\n  }\r\n  /**\r\n   * Parse the file.\r\n   * @param {Object} - The file to parse.\r\n   */\r\n  parse(file) {\r\n    this.file = file;\r\n    this.ast = this.engine.parse(this.file);\r\n    // DEBUG: AST\r\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\r\n    [\r\n      { type: 'leadingComments', context: true },\r\n      { type: 'innerComments', context: false },\r\n      { type: 'trailingComments', context: false },\r\n    ].forEach(comment => this.walkComments(comment));\r\n    return this.results;\r\n  }\r\n  /**\r\n   * Walk the comments.\r\n   * @param {Object} - The comment type and context to walk.\r\n   */\r\n  walkComments(comment) {\r\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\r\n        .filter(this.isJSDocComment)\r\n        .forEach(this.parseComment(node, comment.context)));\r\n  }\r\n  /**\r\n   * Parse the comment.\r\n   * @param {Node} - The current node.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseComment(node, includeContext) {\r\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\r\n    range = !range ? node.range : range;\r\n    range = !range ? [node.start, node.end] : range;\r\n    const context = {\r\n      code: null,\r\n      file: this.file,\r\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\r\n      range: {\r\n        column: [node.loc.start.column, node.loc.end.column],\r\n        line: [node.loc.start.line, node.loc.end.line],\r\n      },\r\n    };\r\n    return (comment) => {\r\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\r\n      if (!this.visited[key]) {\r\n        this.visited[key] = true;\r\n        if (includeContext) {\r\n          Object.defineProperty(context, 'ast', {\r\n            enumerable: false,\r\n            value: node,\r\n          });\r\n          context.code = this.file.source.substring.apply(this.file.source, range);\r\n        }\r\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\r\n      }\r\n    };\r\n  }\r\n  /**\r\n   * Parse the JSDoc comment.\r\n   * @param {String} - The comment to parse.\r\n   * @param {Location} - The comment location.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseJSDoc(comment, loc, context) {\r\n    const result = Doctrine.parse(comment, {\r\n      lineNumbers: true,\r\n      recoverable: true,\r\n      sloppy: true,\r\n      unwrap: true,\r\n    });\r\n    result.loc = loc;\r\n    result.context = context;\r\n    result.errors = [];\r\n    let i = 0;\r\n    while (i < result.tags.length) {\r\n      const tag = result.tags[i];\r\n      if (tag.errors) {\r\n        for (let j = 0; j < tag.errors.length; j++) {\r\n          result.errors.push({ message: tag.errors[j] });\r\n        }\r\n        result.tags.splice(i, 1);\r\n      } else i++;\r\n    }\r\n    return JavaScript.normalize(result);\r\n  }\r\n  /**\r\n   * Determine whether the comment is normalized.\r\n   * @param {String} - The comment to determine.\r\n   * @return {Boolean} - The truth value.\r\n   */\r\n  isJSDocComment(comment) {\r\n    const asterisks = comment.value.match(/^(\\*+)/);\r\n    return (comment.type === 'CommentBlock' ||\r\n      comment.type === 'Block')\r\n      && asterisks && asterisks[1].length === 1;\r\n  }\r\n  /**\r\n   * Normalize the comment tags.\r\n   * @param {Array} - The comment to normalize.\r\n   * @return {Array} - The comment containing normalized tags.\r\n   */\r\n  static normalize(comment) {\r\n    return _.assignIn({}, comment, {\r\n      tags: comment.tags.map(tag => {\r\n        let title = tag.title.toLowerCase();\r\n        const canonical = synonyms[title];\r\n        if (!canonical) {\r\n          switch (title[0]) {\r\n            case 'e':\r\n              if (title === 'extend') title = 'extends';\r\n              break;\r\n            case 'j':\r\n              if (title === 'jsfiddles') title = 'jsfiddle';\r\n              break;\r\n            default: break;\r\n          }\r\n        }\r\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\r\n      }),\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = JavaScript;\r\n",
        "ref": [
          {
            "E1_QbLZRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\cli\\index.js",
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\nconst Extension = require('../utils/extension');\r\nconst File = require('fs-extra');\r\nconst Log = require('../utils/log');\r\nconst Liftoff = require('liftoff');\r\nconst Option = require('mr-doc-utils').Option;\r\nconst Path = require('path');\r\nconst Promise = require('bluebird');\r\nconst Yargs = require('yargs');\r\nconst ViynlFS = require('vinyl-fs');\r\nconst isGlob = require('is-glob');\r\nconst log = Log.global();\r\nconst pkg = require('../../package.json');\r\nconst rc = require('rc');\r\nconst _ = require('lodash');\r\n\r\nclass CLI {\r\n  /**\r\n   * Parse the CLI arguments.\r\n   * @static\r\n   */\r\n  static parse() {\r\n    return Yargs\r\n    .usage('Usage: mrdoc [options]', Option.cli())\r\n    .showHelpOnFail(false, 'Specify --help for available options')\r\n    .help('help', log.color.gray('Show help.'))\r\n    .alias('help', 'h')\r\n    .argv;\r\n  }\r\n  /**\r\n   * Create the CLI.\r\n   * @static\r\n   * @return {Liftoff} - An instance of Liftoff.\r\n   */\r\n  static get rocket() {\r\n    // Create the CLI.\r\n    return new Liftoff({\r\n      name: 'mrdoc',\r\n      processTitle: 'mrdoc',\r\n      v8flags: require('v8flags'),\r\n    });\r\n  }\r\n  /**\r\n   * Launch the cli.\r\n   * @static\r\n   * @param {Object} - The parsed CLI arguments.\r\n   * @return {Promise<Stream>} - A promise to the stream.\r\n   */\r\n  static launch(argv) {\r\n    return new Promise((resolve, reject) => {\r\n      // Launch the CLI!\r\n      CLI.rocket.launch({\r\n        cwd: argv.cwd,\r\n        configPath: argv.mrdocrc,\r\n      }, env => CLI.handler(env, argv)\r\n      .then(stream => resolve(stream))\r\n      .catch(error => reject(error)));\r\n    });\r\n  }\r\n  /**\r\n   * Handles the result from the CLI.\r\n   * @static\r\n   */\r\n  static handler(env, options) {\r\n    const version = options.version || options.v;\r\n    const source = options.source || options.s;\r\n    if (version) {\r\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\r\n      process.exit();\r\n    }\r\n    if (_.isEmpty(source) && version === false) {\r\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\r\n      process.exit();\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      // Get the options.\r\n      const opts = rc('mrdoc', Option.merge(options));\r\n      const sources = opts.mrdoc.source.split(',')\r\n      .map(path => path.trim())\r\n      .map(path => {\r\n        // Check if the path is not in glob pattern.\r\n        if (!isGlob(path)) {\r\n          // Make sure the path is resolved.\r\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\r\n          // Check if the path is a file or directory.\r\n          if (_.isEmpty(Path.parse(path).ext)) {\r\n            // Check if the path has a '/' at the end.\r\n            str = str[str.length - 1] === Path.sep ?\r\n            str : `${str}${Path.sep}`;\r\n          }\r\n          // Make sure the file or directory exists;\r\n          if (File.existsSync(str)) {\r\n            // Check if the directory has sub-directories.\r\n            const hasSubDirs = File.readdirSync(str)\r\n            .filter(file =>\r\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\r\n            // Get the file extension.\r\n            const extension = Extension.find(opts.parser.language);\r\n            // Set the glob pattern based on 'hasSubDirs'.\r\n            str = hasSubDirs ?\r\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\r\n          } else return null;\r\n          return str;\r\n        }\r\n        return path;\r\n      });\r\n      // DEBUG: Sources\r\n      log.debug(log.color.blue('Sources:'), sources);\r\n      if (sources.indexOf(null) > -1) {\r\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\r\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = CLI;\r\n"
            }
          },
          {
            "EkedmbI-Rg": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\index.js",
              "source": "'use strict';\r\nconst JSONC = require('./compilers/json/');\r\n// const HTML = require('./compilers/html');\r\n\r\nclass Compiler {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.compiler().file.format) {\r\n      case 'json':\r\n        return (new JSONC(this.options));\r\n      case 'html':\r\n        // return (new HTML(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Compiler;\r\n"
            }
          },
          {
            "VJZdXZU-Ae": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\index.js",
              "source": "'use strict';\r\nconst JavaScript = require('./parsers/javascript/');\r\n\r\nclass Parser {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.parser().language) {\r\n      case 'js':\r\n      case 'javascript':\r\n        return (new JavaScript(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Parser;\r\n"
            }
          },
          {
            "VkzumbIW0x": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\extension.js",
              "source": "'use strict';\r\n\r\nclass Extension {\r\n  static find(language) {\r\n    return Extension.extensions()[language];\r\n  }\r\n  static extensions() {\r\n    return {\r\n      js: '.js',\r\n      javascript: '.js',\r\n      json: '.json',\r\n      html: '.html',\r\n      typescript: '.ts',\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = Extension;\r\n"
            }
          },
          {
            "EJ7uQ-L-Al": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\log.js",
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\n/* eslint-env node */\r\nconst Utils = require('mr-doc-utils');\r\nconst log = new Utils.Log();\r\nconst _ = require('lodash');\r\n\r\nclass Log {\r\n  constructor(options) {\r\n    if (options.silent) {\r\n      log.on('error', () => { /* NOOP */});\r\n      return log;\r\n    }\r\n    this.levels(options.level)\r\n    .forEach(level => {\r\n      if (level === 'error') this.error();\r\n      else this.other(level);\r\n    });\r\n    return log;\r\n  }\r\n  levels(level) {\r\n    const levels = _.isString(level) ? level.split(',') : level;\r\n    return levels\r\n    .map(i => i.replace(/\\s/g, ''));\r\n  }\r\n  error() {\r\n    log.on('error', function error() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args.map(i => log.color.red(i)));\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  other(level) {\r\n    log.on(level, function logger() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args);\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  /**\r\n   * Get the global instance of Log.\r\n   * @return {Log} - An instance of Log.\r\n   */\r\n  static global() {\r\n    log.color = Utils.Log.color;\r\n    return log;\r\n  }\r\n}\r\n\r\nmodule.exports = Log;\r\n"
            }
          },
          {
            "V1V_7WIWAg": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\output.js",
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nconst Option = require('mr-doc-utils').Option;\n\nclass Output {\n  static handler(options, buffer) {\n    const opt = (new Option(options)).options();\n    return function (callback) {\n      Output.format(opt, buffer).forEach(Output.toStream(opt, this));\n      callback();\n    };\n  }\n  static format(options, buffer) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler().file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n\n  static toStream(options, context) {\n    const format = options.compiler().file.format;\n    const file = options.compiler().file;\n    return function (f) {\n      if (format === 'json' || format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "EJSdQZI-Ce": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\source.js",
              "source": "'use strict';\r\nconst ShortID = require('shortid');\r\nconst File = require('fs-extra');\r\nconst _ = require('lodash');\r\n\r\nclass Source {\r\n  static create(files) {\r\n    // Process the files.\r\n    const result = files\r\n    .map(file => Source.processFile(file));\r\n    // Create references for each file.\r\n    const references = result\r\n    .map(file => Source.createReference(file));\r\n    // Process the references and attach it to each file.\r\n    return result\r\n    .map(file => Source.processReference(file, references));\r\n  }\r\n  static processFile(file) {\r\n    return {\r\n      id: ShortID.generate(),\r\n      cwd: file.cwd,\r\n      base: file.base,\r\n      path: file.path,\r\n      source: File.readFileSync(file.path, 'utf8'),\r\n      comments: undefined,\r\n    };\r\n  }\r\n  static createReference(file) {\r\n    return {\r\n      id: file.id,\r\n      cwd: file.cwd,\r\n      base: file.base,\r\n      path: file.path,\r\n      source: file.source,\r\n      comments: file.comments,\r\n    };\r\n  }\r\n  static processReference(file, references) {\r\n    return _.merge(file, {\r\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = Source;\r\n"
            }
          },
          {
            "VJU_QZUb0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\compilers\\interface.js",
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.compiler() : options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "VyPuX-LbCx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\engines\\javascript.engine.js",
              "source": "'use strict';\r\n\r\nconst Babylon = require('babylon');\r\nconst Acorn = require('acorn');\r\nconst Espree = require('espree');\r\nconst ESCodeGen = require('escodegen');\r\nconst ESTraverse = require('estraverse');\r\nconst traverse = require('babel-traverse').default;\r\n\r\nconst opts = {\r\n  acorn: (version, comments, tokens) => ({\r\n    ecmaVersion: version,\r\n    locations: true,\r\n    onComment: comments,\r\n    onToken: tokens,\r\n    ranges: true,\r\n  }),\r\n  babylon: () => ({\r\n    allowImportExportEverywhere: true,\r\n    plugins: [\r\n      'jsx',\r\n      'flow',\r\n      'asyncFunctions',\r\n      'classConstructorCall',\r\n      'doExpressions',\r\n      'trailingFunctionCommas',\r\n      'objectRestSpread',\r\n      'decorators',\r\n      'classProperties',\r\n      'exportExtensions',\r\n      'exponentiationOperator',\r\n      'asyncGenerators',\r\n      'functionBind',\r\n      'functionSent',\r\n    ],\r\n    sourceType: 'module',\r\n  }),\r\n  espree: (version) => ({\r\n    attachComment: true,\r\n    comment: true,\r\n    ecmaFeatures: {\r\n      experimentalObjectRestSpread: true,\r\n      globalReturn: true,\r\n      impliedStrict: true,\r\n      jsx: true,\r\n    },\r\n    ecmaVersion: version,\r\n    loc: true,\r\n    range: true,\r\n    sourceType: 'module',\r\n    tokens: true,\r\n  }),\r\n};\r\n\r\nclass Engine {\r\n  constructor(options) {\r\n    this.options = options;\r\n    switch (this.options.engine) {\r\n      case 'acorn':\r\n        this.engine = Acorn;\r\n        break;\r\n      case 'espree':\r\n        this.engine = Espree;\r\n        break;\r\n      default:\r\n        this.engine = Babylon;\r\n        break;\r\n    }\r\n  }\r\n  parse(file) {\r\n    const comments = [];\r\n    const tokens = [];\r\n    try {\r\n      switch (this.options.engine) {\r\n        case 'acorn':\r\n          return ESCodeGen\r\n          .attachComments(this.engine.parse(file.source,\r\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\r\n        case 'espree':\r\n          return this.engine.parse(file.source, opts.espree(this.options.version));\r\n        default:\r\n          return this.engine.parse(file.source, opts.babylon());\r\n      }\r\n    } catch (error) {\r\n      throw (new Error(error));\r\n    }\r\n  }\r\n  static traverse(options, ast, callback) {\r\n    switch (options.engine) {\r\n      case 'babylon':\r\n        traverse(ast, {\r\n          enter: (path) => {\r\n            const node = path.node;\r\n            callback(node);\r\n          } });\r\n        break;\r\n      default:\r\n        ESTraverse.traverse(ast, {\r\n          /* eslint-disable no-param-reassign */\r\n          enter: (node) => {\r\n            if (node.type === 'Program') {\r\n              node = node.body[0];\r\n            }\r\n            callback(node);\r\n          } });\r\n          /* eslint-enable no-param-reassign */\r\n        break;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Engine;\r\n"
            }
          },
          {
            "EyudQbUb0e": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\interface.js",
              "source": "'use strict';\r\nclass IParser {\r\n  /**\r\n   * @constructor\r\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\r\n   */\r\n  constructor(options) {\r\n    this.options = options.parser ? options.parser() : options;\r\n  }\r\n  /**\r\n   * Parses the sources' comments into the desired output.\r\n   * @param  {Array<Object>} results - The files to parse.\r\n   * @return {Array<Object>} - The parsed comments.\r\n   */\r\n  /* eslint-disable no-unused-vars */\r\n  parse(sources) {\r\n    // ...\r\n  }\r\n  /* eslint-enable no-unused-vars */\r\n}\r\n\r\nmodule.exports = IParser;\r\n"
            }
          },
          {
            "4JF_XW8Z0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\compilers\\json\\index.js",
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "4yc_7bIZ0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\javascript\\index.js",
              "source": "'use strict';\r\n\r\nconst Doctrine = require('doctrine');\r\nconst IParser = require('../interface');\r\nconst Engine = require('../../engines/javascript.engine.js');\r\nconst _ = require('lodash');\r\nconst Log = require('mr-doc-utils').Log;\r\nconst log = new Log();\r\nconst synonyms = require('./synonyms.js');\r\n\r\nclass JavaScript extends IParser {\r\n  constructor(options) {\r\n    super(options);\r\n    this.visited = {};\r\n    this.engine = new Engine(this.options);\r\n    this.comments = [];\r\n    this.results = [];\r\n  }\r\n  /**\r\n   * Parse the file.\r\n   * @param {Object} - The file to parse.\r\n   */\r\n  parse(file) {\r\n    this.file = file;\r\n    this.ast = this.engine.parse(this.file);\r\n    // DEBUG: AST\r\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\r\n    [\r\n      { type: 'leadingComments', context: true },\r\n      { type: 'innerComments', context: false },\r\n      { type: 'trailingComments', context: false },\r\n    ].forEach(comment => this.walkComments(comment));\r\n    return this.results;\r\n  }\r\n  /**\r\n   * Walk the comments.\r\n   * @param {Object} - The comment type and context to walk.\r\n   */\r\n  walkComments(comment) {\r\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\r\n        .filter(this.isJSDocComment)\r\n        .forEach(this.parseComment(node, comment.context)));\r\n  }\r\n  /**\r\n   * Parse the comment.\r\n   * @param {Node} - The current node.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseComment(node, includeContext) {\r\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\r\n    range = !range ? node.range : range;\r\n    range = !range ? [node.start, node.end] : range;\r\n    const context = {\r\n      code: null,\r\n      file: this.file,\r\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\r\n      range: {\r\n        column: [node.loc.start.column, node.loc.end.column],\r\n        line: [node.loc.start.line, node.loc.end.line],\r\n      },\r\n    };\r\n    return (comment) => {\r\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\r\n      if (!this.visited[key]) {\r\n        this.visited[key] = true;\r\n        if (includeContext) {\r\n          Object.defineProperty(context, 'ast', {\r\n            enumerable: false,\r\n            value: node,\r\n          });\r\n          context.code = this.file.source.substring.apply(this.file.source, range);\r\n        }\r\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\r\n      }\r\n    };\r\n  }\r\n  /**\r\n   * Parse the JSDoc comment.\r\n   * @param {String} - The comment to parse.\r\n   * @param {Location} - The comment location.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseJSDoc(comment, loc, context) {\r\n    const result = Doctrine.parse(comment, {\r\n      lineNumbers: true,\r\n      recoverable: true,\r\n      sloppy: true,\r\n      unwrap: true,\r\n    });\r\n    result.loc = loc;\r\n    result.context = context;\r\n    result.errors = [];\r\n    let i = 0;\r\n    while (i < result.tags.length) {\r\n      const tag = result.tags[i];\r\n      if (tag.errors) {\r\n        for (let j = 0; j < tag.errors.length; j++) {\r\n          result.errors.push({ message: tag.errors[j] });\r\n        }\r\n        result.tags.splice(i, 1);\r\n      } else i++;\r\n    }\r\n    return JavaScript.normalize(result);\r\n  }\r\n  /**\r\n   * Determine whether the comment is normalized.\r\n   * @param {String} - The comment to determine.\r\n   * @return {Boolean} - The truth value.\r\n   */\r\n  isJSDocComment(comment) {\r\n    const asterisks = comment.value.match(/^(\\*+)/);\r\n    return (comment.type === 'CommentBlock' ||\r\n      comment.type === 'Block')\r\n      && asterisks && asterisks[1].length === 1;\r\n  }\r\n  /**\r\n   * Normalize the comment tags.\r\n   * @param {Array} - The comment to normalize.\r\n   * @return {Array} - The comment containing normalized tags.\r\n   */\r\n  static normalize(comment) {\r\n    return _.assignIn({}, comment, {\r\n      tags: comment.tags.map(tag => {\r\n        let title = tag.title.toLowerCase();\r\n        const canonical = synonyms[title];\r\n        if (!canonical) {\r\n          switch (title[0]) {\r\n            case 'e':\r\n              if (title === 'extend') title = 'extends';\r\n              break;\r\n            case 'j':\r\n              if (title === 'jsfiddles') title = 'jsfiddle';\r\n              break;\r\n            default: break;\r\n          }\r\n        }\r\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\r\n      }),\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = JavaScript;\r\n"
            }
          },
          {
            "VkjOmWLbAl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\javascript\\synonyms.js",
              "source": "module.exports = {\r\n  arg: 'param',\r\n  argument: 'param',\r\n  constructor: 'class',\r\n  const: 'constant',\r\n  defaultvalue: 'default',\r\n  desc: 'description',\r\n  emits: 'fires',\r\n  exception: 'throws',\r\n  fileoverview: 'file',\r\n  func: 'function',\r\n  host: 'external',\r\n  linkcode: 'link',\r\n  linkplain: 'link',\r\n  virtual: 'abstract',\r\n  method: 'function',\r\n  overview: 'file',\r\n  prop: 'property',\r\n  return: 'returns',\r\n  var: 'member',\r\n};\r\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 23,
          "column": 2
        },
        "end": {
          "line": 34,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          23,
          34
        ]
      }
    }
  },
  {
    "description": "Walk the comments.",
    "tags": [
      {
        "title": "param",
        "description": "The comment type and context to walk.",
        "lineNumber": 2,
        "type": null,
        "name": "Object"
      }
    ],
    "loc": {
      "start": {
        "line": 35,
        "column": 2
      },
      "end": {
        "line": 38,
        "column": 5
      }
    },
    "context": {
      "code": "walkComments(comment) {\r\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\r\n        .filter(this.isJSDocComment)\r\n        .forEach(this.parseComment(node, comment.context)));\r\n  }",
      "file": {
        "id": "4yc_7bIZ0l",
        "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
        "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
        "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\javascript\\index.js",
        "source": "'use strict';\r\n\r\nconst Doctrine = require('doctrine');\r\nconst IParser = require('../interface');\r\nconst Engine = require('../../engines/javascript.engine.js');\r\nconst _ = require('lodash');\r\nconst Log = require('mr-doc-utils').Log;\r\nconst log = new Log();\r\nconst synonyms = require('./synonyms.js');\r\n\r\nclass JavaScript extends IParser {\r\n  constructor(options) {\r\n    super(options);\r\n    this.visited = {};\r\n    this.engine = new Engine(this.options);\r\n    this.comments = [];\r\n    this.results = [];\r\n  }\r\n  /**\r\n   * Parse the file.\r\n   * @param {Object} - The file to parse.\r\n   */\r\n  parse(file) {\r\n    this.file = file;\r\n    this.ast = this.engine.parse(this.file);\r\n    // DEBUG: AST\r\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\r\n    [\r\n      { type: 'leadingComments', context: true },\r\n      { type: 'innerComments', context: false },\r\n      { type: 'trailingComments', context: false },\r\n    ].forEach(comment => this.walkComments(comment));\r\n    return this.results;\r\n  }\r\n  /**\r\n   * Walk the comments.\r\n   * @param {Object} - The comment type and context to walk.\r\n   */\r\n  walkComments(comment) {\r\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\r\n        .filter(this.isJSDocComment)\r\n        .forEach(this.parseComment(node, comment.context)));\r\n  }\r\n  /**\r\n   * Parse the comment.\r\n   * @param {Node} - The current node.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseComment(node, includeContext) {\r\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\r\n    range = !range ? node.range : range;\r\n    range = !range ? [node.start, node.end] : range;\r\n    const context = {\r\n      code: null,\r\n      file: this.file,\r\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\r\n      range: {\r\n        column: [node.loc.start.column, node.loc.end.column],\r\n        line: [node.loc.start.line, node.loc.end.line],\r\n      },\r\n    };\r\n    return (comment) => {\r\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\r\n      if (!this.visited[key]) {\r\n        this.visited[key] = true;\r\n        if (includeContext) {\r\n          Object.defineProperty(context, 'ast', {\r\n            enumerable: false,\r\n            value: node,\r\n          });\r\n          context.code = this.file.source.substring.apply(this.file.source, range);\r\n        }\r\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\r\n      }\r\n    };\r\n  }\r\n  /**\r\n   * Parse the JSDoc comment.\r\n   * @param {String} - The comment to parse.\r\n   * @param {Location} - The comment location.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseJSDoc(comment, loc, context) {\r\n    const result = Doctrine.parse(comment, {\r\n      lineNumbers: true,\r\n      recoverable: true,\r\n      sloppy: true,\r\n      unwrap: true,\r\n    });\r\n    result.loc = loc;\r\n    result.context = context;\r\n    result.errors = [];\r\n    let i = 0;\r\n    while (i < result.tags.length) {\r\n      const tag = result.tags[i];\r\n      if (tag.errors) {\r\n        for (let j = 0; j < tag.errors.length; j++) {\r\n          result.errors.push({ message: tag.errors[j] });\r\n        }\r\n        result.tags.splice(i, 1);\r\n      } else i++;\r\n    }\r\n    return JavaScript.normalize(result);\r\n  }\r\n  /**\r\n   * Determine whether the comment is normalized.\r\n   * @param {String} - The comment to determine.\r\n   * @return {Boolean} - The truth value.\r\n   */\r\n  isJSDocComment(comment) {\r\n    const asterisks = comment.value.match(/^(\\*+)/);\r\n    return (comment.type === 'CommentBlock' ||\r\n      comment.type === 'Block')\r\n      && asterisks && asterisks[1].length === 1;\r\n  }\r\n  /**\r\n   * Normalize the comment tags.\r\n   * @param {Array} - The comment to normalize.\r\n   * @return {Array} - The comment containing normalized tags.\r\n   */\r\n  static normalize(comment) {\r\n    return _.assignIn({}, comment, {\r\n      tags: comment.tags.map(tag => {\r\n        let title = tag.title.toLowerCase();\r\n        const canonical = synonyms[title];\r\n        if (!canonical) {\r\n          switch (title[0]) {\r\n            case 'e':\r\n              if (title === 'extend') title = 'extends';\r\n              break;\r\n            case 'j':\r\n              if (title === 'jsfiddles') title = 'jsfiddle';\r\n              break;\r\n            default: break;\r\n          }\r\n        }\r\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\r\n      }),\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = JavaScript;\r\n",
        "ref": [
          {
            "E1_QbLZRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\cli\\index.js",
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\nconst Extension = require('../utils/extension');\r\nconst File = require('fs-extra');\r\nconst Log = require('../utils/log');\r\nconst Liftoff = require('liftoff');\r\nconst Option = require('mr-doc-utils').Option;\r\nconst Path = require('path');\r\nconst Promise = require('bluebird');\r\nconst Yargs = require('yargs');\r\nconst ViynlFS = require('vinyl-fs');\r\nconst isGlob = require('is-glob');\r\nconst log = Log.global();\r\nconst pkg = require('../../package.json');\r\nconst rc = require('rc');\r\nconst _ = require('lodash');\r\n\r\nclass CLI {\r\n  /**\r\n   * Parse the CLI arguments.\r\n   * @static\r\n   */\r\n  static parse() {\r\n    return Yargs\r\n    .usage('Usage: mrdoc [options]', Option.cli())\r\n    .showHelpOnFail(false, 'Specify --help for available options')\r\n    .help('help', log.color.gray('Show help.'))\r\n    .alias('help', 'h')\r\n    .argv;\r\n  }\r\n  /**\r\n   * Create the CLI.\r\n   * @static\r\n   * @return {Liftoff} - An instance of Liftoff.\r\n   */\r\n  static get rocket() {\r\n    // Create the CLI.\r\n    return new Liftoff({\r\n      name: 'mrdoc',\r\n      processTitle: 'mrdoc',\r\n      v8flags: require('v8flags'),\r\n    });\r\n  }\r\n  /**\r\n   * Launch the cli.\r\n   * @static\r\n   * @param {Object} - The parsed CLI arguments.\r\n   * @return {Promise<Stream>} - A promise to the stream.\r\n   */\r\n  static launch(argv) {\r\n    return new Promise((resolve, reject) => {\r\n      // Launch the CLI!\r\n      CLI.rocket.launch({\r\n        cwd: argv.cwd,\r\n        configPath: argv.mrdocrc,\r\n      }, env => CLI.handler(env, argv)\r\n      .then(stream => resolve(stream))\r\n      .catch(error => reject(error)));\r\n    });\r\n  }\r\n  /**\r\n   * Handles the result from the CLI.\r\n   * @static\r\n   */\r\n  static handler(env, options) {\r\n    const version = options.version || options.v;\r\n    const source = options.source || options.s;\r\n    if (version) {\r\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\r\n      process.exit();\r\n    }\r\n    if (_.isEmpty(source) && version === false) {\r\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\r\n      process.exit();\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      // Get the options.\r\n      const opts = rc('mrdoc', Option.merge(options));\r\n      const sources = opts.mrdoc.source.split(',')\r\n      .map(path => path.trim())\r\n      .map(path => {\r\n        // Check if the path is not in glob pattern.\r\n        if (!isGlob(path)) {\r\n          // Make sure the path is resolved.\r\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\r\n          // Check if the path is a file or directory.\r\n          if (_.isEmpty(Path.parse(path).ext)) {\r\n            // Check if the path has a '/' at the end.\r\n            str = str[str.length - 1] === Path.sep ?\r\n            str : `${str}${Path.sep}`;\r\n          }\r\n          // Make sure the file or directory exists;\r\n          if (File.existsSync(str)) {\r\n            // Check if the directory has sub-directories.\r\n            const hasSubDirs = File.readdirSync(str)\r\n            .filter(file =>\r\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\r\n            // Get the file extension.\r\n            const extension = Extension.find(opts.parser.language);\r\n            // Set the glob pattern based on 'hasSubDirs'.\r\n            str = hasSubDirs ?\r\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\r\n          } else return null;\r\n          return str;\r\n        }\r\n        return path;\r\n      });\r\n      // DEBUG: Sources\r\n      log.debug(log.color.blue('Sources:'), sources);\r\n      if (sources.indexOf(null) > -1) {\r\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\r\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = CLI;\r\n"
            }
          },
          {
            "EkedmbI-Rg": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\index.js",
              "source": "'use strict';\r\nconst JSONC = require('./compilers/json/');\r\n// const HTML = require('./compilers/html');\r\n\r\nclass Compiler {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.compiler().file.format) {\r\n      case 'json':\r\n        return (new JSONC(this.options));\r\n      case 'html':\r\n        // return (new HTML(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Compiler;\r\n"
            }
          },
          {
            "VJZdXZU-Ae": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\index.js",
              "source": "'use strict';\r\nconst JavaScript = require('./parsers/javascript/');\r\n\r\nclass Parser {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.parser().language) {\r\n      case 'js':\r\n      case 'javascript':\r\n        return (new JavaScript(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Parser;\r\n"
            }
          },
          {
            "VkzumbIW0x": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\extension.js",
              "source": "'use strict';\r\n\r\nclass Extension {\r\n  static find(language) {\r\n    return Extension.extensions()[language];\r\n  }\r\n  static extensions() {\r\n    return {\r\n      js: '.js',\r\n      javascript: '.js',\r\n      json: '.json',\r\n      html: '.html',\r\n      typescript: '.ts',\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = Extension;\r\n"
            }
          },
          {
            "EJ7uQ-L-Al": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\log.js",
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\n/* eslint-env node */\r\nconst Utils = require('mr-doc-utils');\r\nconst log = new Utils.Log();\r\nconst _ = require('lodash');\r\n\r\nclass Log {\r\n  constructor(options) {\r\n    if (options.silent) {\r\n      log.on('error', () => { /* NOOP */});\r\n      return log;\r\n    }\r\n    this.levels(options.level)\r\n    .forEach(level => {\r\n      if (level === 'error') this.error();\r\n      else this.other(level);\r\n    });\r\n    return log;\r\n  }\r\n  levels(level) {\r\n    const levels = _.isString(level) ? level.split(',') : level;\r\n    return levels\r\n    .map(i => i.replace(/\\s/g, ''));\r\n  }\r\n  error() {\r\n    log.on('error', function error() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args.map(i => log.color.red(i)));\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  other(level) {\r\n    log.on(level, function logger() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args);\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  /**\r\n   * Get the global instance of Log.\r\n   * @return {Log} - An instance of Log.\r\n   */\r\n  static global() {\r\n    log.color = Utils.Log.color;\r\n    return log;\r\n  }\r\n}\r\n\r\nmodule.exports = Log;\r\n"
            }
          },
          {
            "V1V_7WIWAg": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\output.js",
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nconst Option = require('mr-doc-utils').Option;\n\nclass Output {\n  static handler(options, buffer) {\n    const opt = (new Option(options)).options();\n    return function (callback) {\n      Output.format(opt, buffer).forEach(Output.toStream(opt, this));\n      callback();\n    };\n  }\n  static format(options, buffer) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler().file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n\n  static toStream(options, context) {\n    const format = options.compiler().file.format;\n    const file = options.compiler().file;\n    return function (f) {\n      if (format === 'json' || format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "EJSdQZI-Ce": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\source.js",
              "source": "'use strict';\r\nconst ShortID = require('shortid');\r\nconst File = require('fs-extra');\r\nconst _ = require('lodash');\r\n\r\nclass Source {\r\n  static create(files) {\r\n    // Process the files.\r\n    const result = files\r\n    .map(file => Source.processFile(file));\r\n    // Create references for each file.\r\n    const references = result\r\n    .map(file => Source.createReference(file));\r\n    // Process the references and attach it to each file.\r\n    return result\r\n    .map(file => Source.processReference(file, references));\r\n  }\r\n  static processFile(file) {\r\n    return {\r\n      id: ShortID.generate(),\r\n      cwd: file.cwd,\r\n      base: file.base,\r\n      path: file.path,\r\n      source: File.readFileSync(file.path, 'utf8'),\r\n      comments: undefined,\r\n    };\r\n  }\r\n  static createReference(file) {\r\n    return {\r\n      id: file.id,\r\n      cwd: file.cwd,\r\n      base: file.base,\r\n      path: file.path,\r\n      source: file.source,\r\n      comments: file.comments,\r\n    };\r\n  }\r\n  static processReference(file, references) {\r\n    return _.merge(file, {\r\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = Source;\r\n"
            }
          },
          {
            "VJU_QZUb0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\compilers\\interface.js",
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.compiler() : options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "VyPuX-LbCx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\engines\\javascript.engine.js",
              "source": "'use strict';\r\n\r\nconst Babylon = require('babylon');\r\nconst Acorn = require('acorn');\r\nconst Espree = require('espree');\r\nconst ESCodeGen = require('escodegen');\r\nconst ESTraverse = require('estraverse');\r\nconst traverse = require('babel-traverse').default;\r\n\r\nconst opts = {\r\n  acorn: (version, comments, tokens) => ({\r\n    ecmaVersion: version,\r\n    locations: true,\r\n    onComment: comments,\r\n    onToken: tokens,\r\n    ranges: true,\r\n  }),\r\n  babylon: () => ({\r\n    allowImportExportEverywhere: true,\r\n    plugins: [\r\n      'jsx',\r\n      'flow',\r\n      'asyncFunctions',\r\n      'classConstructorCall',\r\n      'doExpressions',\r\n      'trailingFunctionCommas',\r\n      'objectRestSpread',\r\n      'decorators',\r\n      'classProperties',\r\n      'exportExtensions',\r\n      'exponentiationOperator',\r\n      'asyncGenerators',\r\n      'functionBind',\r\n      'functionSent',\r\n    ],\r\n    sourceType: 'module',\r\n  }),\r\n  espree: (version) => ({\r\n    attachComment: true,\r\n    comment: true,\r\n    ecmaFeatures: {\r\n      experimentalObjectRestSpread: true,\r\n      globalReturn: true,\r\n      impliedStrict: true,\r\n      jsx: true,\r\n    },\r\n    ecmaVersion: version,\r\n    loc: true,\r\n    range: true,\r\n    sourceType: 'module',\r\n    tokens: true,\r\n  }),\r\n};\r\n\r\nclass Engine {\r\n  constructor(options) {\r\n    this.options = options;\r\n    switch (this.options.engine) {\r\n      case 'acorn':\r\n        this.engine = Acorn;\r\n        break;\r\n      case 'espree':\r\n        this.engine = Espree;\r\n        break;\r\n      default:\r\n        this.engine = Babylon;\r\n        break;\r\n    }\r\n  }\r\n  parse(file) {\r\n    const comments = [];\r\n    const tokens = [];\r\n    try {\r\n      switch (this.options.engine) {\r\n        case 'acorn':\r\n          return ESCodeGen\r\n          .attachComments(this.engine.parse(file.source,\r\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\r\n        case 'espree':\r\n          return this.engine.parse(file.source, opts.espree(this.options.version));\r\n        default:\r\n          return this.engine.parse(file.source, opts.babylon());\r\n      }\r\n    } catch (error) {\r\n      throw (new Error(error));\r\n    }\r\n  }\r\n  static traverse(options, ast, callback) {\r\n    switch (options.engine) {\r\n      case 'babylon':\r\n        traverse(ast, {\r\n          enter: (path) => {\r\n            const node = path.node;\r\n            callback(node);\r\n          } });\r\n        break;\r\n      default:\r\n        ESTraverse.traverse(ast, {\r\n          /* eslint-disable no-param-reassign */\r\n          enter: (node) => {\r\n            if (node.type === 'Program') {\r\n              node = node.body[0];\r\n            }\r\n            callback(node);\r\n          } });\r\n          /* eslint-enable no-param-reassign */\r\n        break;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Engine;\r\n"
            }
          },
          {
            "EyudQbUb0e": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\interface.js",
              "source": "'use strict';\r\nclass IParser {\r\n  /**\r\n   * @constructor\r\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\r\n   */\r\n  constructor(options) {\r\n    this.options = options.parser ? options.parser() : options;\r\n  }\r\n  /**\r\n   * Parses the sources' comments into the desired output.\r\n   * @param  {Array<Object>} results - The files to parse.\r\n   * @return {Array<Object>} - The parsed comments.\r\n   */\r\n  /* eslint-disable no-unused-vars */\r\n  parse(sources) {\r\n    // ...\r\n  }\r\n  /* eslint-enable no-unused-vars */\r\n}\r\n\r\nmodule.exports = IParser;\r\n"
            }
          },
          {
            "4JF_XW8Z0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\compilers\\json\\index.js",
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "4yc_7bIZ0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\javascript\\index.js",
              "source": "'use strict';\r\n\r\nconst Doctrine = require('doctrine');\r\nconst IParser = require('../interface');\r\nconst Engine = require('../../engines/javascript.engine.js');\r\nconst _ = require('lodash');\r\nconst Log = require('mr-doc-utils').Log;\r\nconst log = new Log();\r\nconst synonyms = require('./synonyms.js');\r\n\r\nclass JavaScript extends IParser {\r\n  constructor(options) {\r\n    super(options);\r\n    this.visited = {};\r\n    this.engine = new Engine(this.options);\r\n    this.comments = [];\r\n    this.results = [];\r\n  }\r\n  /**\r\n   * Parse the file.\r\n   * @param {Object} - The file to parse.\r\n   */\r\n  parse(file) {\r\n    this.file = file;\r\n    this.ast = this.engine.parse(this.file);\r\n    // DEBUG: AST\r\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\r\n    [\r\n      { type: 'leadingComments', context: true },\r\n      { type: 'innerComments', context: false },\r\n      { type: 'trailingComments', context: false },\r\n    ].forEach(comment => this.walkComments(comment));\r\n    return this.results;\r\n  }\r\n  /**\r\n   * Walk the comments.\r\n   * @param {Object} - The comment type and context to walk.\r\n   */\r\n  walkComments(comment) {\r\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\r\n        .filter(this.isJSDocComment)\r\n        .forEach(this.parseComment(node, comment.context)));\r\n  }\r\n  /**\r\n   * Parse the comment.\r\n   * @param {Node} - The current node.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseComment(node, includeContext) {\r\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\r\n    range = !range ? node.range : range;\r\n    range = !range ? [node.start, node.end] : range;\r\n    const context = {\r\n      code: null,\r\n      file: this.file,\r\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\r\n      range: {\r\n        column: [node.loc.start.column, node.loc.end.column],\r\n        line: [node.loc.start.line, node.loc.end.line],\r\n      },\r\n    };\r\n    return (comment) => {\r\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\r\n      if (!this.visited[key]) {\r\n        this.visited[key] = true;\r\n        if (includeContext) {\r\n          Object.defineProperty(context, 'ast', {\r\n            enumerable: false,\r\n            value: node,\r\n          });\r\n          context.code = this.file.source.substring.apply(this.file.source, range);\r\n        }\r\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\r\n      }\r\n    };\r\n  }\r\n  /**\r\n   * Parse the JSDoc comment.\r\n   * @param {String} - The comment to parse.\r\n   * @param {Location} - The comment location.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseJSDoc(comment, loc, context) {\r\n    const result = Doctrine.parse(comment, {\r\n      lineNumbers: true,\r\n      recoverable: true,\r\n      sloppy: true,\r\n      unwrap: true,\r\n    });\r\n    result.loc = loc;\r\n    result.context = context;\r\n    result.errors = [];\r\n    let i = 0;\r\n    while (i < result.tags.length) {\r\n      const tag = result.tags[i];\r\n      if (tag.errors) {\r\n        for (let j = 0; j < tag.errors.length; j++) {\r\n          result.errors.push({ message: tag.errors[j] });\r\n        }\r\n        result.tags.splice(i, 1);\r\n      } else i++;\r\n    }\r\n    return JavaScript.normalize(result);\r\n  }\r\n  /**\r\n   * Determine whether the comment is normalized.\r\n   * @param {String} - The comment to determine.\r\n   * @return {Boolean} - The truth value.\r\n   */\r\n  isJSDocComment(comment) {\r\n    const asterisks = comment.value.match(/^(\\*+)/);\r\n    return (comment.type === 'CommentBlock' ||\r\n      comment.type === 'Block')\r\n      && asterisks && asterisks[1].length === 1;\r\n  }\r\n  /**\r\n   * Normalize the comment tags.\r\n   * @param {Array} - The comment to normalize.\r\n   * @return {Array} - The comment containing normalized tags.\r\n   */\r\n  static normalize(comment) {\r\n    return _.assignIn({}, comment, {\r\n      tags: comment.tags.map(tag => {\r\n        let title = tag.title.toLowerCase();\r\n        const canonical = synonyms[title];\r\n        if (!canonical) {\r\n          switch (title[0]) {\r\n            case 'e':\r\n              if (title === 'extend') title = 'extends';\r\n              break;\r\n            case 'j':\r\n              if (title === 'jsfiddles') title = 'jsfiddle';\r\n              break;\r\n            default: break;\r\n          }\r\n        }\r\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\r\n      }),\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = JavaScript;\r\n"
            }
          },
          {
            "VkjOmWLbAl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\javascript\\synonyms.js",
              "source": "module.exports = {\r\n  arg: 'param',\r\n  argument: 'param',\r\n  constructor: 'class',\r\n  const: 'constant',\r\n  defaultvalue: 'default',\r\n  desc: 'description',\r\n  emits: 'fires',\r\n  exception: 'throws',\r\n  fileoverview: 'file',\r\n  func: 'function',\r\n  host: 'external',\r\n  linkcode: 'link',\r\n  linkplain: 'link',\r\n  virtual: 'abstract',\r\n  method: 'function',\r\n  overview: 'file',\r\n  prop: 'property',\r\n  return: 'returns',\r\n  var: 'member',\r\n};\r\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 39,
          "column": 2
        },
        "end": {
          "line": 43,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          39,
          43
        ]
      }
    }
  },
  {
    "description": "Parse the comment.",
    "tags": [
      {
        "title": "param",
        "description": "The current node.",
        "lineNumber": 2,
        "type": null,
        "name": "Node"
      },
      {
        "title": "param",
        "description": "The truth value on whether to include the context.",
        "lineNumber": 3,
        "type": null,
        "name": "Boolean"
      }
    ],
    "loc": {
      "start": {
        "line": 44,
        "column": 2
      },
      "end": {
        "line": 48,
        "column": 5
      }
    },
    "context": {
      "code": "parseComment(node, includeContext) {\r\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\r\n    range = !range ? node.range : range;\r\n    range = !range ? [node.start, node.end] : range;\r\n    const context = {\r\n      code: null,\r\n      file: this.file,\r\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\r\n      range: {\r\n        column: [node.loc.start.column, node.loc.end.column],\r\n        line: [node.loc.start.line, node.loc.end.line],\r\n      },\r\n    };\r\n    return (comment) => {\r\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\r\n      if (!this.visited[key]) {\r\n        this.visited[key] = true;\r\n        if (includeContext) {\r\n          Object.defineProperty(context, 'ast', {\r\n            enumerable: false,\r\n            value: node,\r\n          });\r\n          context.code = this.file.source.substring.apply(this.file.source, range);\r\n        }\r\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\r\n      }\r\n    };\r\n  }",
      "file": {
        "id": "4yc_7bIZ0l",
        "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
        "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
        "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\javascript\\index.js",
        "source": "'use strict';\r\n\r\nconst Doctrine = require('doctrine');\r\nconst IParser = require('../interface');\r\nconst Engine = require('../../engines/javascript.engine.js');\r\nconst _ = require('lodash');\r\nconst Log = require('mr-doc-utils').Log;\r\nconst log = new Log();\r\nconst synonyms = require('./synonyms.js');\r\n\r\nclass JavaScript extends IParser {\r\n  constructor(options) {\r\n    super(options);\r\n    this.visited = {};\r\n    this.engine = new Engine(this.options);\r\n    this.comments = [];\r\n    this.results = [];\r\n  }\r\n  /**\r\n   * Parse the file.\r\n   * @param {Object} - The file to parse.\r\n   */\r\n  parse(file) {\r\n    this.file = file;\r\n    this.ast = this.engine.parse(this.file);\r\n    // DEBUG: AST\r\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\r\n    [\r\n      { type: 'leadingComments', context: true },\r\n      { type: 'innerComments', context: false },\r\n      { type: 'trailingComments', context: false },\r\n    ].forEach(comment => this.walkComments(comment));\r\n    return this.results;\r\n  }\r\n  /**\r\n   * Walk the comments.\r\n   * @param {Object} - The comment type and context to walk.\r\n   */\r\n  walkComments(comment) {\r\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\r\n        .filter(this.isJSDocComment)\r\n        .forEach(this.parseComment(node, comment.context)));\r\n  }\r\n  /**\r\n   * Parse the comment.\r\n   * @param {Node} - The current node.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseComment(node, includeContext) {\r\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\r\n    range = !range ? node.range : range;\r\n    range = !range ? [node.start, node.end] : range;\r\n    const context = {\r\n      code: null,\r\n      file: this.file,\r\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\r\n      range: {\r\n        column: [node.loc.start.column, node.loc.end.column],\r\n        line: [node.loc.start.line, node.loc.end.line],\r\n      },\r\n    };\r\n    return (comment) => {\r\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\r\n      if (!this.visited[key]) {\r\n        this.visited[key] = true;\r\n        if (includeContext) {\r\n          Object.defineProperty(context, 'ast', {\r\n            enumerable: false,\r\n            value: node,\r\n          });\r\n          context.code = this.file.source.substring.apply(this.file.source, range);\r\n        }\r\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\r\n      }\r\n    };\r\n  }\r\n  /**\r\n   * Parse the JSDoc comment.\r\n   * @param {String} - The comment to parse.\r\n   * @param {Location} - The comment location.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseJSDoc(comment, loc, context) {\r\n    const result = Doctrine.parse(comment, {\r\n      lineNumbers: true,\r\n      recoverable: true,\r\n      sloppy: true,\r\n      unwrap: true,\r\n    });\r\n    result.loc = loc;\r\n    result.context = context;\r\n    result.errors = [];\r\n    let i = 0;\r\n    while (i < result.tags.length) {\r\n      const tag = result.tags[i];\r\n      if (tag.errors) {\r\n        for (let j = 0; j < tag.errors.length; j++) {\r\n          result.errors.push({ message: tag.errors[j] });\r\n        }\r\n        result.tags.splice(i, 1);\r\n      } else i++;\r\n    }\r\n    return JavaScript.normalize(result);\r\n  }\r\n  /**\r\n   * Determine whether the comment is normalized.\r\n   * @param {String} - The comment to determine.\r\n   * @return {Boolean} - The truth value.\r\n   */\r\n  isJSDocComment(comment) {\r\n    const asterisks = comment.value.match(/^(\\*+)/);\r\n    return (comment.type === 'CommentBlock' ||\r\n      comment.type === 'Block')\r\n      && asterisks && asterisks[1].length === 1;\r\n  }\r\n  /**\r\n   * Normalize the comment tags.\r\n   * @param {Array} - The comment to normalize.\r\n   * @return {Array} - The comment containing normalized tags.\r\n   */\r\n  static normalize(comment) {\r\n    return _.assignIn({}, comment, {\r\n      tags: comment.tags.map(tag => {\r\n        let title = tag.title.toLowerCase();\r\n        const canonical = synonyms[title];\r\n        if (!canonical) {\r\n          switch (title[0]) {\r\n            case 'e':\r\n              if (title === 'extend') title = 'extends';\r\n              break;\r\n            case 'j':\r\n              if (title === 'jsfiddles') title = 'jsfiddle';\r\n              break;\r\n            default: break;\r\n          }\r\n        }\r\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\r\n      }),\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = JavaScript;\r\n",
        "ref": [
          {
            "E1_QbLZRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\cli\\index.js",
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\nconst Extension = require('../utils/extension');\r\nconst File = require('fs-extra');\r\nconst Log = require('../utils/log');\r\nconst Liftoff = require('liftoff');\r\nconst Option = require('mr-doc-utils').Option;\r\nconst Path = require('path');\r\nconst Promise = require('bluebird');\r\nconst Yargs = require('yargs');\r\nconst ViynlFS = require('vinyl-fs');\r\nconst isGlob = require('is-glob');\r\nconst log = Log.global();\r\nconst pkg = require('../../package.json');\r\nconst rc = require('rc');\r\nconst _ = require('lodash');\r\n\r\nclass CLI {\r\n  /**\r\n   * Parse the CLI arguments.\r\n   * @static\r\n   */\r\n  static parse() {\r\n    return Yargs\r\n    .usage('Usage: mrdoc [options]', Option.cli())\r\n    .showHelpOnFail(false, 'Specify --help for available options')\r\n    .help('help', log.color.gray('Show help.'))\r\n    .alias('help', 'h')\r\n    .argv;\r\n  }\r\n  /**\r\n   * Create the CLI.\r\n   * @static\r\n   * @return {Liftoff} - An instance of Liftoff.\r\n   */\r\n  static get rocket() {\r\n    // Create the CLI.\r\n    return new Liftoff({\r\n      name: 'mrdoc',\r\n      processTitle: 'mrdoc',\r\n      v8flags: require('v8flags'),\r\n    });\r\n  }\r\n  /**\r\n   * Launch the cli.\r\n   * @static\r\n   * @param {Object} - The parsed CLI arguments.\r\n   * @return {Promise<Stream>} - A promise to the stream.\r\n   */\r\n  static launch(argv) {\r\n    return new Promise((resolve, reject) => {\r\n      // Launch the CLI!\r\n      CLI.rocket.launch({\r\n        cwd: argv.cwd,\r\n        configPath: argv.mrdocrc,\r\n      }, env => CLI.handler(env, argv)\r\n      .then(stream => resolve(stream))\r\n      .catch(error => reject(error)));\r\n    });\r\n  }\r\n  /**\r\n   * Handles the result from the CLI.\r\n   * @static\r\n   */\r\n  static handler(env, options) {\r\n    const version = options.version || options.v;\r\n    const source = options.source || options.s;\r\n    if (version) {\r\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\r\n      process.exit();\r\n    }\r\n    if (_.isEmpty(source) && version === false) {\r\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\r\n      process.exit();\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      // Get the options.\r\n      const opts = rc('mrdoc', Option.merge(options));\r\n      const sources = opts.mrdoc.source.split(',')\r\n      .map(path => path.trim())\r\n      .map(path => {\r\n        // Check if the path is not in glob pattern.\r\n        if (!isGlob(path)) {\r\n          // Make sure the path is resolved.\r\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\r\n          // Check if the path is a file or directory.\r\n          if (_.isEmpty(Path.parse(path).ext)) {\r\n            // Check if the path has a '/' at the end.\r\n            str = str[str.length - 1] === Path.sep ?\r\n            str : `${str}${Path.sep}`;\r\n          }\r\n          // Make sure the file or directory exists;\r\n          if (File.existsSync(str)) {\r\n            // Check if the directory has sub-directories.\r\n            const hasSubDirs = File.readdirSync(str)\r\n            .filter(file =>\r\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\r\n            // Get the file extension.\r\n            const extension = Extension.find(opts.parser.language);\r\n            // Set the glob pattern based on 'hasSubDirs'.\r\n            str = hasSubDirs ?\r\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\r\n          } else return null;\r\n          return str;\r\n        }\r\n        return path;\r\n      });\r\n      // DEBUG: Sources\r\n      log.debug(log.color.blue('Sources:'), sources);\r\n      if (sources.indexOf(null) > -1) {\r\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\r\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = CLI;\r\n"
            }
          },
          {
            "EkedmbI-Rg": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\index.js",
              "source": "'use strict';\r\nconst JSONC = require('./compilers/json/');\r\n// const HTML = require('./compilers/html');\r\n\r\nclass Compiler {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.compiler().file.format) {\r\n      case 'json':\r\n        return (new JSONC(this.options));\r\n      case 'html':\r\n        // return (new HTML(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Compiler;\r\n"
            }
          },
          {
            "VJZdXZU-Ae": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\index.js",
              "source": "'use strict';\r\nconst JavaScript = require('./parsers/javascript/');\r\n\r\nclass Parser {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.parser().language) {\r\n      case 'js':\r\n      case 'javascript':\r\n        return (new JavaScript(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Parser;\r\n"
            }
          },
          {
            "VkzumbIW0x": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\extension.js",
              "source": "'use strict';\r\n\r\nclass Extension {\r\n  static find(language) {\r\n    return Extension.extensions()[language];\r\n  }\r\n  static extensions() {\r\n    return {\r\n      js: '.js',\r\n      javascript: '.js',\r\n      json: '.json',\r\n      html: '.html',\r\n      typescript: '.ts',\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = Extension;\r\n"
            }
          },
          {
            "EJ7uQ-L-Al": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\log.js",
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\n/* eslint-env node */\r\nconst Utils = require('mr-doc-utils');\r\nconst log = new Utils.Log();\r\nconst _ = require('lodash');\r\n\r\nclass Log {\r\n  constructor(options) {\r\n    if (options.silent) {\r\n      log.on('error', () => { /* NOOP */});\r\n      return log;\r\n    }\r\n    this.levels(options.level)\r\n    .forEach(level => {\r\n      if (level === 'error') this.error();\r\n      else this.other(level);\r\n    });\r\n    return log;\r\n  }\r\n  levels(level) {\r\n    const levels = _.isString(level) ? level.split(',') : level;\r\n    return levels\r\n    .map(i => i.replace(/\\s/g, ''));\r\n  }\r\n  error() {\r\n    log.on('error', function error() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args.map(i => log.color.red(i)));\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  other(level) {\r\n    log.on(level, function logger() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args);\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  /**\r\n   * Get the global instance of Log.\r\n   * @return {Log} - An instance of Log.\r\n   */\r\n  static global() {\r\n    log.color = Utils.Log.color;\r\n    return log;\r\n  }\r\n}\r\n\r\nmodule.exports = Log;\r\n"
            }
          },
          {
            "V1V_7WIWAg": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\output.js",
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nconst Option = require('mr-doc-utils').Option;\n\nclass Output {\n  static handler(options, buffer) {\n    const opt = (new Option(options)).options();\n    return function (callback) {\n      Output.format(opt, buffer).forEach(Output.toStream(opt, this));\n      callback();\n    };\n  }\n  static format(options, buffer) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler().file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n\n  static toStream(options, context) {\n    const format = options.compiler().file.format;\n    const file = options.compiler().file;\n    return function (f) {\n      if (format === 'json' || format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "EJSdQZI-Ce": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\source.js",
              "source": "'use strict';\r\nconst ShortID = require('shortid');\r\nconst File = require('fs-extra');\r\nconst _ = require('lodash');\r\n\r\nclass Source {\r\n  static create(files) {\r\n    // Process the files.\r\n    const result = files\r\n    .map(file => Source.processFile(file));\r\n    // Create references for each file.\r\n    const references = result\r\n    .map(file => Source.createReference(file));\r\n    // Process the references and attach it to each file.\r\n    return result\r\n    .map(file => Source.processReference(file, references));\r\n  }\r\n  static processFile(file) {\r\n    return {\r\n      id: ShortID.generate(),\r\n      cwd: file.cwd,\r\n      base: file.base,\r\n      path: file.path,\r\n      source: File.readFileSync(file.path, 'utf8'),\r\n      comments: undefined,\r\n    };\r\n  }\r\n  static createReference(file) {\r\n    return {\r\n      id: file.id,\r\n      cwd: file.cwd,\r\n      base: file.base,\r\n      path: file.path,\r\n      source: file.source,\r\n      comments: file.comments,\r\n    };\r\n  }\r\n  static processReference(file, references) {\r\n    return _.merge(file, {\r\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = Source;\r\n"
            }
          },
          {
            "VJU_QZUb0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\compilers\\interface.js",
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.compiler() : options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "VyPuX-LbCx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\engines\\javascript.engine.js",
              "source": "'use strict';\r\n\r\nconst Babylon = require('babylon');\r\nconst Acorn = require('acorn');\r\nconst Espree = require('espree');\r\nconst ESCodeGen = require('escodegen');\r\nconst ESTraverse = require('estraverse');\r\nconst traverse = require('babel-traverse').default;\r\n\r\nconst opts = {\r\n  acorn: (version, comments, tokens) => ({\r\n    ecmaVersion: version,\r\n    locations: true,\r\n    onComment: comments,\r\n    onToken: tokens,\r\n    ranges: true,\r\n  }),\r\n  babylon: () => ({\r\n    allowImportExportEverywhere: true,\r\n    plugins: [\r\n      'jsx',\r\n      'flow',\r\n      'asyncFunctions',\r\n      'classConstructorCall',\r\n      'doExpressions',\r\n      'trailingFunctionCommas',\r\n      'objectRestSpread',\r\n      'decorators',\r\n      'classProperties',\r\n      'exportExtensions',\r\n      'exponentiationOperator',\r\n      'asyncGenerators',\r\n      'functionBind',\r\n      'functionSent',\r\n    ],\r\n    sourceType: 'module',\r\n  }),\r\n  espree: (version) => ({\r\n    attachComment: true,\r\n    comment: true,\r\n    ecmaFeatures: {\r\n      experimentalObjectRestSpread: true,\r\n      globalReturn: true,\r\n      impliedStrict: true,\r\n      jsx: true,\r\n    },\r\n    ecmaVersion: version,\r\n    loc: true,\r\n    range: true,\r\n    sourceType: 'module',\r\n    tokens: true,\r\n  }),\r\n};\r\n\r\nclass Engine {\r\n  constructor(options) {\r\n    this.options = options;\r\n    switch (this.options.engine) {\r\n      case 'acorn':\r\n        this.engine = Acorn;\r\n        break;\r\n      case 'espree':\r\n        this.engine = Espree;\r\n        break;\r\n      default:\r\n        this.engine = Babylon;\r\n        break;\r\n    }\r\n  }\r\n  parse(file) {\r\n    const comments = [];\r\n    const tokens = [];\r\n    try {\r\n      switch (this.options.engine) {\r\n        case 'acorn':\r\n          return ESCodeGen\r\n          .attachComments(this.engine.parse(file.source,\r\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\r\n        case 'espree':\r\n          return this.engine.parse(file.source, opts.espree(this.options.version));\r\n        default:\r\n          return this.engine.parse(file.source, opts.babylon());\r\n      }\r\n    } catch (error) {\r\n      throw (new Error(error));\r\n    }\r\n  }\r\n  static traverse(options, ast, callback) {\r\n    switch (options.engine) {\r\n      case 'babylon':\r\n        traverse(ast, {\r\n          enter: (path) => {\r\n            const node = path.node;\r\n            callback(node);\r\n          } });\r\n        break;\r\n      default:\r\n        ESTraverse.traverse(ast, {\r\n          /* eslint-disable no-param-reassign */\r\n          enter: (node) => {\r\n            if (node.type === 'Program') {\r\n              node = node.body[0];\r\n            }\r\n            callback(node);\r\n          } });\r\n          /* eslint-enable no-param-reassign */\r\n        break;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Engine;\r\n"
            }
          },
          {
            "EyudQbUb0e": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\interface.js",
              "source": "'use strict';\r\nclass IParser {\r\n  /**\r\n   * @constructor\r\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\r\n   */\r\n  constructor(options) {\r\n    this.options = options.parser ? options.parser() : options;\r\n  }\r\n  /**\r\n   * Parses the sources' comments into the desired output.\r\n   * @param  {Array<Object>} results - The files to parse.\r\n   * @return {Array<Object>} - The parsed comments.\r\n   */\r\n  /* eslint-disable no-unused-vars */\r\n  parse(sources) {\r\n    // ...\r\n  }\r\n  /* eslint-enable no-unused-vars */\r\n}\r\n\r\nmodule.exports = IParser;\r\n"
            }
          },
          {
            "4JF_XW8Z0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\compilers\\json\\index.js",
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "4yc_7bIZ0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\javascript\\index.js",
              "source": "'use strict';\r\n\r\nconst Doctrine = require('doctrine');\r\nconst IParser = require('../interface');\r\nconst Engine = require('../../engines/javascript.engine.js');\r\nconst _ = require('lodash');\r\nconst Log = require('mr-doc-utils').Log;\r\nconst log = new Log();\r\nconst synonyms = require('./synonyms.js');\r\n\r\nclass JavaScript extends IParser {\r\n  constructor(options) {\r\n    super(options);\r\n    this.visited = {};\r\n    this.engine = new Engine(this.options);\r\n    this.comments = [];\r\n    this.results = [];\r\n  }\r\n  /**\r\n   * Parse the file.\r\n   * @param {Object} - The file to parse.\r\n   */\r\n  parse(file) {\r\n    this.file = file;\r\n    this.ast = this.engine.parse(this.file);\r\n    // DEBUG: AST\r\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\r\n    [\r\n      { type: 'leadingComments', context: true },\r\n      { type: 'innerComments', context: false },\r\n      { type: 'trailingComments', context: false },\r\n    ].forEach(comment => this.walkComments(comment));\r\n    return this.results;\r\n  }\r\n  /**\r\n   * Walk the comments.\r\n   * @param {Object} - The comment type and context to walk.\r\n   */\r\n  walkComments(comment) {\r\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\r\n        .filter(this.isJSDocComment)\r\n        .forEach(this.parseComment(node, comment.context)));\r\n  }\r\n  /**\r\n   * Parse the comment.\r\n   * @param {Node} - The current node.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseComment(node, includeContext) {\r\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\r\n    range = !range ? node.range : range;\r\n    range = !range ? [node.start, node.end] : range;\r\n    const context = {\r\n      code: null,\r\n      file: this.file,\r\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\r\n      range: {\r\n        column: [node.loc.start.column, node.loc.end.column],\r\n        line: [node.loc.start.line, node.loc.end.line],\r\n      },\r\n    };\r\n    return (comment) => {\r\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\r\n      if (!this.visited[key]) {\r\n        this.visited[key] = true;\r\n        if (includeContext) {\r\n          Object.defineProperty(context, 'ast', {\r\n            enumerable: false,\r\n            value: node,\r\n          });\r\n          context.code = this.file.source.substring.apply(this.file.source, range);\r\n        }\r\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\r\n      }\r\n    };\r\n  }\r\n  /**\r\n   * Parse the JSDoc comment.\r\n   * @param {String} - The comment to parse.\r\n   * @param {Location} - The comment location.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseJSDoc(comment, loc, context) {\r\n    const result = Doctrine.parse(comment, {\r\n      lineNumbers: true,\r\n      recoverable: true,\r\n      sloppy: true,\r\n      unwrap: true,\r\n    });\r\n    result.loc = loc;\r\n    result.context = context;\r\n    result.errors = [];\r\n    let i = 0;\r\n    while (i < result.tags.length) {\r\n      const tag = result.tags[i];\r\n      if (tag.errors) {\r\n        for (let j = 0; j < tag.errors.length; j++) {\r\n          result.errors.push({ message: tag.errors[j] });\r\n        }\r\n        result.tags.splice(i, 1);\r\n      } else i++;\r\n    }\r\n    return JavaScript.normalize(result);\r\n  }\r\n  /**\r\n   * Determine whether the comment is normalized.\r\n   * @param {String} - The comment to determine.\r\n   * @return {Boolean} - The truth value.\r\n   */\r\n  isJSDocComment(comment) {\r\n    const asterisks = comment.value.match(/^(\\*+)/);\r\n    return (comment.type === 'CommentBlock' ||\r\n      comment.type === 'Block')\r\n      && asterisks && asterisks[1].length === 1;\r\n  }\r\n  /**\r\n   * Normalize the comment tags.\r\n   * @param {Array} - The comment to normalize.\r\n   * @return {Array} - The comment containing normalized tags.\r\n   */\r\n  static normalize(comment) {\r\n    return _.assignIn({}, comment, {\r\n      tags: comment.tags.map(tag => {\r\n        let title = tag.title.toLowerCase();\r\n        const canonical = synonyms[title];\r\n        if (!canonical) {\r\n          switch (title[0]) {\r\n            case 'e':\r\n              if (title === 'extend') title = 'extends';\r\n              break;\r\n            case 'j':\r\n              if (title === 'jsfiddles') title = 'jsfiddle';\r\n              break;\r\n            default: break;\r\n          }\r\n        }\r\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\r\n      }),\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = JavaScript;\r\n"
            }
          },
          {
            "VkjOmWLbAl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\javascript\\synonyms.js",
              "source": "module.exports = {\r\n  arg: 'param',\r\n  argument: 'param',\r\n  constructor: 'class',\r\n  const: 'constant',\r\n  defaultvalue: 'default',\r\n  desc: 'description',\r\n  emits: 'fires',\r\n  exception: 'throws',\r\n  fileoverview: 'file',\r\n  func: 'function',\r\n  host: 'external',\r\n  linkcode: 'link',\r\n  linkplain: 'link',\r\n  virtual: 'abstract',\r\n  method: 'function',\r\n  overview: 'file',\r\n  prop: 'property',\r\n  return: 'returns',\r\n  var: 'member',\r\n};\r\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 49,
          "column": 2
        },
        "end": {
          "line": 76,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          49,
          76
        ]
      }
    }
  },
  {
    "description": "Parse the JSDoc comment.",
    "tags": [
      {
        "title": "param",
        "description": "The comment to parse.",
        "lineNumber": 2,
        "type": null,
        "name": "String"
      },
      {
        "title": "param",
        "description": "The comment location.",
        "lineNumber": 3,
        "type": null,
        "name": "Location"
      },
      {
        "title": "param",
        "description": "The truth value on whether to include the context.",
        "lineNumber": 4,
        "type": null,
        "name": "Boolean"
      }
    ],
    "loc": {
      "start": {
        "line": 77,
        "column": 2
      },
      "end": {
        "line": 82,
        "column": 5
      }
    },
    "context": {
      "code": "parseJSDoc(comment, loc, context) {\r\n    const result = Doctrine.parse(comment, {\r\n      lineNumbers: true,\r\n      recoverable: true,\r\n      sloppy: true,\r\n      unwrap: true,\r\n    });\r\n    result.loc = loc;\r\n    result.context = context;\r\n    result.errors = [];\r\n    let i = 0;\r\n    while (i < result.tags.length) {\r\n      const tag = result.tags[i];\r\n      if (tag.errors) {\r\n        for (let j = 0; j < tag.errors.length; j++) {\r\n          result.errors.push({ message: tag.errors[j] });\r\n        }\r\n        result.tags.splice(i, 1);\r\n      } else i++;\r\n    }\r\n    return JavaScript.normalize(result);\r\n  }",
      "file": {
        "id": "4yc_7bIZ0l",
        "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
        "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
        "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\javascript\\index.js",
        "source": "'use strict';\r\n\r\nconst Doctrine = require('doctrine');\r\nconst IParser = require('../interface');\r\nconst Engine = require('../../engines/javascript.engine.js');\r\nconst _ = require('lodash');\r\nconst Log = require('mr-doc-utils').Log;\r\nconst log = new Log();\r\nconst synonyms = require('./synonyms.js');\r\n\r\nclass JavaScript extends IParser {\r\n  constructor(options) {\r\n    super(options);\r\n    this.visited = {};\r\n    this.engine = new Engine(this.options);\r\n    this.comments = [];\r\n    this.results = [];\r\n  }\r\n  /**\r\n   * Parse the file.\r\n   * @param {Object} - The file to parse.\r\n   */\r\n  parse(file) {\r\n    this.file = file;\r\n    this.ast = this.engine.parse(this.file);\r\n    // DEBUG: AST\r\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\r\n    [\r\n      { type: 'leadingComments', context: true },\r\n      { type: 'innerComments', context: false },\r\n      { type: 'trailingComments', context: false },\r\n    ].forEach(comment => this.walkComments(comment));\r\n    return this.results;\r\n  }\r\n  /**\r\n   * Walk the comments.\r\n   * @param {Object} - The comment type and context to walk.\r\n   */\r\n  walkComments(comment) {\r\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\r\n        .filter(this.isJSDocComment)\r\n        .forEach(this.parseComment(node, comment.context)));\r\n  }\r\n  /**\r\n   * Parse the comment.\r\n   * @param {Node} - The current node.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseComment(node, includeContext) {\r\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\r\n    range = !range ? node.range : range;\r\n    range = !range ? [node.start, node.end] : range;\r\n    const context = {\r\n      code: null,\r\n      file: this.file,\r\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\r\n      range: {\r\n        column: [node.loc.start.column, node.loc.end.column],\r\n        line: [node.loc.start.line, node.loc.end.line],\r\n      },\r\n    };\r\n    return (comment) => {\r\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\r\n      if (!this.visited[key]) {\r\n        this.visited[key] = true;\r\n        if (includeContext) {\r\n          Object.defineProperty(context, 'ast', {\r\n            enumerable: false,\r\n            value: node,\r\n          });\r\n          context.code = this.file.source.substring.apply(this.file.source, range);\r\n        }\r\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\r\n      }\r\n    };\r\n  }\r\n  /**\r\n   * Parse the JSDoc comment.\r\n   * @param {String} - The comment to parse.\r\n   * @param {Location} - The comment location.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseJSDoc(comment, loc, context) {\r\n    const result = Doctrine.parse(comment, {\r\n      lineNumbers: true,\r\n      recoverable: true,\r\n      sloppy: true,\r\n      unwrap: true,\r\n    });\r\n    result.loc = loc;\r\n    result.context = context;\r\n    result.errors = [];\r\n    let i = 0;\r\n    while (i < result.tags.length) {\r\n      const tag = result.tags[i];\r\n      if (tag.errors) {\r\n        for (let j = 0; j < tag.errors.length; j++) {\r\n          result.errors.push({ message: tag.errors[j] });\r\n        }\r\n        result.tags.splice(i, 1);\r\n      } else i++;\r\n    }\r\n    return JavaScript.normalize(result);\r\n  }\r\n  /**\r\n   * Determine whether the comment is normalized.\r\n   * @param {String} - The comment to determine.\r\n   * @return {Boolean} - The truth value.\r\n   */\r\n  isJSDocComment(comment) {\r\n    const asterisks = comment.value.match(/^(\\*+)/);\r\n    return (comment.type === 'CommentBlock' ||\r\n      comment.type === 'Block')\r\n      && asterisks && asterisks[1].length === 1;\r\n  }\r\n  /**\r\n   * Normalize the comment tags.\r\n   * @param {Array} - The comment to normalize.\r\n   * @return {Array} - The comment containing normalized tags.\r\n   */\r\n  static normalize(comment) {\r\n    return _.assignIn({}, comment, {\r\n      tags: comment.tags.map(tag => {\r\n        let title = tag.title.toLowerCase();\r\n        const canonical = synonyms[title];\r\n        if (!canonical) {\r\n          switch (title[0]) {\r\n            case 'e':\r\n              if (title === 'extend') title = 'extends';\r\n              break;\r\n            case 'j':\r\n              if (title === 'jsfiddles') title = 'jsfiddle';\r\n              break;\r\n            default: break;\r\n          }\r\n        }\r\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\r\n      }),\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = JavaScript;\r\n",
        "ref": [
          {
            "E1_QbLZRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\cli\\index.js",
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\nconst Extension = require('../utils/extension');\r\nconst File = require('fs-extra');\r\nconst Log = require('../utils/log');\r\nconst Liftoff = require('liftoff');\r\nconst Option = require('mr-doc-utils').Option;\r\nconst Path = require('path');\r\nconst Promise = require('bluebird');\r\nconst Yargs = require('yargs');\r\nconst ViynlFS = require('vinyl-fs');\r\nconst isGlob = require('is-glob');\r\nconst log = Log.global();\r\nconst pkg = require('../../package.json');\r\nconst rc = require('rc');\r\nconst _ = require('lodash');\r\n\r\nclass CLI {\r\n  /**\r\n   * Parse the CLI arguments.\r\n   * @static\r\n   */\r\n  static parse() {\r\n    return Yargs\r\n    .usage('Usage: mrdoc [options]', Option.cli())\r\n    .showHelpOnFail(false, 'Specify --help for available options')\r\n    .help('help', log.color.gray('Show help.'))\r\n    .alias('help', 'h')\r\n    .argv;\r\n  }\r\n  /**\r\n   * Create the CLI.\r\n   * @static\r\n   * @return {Liftoff} - An instance of Liftoff.\r\n   */\r\n  static get rocket() {\r\n    // Create the CLI.\r\n    return new Liftoff({\r\n      name: 'mrdoc',\r\n      processTitle: 'mrdoc',\r\n      v8flags: require('v8flags'),\r\n    });\r\n  }\r\n  /**\r\n   * Launch the cli.\r\n   * @static\r\n   * @param {Object} - The parsed CLI arguments.\r\n   * @return {Promise<Stream>} - A promise to the stream.\r\n   */\r\n  static launch(argv) {\r\n    return new Promise((resolve, reject) => {\r\n      // Launch the CLI!\r\n      CLI.rocket.launch({\r\n        cwd: argv.cwd,\r\n        configPath: argv.mrdocrc,\r\n      }, env => CLI.handler(env, argv)\r\n      .then(stream => resolve(stream))\r\n      .catch(error => reject(error)));\r\n    });\r\n  }\r\n  /**\r\n   * Handles the result from the CLI.\r\n   * @static\r\n   */\r\n  static handler(env, options) {\r\n    const version = options.version || options.v;\r\n    const source = options.source || options.s;\r\n    if (version) {\r\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\r\n      process.exit();\r\n    }\r\n    if (_.isEmpty(source) && version === false) {\r\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\r\n      process.exit();\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      // Get the options.\r\n      const opts = rc('mrdoc', Option.merge(options));\r\n      const sources = opts.mrdoc.source.split(',')\r\n      .map(path => path.trim())\r\n      .map(path => {\r\n        // Check if the path is not in glob pattern.\r\n        if (!isGlob(path)) {\r\n          // Make sure the path is resolved.\r\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\r\n          // Check if the path is a file or directory.\r\n          if (_.isEmpty(Path.parse(path).ext)) {\r\n            // Check if the path has a '/' at the end.\r\n            str = str[str.length - 1] === Path.sep ?\r\n            str : `${str}${Path.sep}`;\r\n          }\r\n          // Make sure the file or directory exists;\r\n          if (File.existsSync(str)) {\r\n            // Check if the directory has sub-directories.\r\n            const hasSubDirs = File.readdirSync(str)\r\n            .filter(file =>\r\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\r\n            // Get the file extension.\r\n            const extension = Extension.find(opts.parser.language);\r\n            // Set the glob pattern based on 'hasSubDirs'.\r\n            str = hasSubDirs ?\r\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\r\n          } else return null;\r\n          return str;\r\n        }\r\n        return path;\r\n      });\r\n      // DEBUG: Sources\r\n      log.debug(log.color.blue('Sources:'), sources);\r\n      if (sources.indexOf(null) > -1) {\r\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\r\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = CLI;\r\n"
            }
          },
          {
            "EkedmbI-Rg": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\index.js",
              "source": "'use strict';\r\nconst JSONC = require('./compilers/json/');\r\n// const HTML = require('./compilers/html');\r\n\r\nclass Compiler {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.compiler().file.format) {\r\n      case 'json':\r\n        return (new JSONC(this.options));\r\n      case 'html':\r\n        // return (new HTML(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Compiler;\r\n"
            }
          },
          {
            "VJZdXZU-Ae": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\index.js",
              "source": "'use strict';\r\nconst JavaScript = require('./parsers/javascript/');\r\n\r\nclass Parser {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.parser().language) {\r\n      case 'js':\r\n      case 'javascript':\r\n        return (new JavaScript(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Parser;\r\n"
            }
          },
          {
            "VkzumbIW0x": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\extension.js",
              "source": "'use strict';\r\n\r\nclass Extension {\r\n  static find(language) {\r\n    return Extension.extensions()[language];\r\n  }\r\n  static extensions() {\r\n    return {\r\n      js: '.js',\r\n      javascript: '.js',\r\n      json: '.json',\r\n      html: '.html',\r\n      typescript: '.ts',\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = Extension;\r\n"
            }
          },
          {
            "EJ7uQ-L-Al": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\log.js",
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\n/* eslint-env node */\r\nconst Utils = require('mr-doc-utils');\r\nconst log = new Utils.Log();\r\nconst _ = require('lodash');\r\n\r\nclass Log {\r\n  constructor(options) {\r\n    if (options.silent) {\r\n      log.on('error', () => { /* NOOP */});\r\n      return log;\r\n    }\r\n    this.levels(options.level)\r\n    .forEach(level => {\r\n      if (level === 'error') this.error();\r\n      else this.other(level);\r\n    });\r\n    return log;\r\n  }\r\n  levels(level) {\r\n    const levels = _.isString(level) ? level.split(',') : level;\r\n    return levels\r\n    .map(i => i.replace(/\\s/g, ''));\r\n  }\r\n  error() {\r\n    log.on('error', function error() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args.map(i => log.color.red(i)));\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  other(level) {\r\n    log.on(level, function logger() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args);\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  /**\r\n   * Get the global instance of Log.\r\n   * @return {Log} - An instance of Log.\r\n   */\r\n  static global() {\r\n    log.color = Utils.Log.color;\r\n    return log;\r\n  }\r\n}\r\n\r\nmodule.exports = Log;\r\n"
            }
          },
          {
            "V1V_7WIWAg": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\output.js",
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nconst Option = require('mr-doc-utils').Option;\n\nclass Output {\n  static handler(options, buffer) {\n    const opt = (new Option(options)).options();\n    return function (callback) {\n      Output.format(opt, buffer).forEach(Output.toStream(opt, this));\n      callback();\n    };\n  }\n  static format(options, buffer) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler().file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n\n  static toStream(options, context) {\n    const format = options.compiler().file.format;\n    const file = options.compiler().file;\n    return function (f) {\n      if (format === 'json' || format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "EJSdQZI-Ce": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\source.js",
              "source": "'use strict';\r\nconst ShortID = require('shortid');\r\nconst File = require('fs-extra');\r\nconst _ = require('lodash');\r\n\r\nclass Source {\r\n  static create(files) {\r\n    // Process the files.\r\n    const result = files\r\n    .map(file => Source.processFile(file));\r\n    // Create references for each file.\r\n    const references = result\r\n    .map(file => Source.createReference(file));\r\n    // Process the references and attach it to each file.\r\n    return result\r\n    .map(file => Source.processReference(file, references));\r\n  }\r\n  static processFile(file) {\r\n    return {\r\n      id: ShortID.generate(),\r\n      cwd: file.cwd,\r\n      base: file.base,\r\n      path: file.path,\r\n      source: File.readFileSync(file.path, 'utf8'),\r\n      comments: undefined,\r\n    };\r\n  }\r\n  static createReference(file) {\r\n    return {\r\n      id: file.id,\r\n      cwd: file.cwd,\r\n      base: file.base,\r\n      path: file.path,\r\n      source: file.source,\r\n      comments: file.comments,\r\n    };\r\n  }\r\n  static processReference(file, references) {\r\n    return _.merge(file, {\r\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = Source;\r\n"
            }
          },
          {
            "VJU_QZUb0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\compilers\\interface.js",
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.compiler() : options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "VyPuX-LbCx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\engines\\javascript.engine.js",
              "source": "'use strict';\r\n\r\nconst Babylon = require('babylon');\r\nconst Acorn = require('acorn');\r\nconst Espree = require('espree');\r\nconst ESCodeGen = require('escodegen');\r\nconst ESTraverse = require('estraverse');\r\nconst traverse = require('babel-traverse').default;\r\n\r\nconst opts = {\r\n  acorn: (version, comments, tokens) => ({\r\n    ecmaVersion: version,\r\n    locations: true,\r\n    onComment: comments,\r\n    onToken: tokens,\r\n    ranges: true,\r\n  }),\r\n  babylon: () => ({\r\n    allowImportExportEverywhere: true,\r\n    plugins: [\r\n      'jsx',\r\n      'flow',\r\n      'asyncFunctions',\r\n      'classConstructorCall',\r\n      'doExpressions',\r\n      'trailingFunctionCommas',\r\n      'objectRestSpread',\r\n      'decorators',\r\n      'classProperties',\r\n      'exportExtensions',\r\n      'exponentiationOperator',\r\n      'asyncGenerators',\r\n      'functionBind',\r\n      'functionSent',\r\n    ],\r\n    sourceType: 'module',\r\n  }),\r\n  espree: (version) => ({\r\n    attachComment: true,\r\n    comment: true,\r\n    ecmaFeatures: {\r\n      experimentalObjectRestSpread: true,\r\n      globalReturn: true,\r\n      impliedStrict: true,\r\n      jsx: true,\r\n    },\r\n    ecmaVersion: version,\r\n    loc: true,\r\n    range: true,\r\n    sourceType: 'module',\r\n    tokens: true,\r\n  }),\r\n};\r\n\r\nclass Engine {\r\n  constructor(options) {\r\n    this.options = options;\r\n    switch (this.options.engine) {\r\n      case 'acorn':\r\n        this.engine = Acorn;\r\n        break;\r\n      case 'espree':\r\n        this.engine = Espree;\r\n        break;\r\n      default:\r\n        this.engine = Babylon;\r\n        break;\r\n    }\r\n  }\r\n  parse(file) {\r\n    const comments = [];\r\n    const tokens = [];\r\n    try {\r\n      switch (this.options.engine) {\r\n        case 'acorn':\r\n          return ESCodeGen\r\n          .attachComments(this.engine.parse(file.source,\r\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\r\n        case 'espree':\r\n          return this.engine.parse(file.source, opts.espree(this.options.version));\r\n        default:\r\n          return this.engine.parse(file.source, opts.babylon());\r\n      }\r\n    } catch (error) {\r\n      throw (new Error(error));\r\n    }\r\n  }\r\n  static traverse(options, ast, callback) {\r\n    switch (options.engine) {\r\n      case 'babylon':\r\n        traverse(ast, {\r\n          enter: (path) => {\r\n            const node = path.node;\r\n            callback(node);\r\n          } });\r\n        break;\r\n      default:\r\n        ESTraverse.traverse(ast, {\r\n          /* eslint-disable no-param-reassign */\r\n          enter: (node) => {\r\n            if (node.type === 'Program') {\r\n              node = node.body[0];\r\n            }\r\n            callback(node);\r\n          } });\r\n          /* eslint-enable no-param-reassign */\r\n        break;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Engine;\r\n"
            }
          },
          {
            "EyudQbUb0e": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\interface.js",
              "source": "'use strict';\r\nclass IParser {\r\n  /**\r\n   * @constructor\r\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\r\n   */\r\n  constructor(options) {\r\n    this.options = options.parser ? options.parser() : options;\r\n  }\r\n  /**\r\n   * Parses the sources' comments into the desired output.\r\n   * @param  {Array<Object>} results - The files to parse.\r\n   * @return {Array<Object>} - The parsed comments.\r\n   */\r\n  /* eslint-disable no-unused-vars */\r\n  parse(sources) {\r\n    // ...\r\n  }\r\n  /* eslint-enable no-unused-vars */\r\n}\r\n\r\nmodule.exports = IParser;\r\n"
            }
          },
          {
            "4JF_XW8Z0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\compilers\\json\\index.js",
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "4yc_7bIZ0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\javascript\\index.js",
              "source": "'use strict';\r\n\r\nconst Doctrine = require('doctrine');\r\nconst IParser = require('../interface');\r\nconst Engine = require('../../engines/javascript.engine.js');\r\nconst _ = require('lodash');\r\nconst Log = require('mr-doc-utils').Log;\r\nconst log = new Log();\r\nconst synonyms = require('./synonyms.js');\r\n\r\nclass JavaScript extends IParser {\r\n  constructor(options) {\r\n    super(options);\r\n    this.visited = {};\r\n    this.engine = new Engine(this.options);\r\n    this.comments = [];\r\n    this.results = [];\r\n  }\r\n  /**\r\n   * Parse the file.\r\n   * @param {Object} - The file to parse.\r\n   */\r\n  parse(file) {\r\n    this.file = file;\r\n    this.ast = this.engine.parse(this.file);\r\n    // DEBUG: AST\r\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\r\n    [\r\n      { type: 'leadingComments', context: true },\r\n      { type: 'innerComments', context: false },\r\n      { type: 'trailingComments', context: false },\r\n    ].forEach(comment => this.walkComments(comment));\r\n    return this.results;\r\n  }\r\n  /**\r\n   * Walk the comments.\r\n   * @param {Object} - The comment type and context to walk.\r\n   */\r\n  walkComments(comment) {\r\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\r\n        .filter(this.isJSDocComment)\r\n        .forEach(this.parseComment(node, comment.context)));\r\n  }\r\n  /**\r\n   * Parse the comment.\r\n   * @param {Node} - The current node.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseComment(node, includeContext) {\r\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\r\n    range = !range ? node.range : range;\r\n    range = !range ? [node.start, node.end] : range;\r\n    const context = {\r\n      code: null,\r\n      file: this.file,\r\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\r\n      range: {\r\n        column: [node.loc.start.column, node.loc.end.column],\r\n        line: [node.loc.start.line, node.loc.end.line],\r\n      },\r\n    };\r\n    return (comment) => {\r\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\r\n      if (!this.visited[key]) {\r\n        this.visited[key] = true;\r\n        if (includeContext) {\r\n          Object.defineProperty(context, 'ast', {\r\n            enumerable: false,\r\n            value: node,\r\n          });\r\n          context.code = this.file.source.substring.apply(this.file.source, range);\r\n        }\r\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\r\n      }\r\n    };\r\n  }\r\n  /**\r\n   * Parse the JSDoc comment.\r\n   * @param {String} - The comment to parse.\r\n   * @param {Location} - The comment location.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseJSDoc(comment, loc, context) {\r\n    const result = Doctrine.parse(comment, {\r\n      lineNumbers: true,\r\n      recoverable: true,\r\n      sloppy: true,\r\n      unwrap: true,\r\n    });\r\n    result.loc = loc;\r\n    result.context = context;\r\n    result.errors = [];\r\n    let i = 0;\r\n    while (i < result.tags.length) {\r\n      const tag = result.tags[i];\r\n      if (tag.errors) {\r\n        for (let j = 0; j < tag.errors.length; j++) {\r\n          result.errors.push({ message: tag.errors[j] });\r\n        }\r\n        result.tags.splice(i, 1);\r\n      } else i++;\r\n    }\r\n    return JavaScript.normalize(result);\r\n  }\r\n  /**\r\n   * Determine whether the comment is normalized.\r\n   * @param {String} - The comment to determine.\r\n   * @return {Boolean} - The truth value.\r\n   */\r\n  isJSDocComment(comment) {\r\n    const asterisks = comment.value.match(/^(\\*+)/);\r\n    return (comment.type === 'CommentBlock' ||\r\n      comment.type === 'Block')\r\n      && asterisks && asterisks[1].length === 1;\r\n  }\r\n  /**\r\n   * Normalize the comment tags.\r\n   * @param {Array} - The comment to normalize.\r\n   * @return {Array} - The comment containing normalized tags.\r\n   */\r\n  static normalize(comment) {\r\n    return _.assignIn({}, comment, {\r\n      tags: comment.tags.map(tag => {\r\n        let title = tag.title.toLowerCase();\r\n        const canonical = synonyms[title];\r\n        if (!canonical) {\r\n          switch (title[0]) {\r\n            case 'e':\r\n              if (title === 'extend') title = 'extends';\r\n              break;\r\n            case 'j':\r\n              if (title === 'jsfiddles') title = 'jsfiddle';\r\n              break;\r\n            default: break;\r\n          }\r\n        }\r\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\r\n      }),\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = JavaScript;\r\n"
            }
          },
          {
            "VkjOmWLbAl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\javascript\\synonyms.js",
              "source": "module.exports = {\r\n  arg: 'param',\r\n  argument: 'param',\r\n  constructor: 'class',\r\n  const: 'constant',\r\n  defaultvalue: 'default',\r\n  desc: 'description',\r\n  emits: 'fires',\r\n  exception: 'throws',\r\n  fileoverview: 'file',\r\n  func: 'function',\r\n  host: 'external',\r\n  linkcode: 'link',\r\n  linkplain: 'link',\r\n  virtual: 'abstract',\r\n  method: 'function',\r\n  overview: 'file',\r\n  prop: 'property',\r\n  return: 'returns',\r\n  var: 'member',\r\n};\r\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 83,
          "column": 2
        },
        "end": {
          "line": 104,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          83,
          104
        ]
      }
    }
  },
  {
    "description": "Determine whether the comment is normalized.",
    "tags": [
      {
        "title": "param",
        "description": "The comment to determine.",
        "lineNumber": 2,
        "type": null,
        "name": "String"
      },
      {
        "title": "returns",
        "description": "The truth value.",
        "lineNumber": 3,
        "type": {
          "type": "NameExpression",
          "name": "Boolean"
        }
      }
    ],
    "loc": {
      "start": {
        "line": 105,
        "column": 2
      },
      "end": {
        "line": 109,
        "column": 5
      }
    },
    "context": {
      "code": "isJSDocComment(comment) {\r\n    const asterisks = comment.value.match(/^(\\*+)/);\r\n    return (comment.type === 'CommentBlock' ||\r\n      comment.type === 'Block')\r\n      && asterisks && asterisks[1].length === 1;\r\n  }",
      "file": {
        "id": "4yc_7bIZ0l",
        "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
        "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
        "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\javascript\\index.js",
        "source": "'use strict';\r\n\r\nconst Doctrine = require('doctrine');\r\nconst IParser = require('../interface');\r\nconst Engine = require('../../engines/javascript.engine.js');\r\nconst _ = require('lodash');\r\nconst Log = require('mr-doc-utils').Log;\r\nconst log = new Log();\r\nconst synonyms = require('./synonyms.js');\r\n\r\nclass JavaScript extends IParser {\r\n  constructor(options) {\r\n    super(options);\r\n    this.visited = {};\r\n    this.engine = new Engine(this.options);\r\n    this.comments = [];\r\n    this.results = [];\r\n  }\r\n  /**\r\n   * Parse the file.\r\n   * @param {Object} - The file to parse.\r\n   */\r\n  parse(file) {\r\n    this.file = file;\r\n    this.ast = this.engine.parse(this.file);\r\n    // DEBUG: AST\r\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\r\n    [\r\n      { type: 'leadingComments', context: true },\r\n      { type: 'innerComments', context: false },\r\n      { type: 'trailingComments', context: false },\r\n    ].forEach(comment => this.walkComments(comment));\r\n    return this.results;\r\n  }\r\n  /**\r\n   * Walk the comments.\r\n   * @param {Object} - The comment type and context to walk.\r\n   */\r\n  walkComments(comment) {\r\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\r\n        .filter(this.isJSDocComment)\r\n        .forEach(this.parseComment(node, comment.context)));\r\n  }\r\n  /**\r\n   * Parse the comment.\r\n   * @param {Node} - The current node.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseComment(node, includeContext) {\r\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\r\n    range = !range ? node.range : range;\r\n    range = !range ? [node.start, node.end] : range;\r\n    const context = {\r\n      code: null,\r\n      file: this.file,\r\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\r\n      range: {\r\n        column: [node.loc.start.column, node.loc.end.column],\r\n        line: [node.loc.start.line, node.loc.end.line],\r\n      },\r\n    };\r\n    return (comment) => {\r\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\r\n      if (!this.visited[key]) {\r\n        this.visited[key] = true;\r\n        if (includeContext) {\r\n          Object.defineProperty(context, 'ast', {\r\n            enumerable: false,\r\n            value: node,\r\n          });\r\n          context.code = this.file.source.substring.apply(this.file.source, range);\r\n        }\r\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\r\n      }\r\n    };\r\n  }\r\n  /**\r\n   * Parse the JSDoc comment.\r\n   * @param {String} - The comment to parse.\r\n   * @param {Location} - The comment location.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseJSDoc(comment, loc, context) {\r\n    const result = Doctrine.parse(comment, {\r\n      lineNumbers: true,\r\n      recoverable: true,\r\n      sloppy: true,\r\n      unwrap: true,\r\n    });\r\n    result.loc = loc;\r\n    result.context = context;\r\n    result.errors = [];\r\n    let i = 0;\r\n    while (i < result.tags.length) {\r\n      const tag = result.tags[i];\r\n      if (tag.errors) {\r\n        for (let j = 0; j < tag.errors.length; j++) {\r\n          result.errors.push({ message: tag.errors[j] });\r\n        }\r\n        result.tags.splice(i, 1);\r\n      } else i++;\r\n    }\r\n    return JavaScript.normalize(result);\r\n  }\r\n  /**\r\n   * Determine whether the comment is normalized.\r\n   * @param {String} - The comment to determine.\r\n   * @return {Boolean} - The truth value.\r\n   */\r\n  isJSDocComment(comment) {\r\n    const asterisks = comment.value.match(/^(\\*+)/);\r\n    return (comment.type === 'CommentBlock' ||\r\n      comment.type === 'Block')\r\n      && asterisks && asterisks[1].length === 1;\r\n  }\r\n  /**\r\n   * Normalize the comment tags.\r\n   * @param {Array} - The comment to normalize.\r\n   * @return {Array} - The comment containing normalized tags.\r\n   */\r\n  static normalize(comment) {\r\n    return _.assignIn({}, comment, {\r\n      tags: comment.tags.map(tag => {\r\n        let title = tag.title.toLowerCase();\r\n        const canonical = synonyms[title];\r\n        if (!canonical) {\r\n          switch (title[0]) {\r\n            case 'e':\r\n              if (title === 'extend') title = 'extends';\r\n              break;\r\n            case 'j':\r\n              if (title === 'jsfiddles') title = 'jsfiddle';\r\n              break;\r\n            default: break;\r\n          }\r\n        }\r\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\r\n      }),\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = JavaScript;\r\n",
        "ref": [
          {
            "E1_QbLZRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\cli\\index.js",
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\nconst Extension = require('../utils/extension');\r\nconst File = require('fs-extra');\r\nconst Log = require('../utils/log');\r\nconst Liftoff = require('liftoff');\r\nconst Option = require('mr-doc-utils').Option;\r\nconst Path = require('path');\r\nconst Promise = require('bluebird');\r\nconst Yargs = require('yargs');\r\nconst ViynlFS = require('vinyl-fs');\r\nconst isGlob = require('is-glob');\r\nconst log = Log.global();\r\nconst pkg = require('../../package.json');\r\nconst rc = require('rc');\r\nconst _ = require('lodash');\r\n\r\nclass CLI {\r\n  /**\r\n   * Parse the CLI arguments.\r\n   * @static\r\n   */\r\n  static parse() {\r\n    return Yargs\r\n    .usage('Usage: mrdoc [options]', Option.cli())\r\n    .showHelpOnFail(false, 'Specify --help for available options')\r\n    .help('help', log.color.gray('Show help.'))\r\n    .alias('help', 'h')\r\n    .argv;\r\n  }\r\n  /**\r\n   * Create the CLI.\r\n   * @static\r\n   * @return {Liftoff} - An instance of Liftoff.\r\n   */\r\n  static get rocket() {\r\n    // Create the CLI.\r\n    return new Liftoff({\r\n      name: 'mrdoc',\r\n      processTitle: 'mrdoc',\r\n      v8flags: require('v8flags'),\r\n    });\r\n  }\r\n  /**\r\n   * Launch the cli.\r\n   * @static\r\n   * @param {Object} - The parsed CLI arguments.\r\n   * @return {Promise<Stream>} - A promise to the stream.\r\n   */\r\n  static launch(argv) {\r\n    return new Promise((resolve, reject) => {\r\n      // Launch the CLI!\r\n      CLI.rocket.launch({\r\n        cwd: argv.cwd,\r\n        configPath: argv.mrdocrc,\r\n      }, env => CLI.handler(env, argv)\r\n      .then(stream => resolve(stream))\r\n      .catch(error => reject(error)));\r\n    });\r\n  }\r\n  /**\r\n   * Handles the result from the CLI.\r\n   * @static\r\n   */\r\n  static handler(env, options) {\r\n    const version = options.version || options.v;\r\n    const source = options.source || options.s;\r\n    if (version) {\r\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\r\n      process.exit();\r\n    }\r\n    if (_.isEmpty(source) && version === false) {\r\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\r\n      process.exit();\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      // Get the options.\r\n      const opts = rc('mrdoc', Option.merge(options));\r\n      const sources = opts.mrdoc.source.split(',')\r\n      .map(path => path.trim())\r\n      .map(path => {\r\n        // Check if the path is not in glob pattern.\r\n        if (!isGlob(path)) {\r\n          // Make sure the path is resolved.\r\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\r\n          // Check if the path is a file or directory.\r\n          if (_.isEmpty(Path.parse(path).ext)) {\r\n            // Check if the path has a '/' at the end.\r\n            str = str[str.length - 1] === Path.sep ?\r\n            str : `${str}${Path.sep}`;\r\n          }\r\n          // Make sure the file or directory exists;\r\n          if (File.existsSync(str)) {\r\n            // Check if the directory has sub-directories.\r\n            const hasSubDirs = File.readdirSync(str)\r\n            .filter(file =>\r\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\r\n            // Get the file extension.\r\n            const extension = Extension.find(opts.parser.language);\r\n            // Set the glob pattern based on 'hasSubDirs'.\r\n            str = hasSubDirs ?\r\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\r\n          } else return null;\r\n          return str;\r\n        }\r\n        return path;\r\n      });\r\n      // DEBUG: Sources\r\n      log.debug(log.color.blue('Sources:'), sources);\r\n      if (sources.indexOf(null) > -1) {\r\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\r\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = CLI;\r\n"
            }
          },
          {
            "EkedmbI-Rg": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\index.js",
              "source": "'use strict';\r\nconst JSONC = require('./compilers/json/');\r\n// const HTML = require('./compilers/html');\r\n\r\nclass Compiler {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.compiler().file.format) {\r\n      case 'json':\r\n        return (new JSONC(this.options));\r\n      case 'html':\r\n        // return (new HTML(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Compiler;\r\n"
            }
          },
          {
            "VJZdXZU-Ae": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\index.js",
              "source": "'use strict';\r\nconst JavaScript = require('./parsers/javascript/');\r\n\r\nclass Parser {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.parser().language) {\r\n      case 'js':\r\n      case 'javascript':\r\n        return (new JavaScript(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Parser;\r\n"
            }
          },
          {
            "VkzumbIW0x": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\extension.js",
              "source": "'use strict';\r\n\r\nclass Extension {\r\n  static find(language) {\r\n    return Extension.extensions()[language];\r\n  }\r\n  static extensions() {\r\n    return {\r\n      js: '.js',\r\n      javascript: '.js',\r\n      json: '.json',\r\n      html: '.html',\r\n      typescript: '.ts',\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = Extension;\r\n"
            }
          },
          {
            "EJ7uQ-L-Al": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\log.js",
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\n/* eslint-env node */\r\nconst Utils = require('mr-doc-utils');\r\nconst log = new Utils.Log();\r\nconst _ = require('lodash');\r\n\r\nclass Log {\r\n  constructor(options) {\r\n    if (options.silent) {\r\n      log.on('error', () => { /* NOOP */});\r\n      return log;\r\n    }\r\n    this.levels(options.level)\r\n    .forEach(level => {\r\n      if (level === 'error') this.error();\r\n      else this.other(level);\r\n    });\r\n    return log;\r\n  }\r\n  levels(level) {\r\n    const levels = _.isString(level) ? level.split(',') : level;\r\n    return levels\r\n    .map(i => i.replace(/\\s/g, ''));\r\n  }\r\n  error() {\r\n    log.on('error', function error() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args.map(i => log.color.red(i)));\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  other(level) {\r\n    log.on(level, function logger() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args);\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  /**\r\n   * Get the global instance of Log.\r\n   * @return {Log} - An instance of Log.\r\n   */\r\n  static global() {\r\n    log.color = Utils.Log.color;\r\n    return log;\r\n  }\r\n}\r\n\r\nmodule.exports = Log;\r\n"
            }
          },
          {
            "V1V_7WIWAg": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\output.js",
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nconst Option = require('mr-doc-utils').Option;\n\nclass Output {\n  static handler(options, buffer) {\n    const opt = (new Option(options)).options();\n    return function (callback) {\n      Output.format(opt, buffer).forEach(Output.toStream(opt, this));\n      callback();\n    };\n  }\n  static format(options, buffer) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler().file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n\n  static toStream(options, context) {\n    const format = options.compiler().file.format;\n    const file = options.compiler().file;\n    return function (f) {\n      if (format === 'json' || format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "EJSdQZI-Ce": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\source.js",
              "source": "'use strict';\r\nconst ShortID = require('shortid');\r\nconst File = require('fs-extra');\r\nconst _ = require('lodash');\r\n\r\nclass Source {\r\n  static create(files) {\r\n    // Process the files.\r\n    const result = files\r\n    .map(file => Source.processFile(file));\r\n    // Create references for each file.\r\n    const references = result\r\n    .map(file => Source.createReference(file));\r\n    // Process the references and attach it to each file.\r\n    return result\r\n    .map(file => Source.processReference(file, references));\r\n  }\r\n  static processFile(file) {\r\n    return {\r\n      id: ShortID.generate(),\r\n      cwd: file.cwd,\r\n      base: file.base,\r\n      path: file.path,\r\n      source: File.readFileSync(file.path, 'utf8'),\r\n      comments: undefined,\r\n    };\r\n  }\r\n  static createReference(file) {\r\n    return {\r\n      id: file.id,\r\n      cwd: file.cwd,\r\n      base: file.base,\r\n      path: file.path,\r\n      source: file.source,\r\n      comments: file.comments,\r\n    };\r\n  }\r\n  static processReference(file, references) {\r\n    return _.merge(file, {\r\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = Source;\r\n"
            }
          },
          {
            "VJU_QZUb0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\compilers\\interface.js",
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.compiler() : options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "VyPuX-LbCx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\engines\\javascript.engine.js",
              "source": "'use strict';\r\n\r\nconst Babylon = require('babylon');\r\nconst Acorn = require('acorn');\r\nconst Espree = require('espree');\r\nconst ESCodeGen = require('escodegen');\r\nconst ESTraverse = require('estraverse');\r\nconst traverse = require('babel-traverse').default;\r\n\r\nconst opts = {\r\n  acorn: (version, comments, tokens) => ({\r\n    ecmaVersion: version,\r\n    locations: true,\r\n    onComment: comments,\r\n    onToken: tokens,\r\n    ranges: true,\r\n  }),\r\n  babylon: () => ({\r\n    allowImportExportEverywhere: true,\r\n    plugins: [\r\n      'jsx',\r\n      'flow',\r\n      'asyncFunctions',\r\n      'classConstructorCall',\r\n      'doExpressions',\r\n      'trailingFunctionCommas',\r\n      'objectRestSpread',\r\n      'decorators',\r\n      'classProperties',\r\n      'exportExtensions',\r\n      'exponentiationOperator',\r\n      'asyncGenerators',\r\n      'functionBind',\r\n      'functionSent',\r\n    ],\r\n    sourceType: 'module',\r\n  }),\r\n  espree: (version) => ({\r\n    attachComment: true,\r\n    comment: true,\r\n    ecmaFeatures: {\r\n      experimentalObjectRestSpread: true,\r\n      globalReturn: true,\r\n      impliedStrict: true,\r\n      jsx: true,\r\n    },\r\n    ecmaVersion: version,\r\n    loc: true,\r\n    range: true,\r\n    sourceType: 'module',\r\n    tokens: true,\r\n  }),\r\n};\r\n\r\nclass Engine {\r\n  constructor(options) {\r\n    this.options = options;\r\n    switch (this.options.engine) {\r\n      case 'acorn':\r\n        this.engine = Acorn;\r\n        break;\r\n      case 'espree':\r\n        this.engine = Espree;\r\n        break;\r\n      default:\r\n        this.engine = Babylon;\r\n        break;\r\n    }\r\n  }\r\n  parse(file) {\r\n    const comments = [];\r\n    const tokens = [];\r\n    try {\r\n      switch (this.options.engine) {\r\n        case 'acorn':\r\n          return ESCodeGen\r\n          .attachComments(this.engine.parse(file.source,\r\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\r\n        case 'espree':\r\n          return this.engine.parse(file.source, opts.espree(this.options.version));\r\n        default:\r\n          return this.engine.parse(file.source, opts.babylon());\r\n      }\r\n    } catch (error) {\r\n      throw (new Error(error));\r\n    }\r\n  }\r\n  static traverse(options, ast, callback) {\r\n    switch (options.engine) {\r\n      case 'babylon':\r\n        traverse(ast, {\r\n          enter: (path) => {\r\n            const node = path.node;\r\n            callback(node);\r\n          } });\r\n        break;\r\n      default:\r\n        ESTraverse.traverse(ast, {\r\n          /* eslint-disable no-param-reassign */\r\n          enter: (node) => {\r\n            if (node.type === 'Program') {\r\n              node = node.body[0];\r\n            }\r\n            callback(node);\r\n          } });\r\n          /* eslint-enable no-param-reassign */\r\n        break;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Engine;\r\n"
            }
          },
          {
            "EyudQbUb0e": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\interface.js",
              "source": "'use strict';\r\nclass IParser {\r\n  /**\r\n   * @constructor\r\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\r\n   */\r\n  constructor(options) {\r\n    this.options = options.parser ? options.parser() : options;\r\n  }\r\n  /**\r\n   * Parses the sources' comments into the desired output.\r\n   * @param  {Array<Object>} results - The files to parse.\r\n   * @return {Array<Object>} - The parsed comments.\r\n   */\r\n  /* eslint-disable no-unused-vars */\r\n  parse(sources) {\r\n    // ...\r\n  }\r\n  /* eslint-enable no-unused-vars */\r\n}\r\n\r\nmodule.exports = IParser;\r\n"
            }
          },
          {
            "4JF_XW8Z0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\compilers\\json\\index.js",
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "4yc_7bIZ0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\javascript\\index.js",
              "source": "'use strict';\r\n\r\nconst Doctrine = require('doctrine');\r\nconst IParser = require('../interface');\r\nconst Engine = require('../../engines/javascript.engine.js');\r\nconst _ = require('lodash');\r\nconst Log = require('mr-doc-utils').Log;\r\nconst log = new Log();\r\nconst synonyms = require('./synonyms.js');\r\n\r\nclass JavaScript extends IParser {\r\n  constructor(options) {\r\n    super(options);\r\n    this.visited = {};\r\n    this.engine = new Engine(this.options);\r\n    this.comments = [];\r\n    this.results = [];\r\n  }\r\n  /**\r\n   * Parse the file.\r\n   * @param {Object} - The file to parse.\r\n   */\r\n  parse(file) {\r\n    this.file = file;\r\n    this.ast = this.engine.parse(this.file);\r\n    // DEBUG: AST\r\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\r\n    [\r\n      { type: 'leadingComments', context: true },\r\n      { type: 'innerComments', context: false },\r\n      { type: 'trailingComments', context: false },\r\n    ].forEach(comment => this.walkComments(comment));\r\n    return this.results;\r\n  }\r\n  /**\r\n   * Walk the comments.\r\n   * @param {Object} - The comment type and context to walk.\r\n   */\r\n  walkComments(comment) {\r\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\r\n        .filter(this.isJSDocComment)\r\n        .forEach(this.parseComment(node, comment.context)));\r\n  }\r\n  /**\r\n   * Parse the comment.\r\n   * @param {Node} - The current node.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseComment(node, includeContext) {\r\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\r\n    range = !range ? node.range : range;\r\n    range = !range ? [node.start, node.end] : range;\r\n    const context = {\r\n      code: null,\r\n      file: this.file,\r\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\r\n      range: {\r\n        column: [node.loc.start.column, node.loc.end.column],\r\n        line: [node.loc.start.line, node.loc.end.line],\r\n      },\r\n    };\r\n    return (comment) => {\r\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\r\n      if (!this.visited[key]) {\r\n        this.visited[key] = true;\r\n        if (includeContext) {\r\n          Object.defineProperty(context, 'ast', {\r\n            enumerable: false,\r\n            value: node,\r\n          });\r\n          context.code = this.file.source.substring.apply(this.file.source, range);\r\n        }\r\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\r\n      }\r\n    };\r\n  }\r\n  /**\r\n   * Parse the JSDoc comment.\r\n   * @param {String} - The comment to parse.\r\n   * @param {Location} - The comment location.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseJSDoc(comment, loc, context) {\r\n    const result = Doctrine.parse(comment, {\r\n      lineNumbers: true,\r\n      recoverable: true,\r\n      sloppy: true,\r\n      unwrap: true,\r\n    });\r\n    result.loc = loc;\r\n    result.context = context;\r\n    result.errors = [];\r\n    let i = 0;\r\n    while (i < result.tags.length) {\r\n      const tag = result.tags[i];\r\n      if (tag.errors) {\r\n        for (let j = 0; j < tag.errors.length; j++) {\r\n          result.errors.push({ message: tag.errors[j] });\r\n        }\r\n        result.tags.splice(i, 1);\r\n      } else i++;\r\n    }\r\n    return JavaScript.normalize(result);\r\n  }\r\n  /**\r\n   * Determine whether the comment is normalized.\r\n   * @param {String} - The comment to determine.\r\n   * @return {Boolean} - The truth value.\r\n   */\r\n  isJSDocComment(comment) {\r\n    const asterisks = comment.value.match(/^(\\*+)/);\r\n    return (comment.type === 'CommentBlock' ||\r\n      comment.type === 'Block')\r\n      && asterisks && asterisks[1].length === 1;\r\n  }\r\n  /**\r\n   * Normalize the comment tags.\r\n   * @param {Array} - The comment to normalize.\r\n   * @return {Array} - The comment containing normalized tags.\r\n   */\r\n  static normalize(comment) {\r\n    return _.assignIn({}, comment, {\r\n      tags: comment.tags.map(tag => {\r\n        let title = tag.title.toLowerCase();\r\n        const canonical = synonyms[title];\r\n        if (!canonical) {\r\n          switch (title[0]) {\r\n            case 'e':\r\n              if (title === 'extend') title = 'extends';\r\n              break;\r\n            case 'j':\r\n              if (title === 'jsfiddles') title = 'jsfiddle';\r\n              break;\r\n            default: break;\r\n          }\r\n        }\r\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\r\n      }),\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = JavaScript;\r\n"
            }
          },
          {
            "VkjOmWLbAl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\javascript\\synonyms.js",
              "source": "module.exports = {\r\n  arg: 'param',\r\n  argument: 'param',\r\n  constructor: 'class',\r\n  const: 'constant',\r\n  defaultvalue: 'default',\r\n  desc: 'description',\r\n  emits: 'fires',\r\n  exception: 'throws',\r\n  fileoverview: 'file',\r\n  func: 'function',\r\n  host: 'external',\r\n  linkcode: 'link',\r\n  linkplain: 'link',\r\n  virtual: 'abstract',\r\n  method: 'function',\r\n  overview: 'file',\r\n  prop: 'property',\r\n  return: 'returns',\r\n  var: 'member',\r\n};\r\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 110,
          "column": 2
        },
        "end": {
          "line": 115,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          110,
          115
        ]
      }
    }
  },
  {
    "description": "Normalize the comment tags.",
    "tags": [
      {
        "title": "param",
        "description": "The comment to normalize.",
        "lineNumber": 2,
        "type": null,
        "name": "Array"
      },
      {
        "title": "returns",
        "description": "The comment containing normalized tags.",
        "lineNumber": 3,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      }
    ],
    "loc": {
      "start": {
        "line": 116,
        "column": 2
      },
      "end": {
        "line": 120,
        "column": 5
      }
    },
    "context": {
      "code": "static normalize(comment) {\r\n    return _.assignIn({}, comment, {\r\n      tags: comment.tags.map(tag => {\r\n        let title = tag.title.toLowerCase();\r\n        const canonical = synonyms[title];\r\n        if (!canonical) {\r\n          switch (title[0]) {\r\n            case 'e':\r\n              if (title === 'extend') title = 'extends';\r\n              break;\r\n            case 'j':\r\n              if (title === 'jsfiddles') title = 'jsfiddle';\r\n              break;\r\n            default: break;\r\n          }\r\n        }\r\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\r\n      }),\r\n    });\r\n  }",
      "file": {
        "id": "4yc_7bIZ0l",
        "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
        "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
        "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\javascript\\index.js",
        "source": "'use strict';\r\n\r\nconst Doctrine = require('doctrine');\r\nconst IParser = require('../interface');\r\nconst Engine = require('../../engines/javascript.engine.js');\r\nconst _ = require('lodash');\r\nconst Log = require('mr-doc-utils').Log;\r\nconst log = new Log();\r\nconst synonyms = require('./synonyms.js');\r\n\r\nclass JavaScript extends IParser {\r\n  constructor(options) {\r\n    super(options);\r\n    this.visited = {};\r\n    this.engine = new Engine(this.options);\r\n    this.comments = [];\r\n    this.results = [];\r\n  }\r\n  /**\r\n   * Parse the file.\r\n   * @param {Object} - The file to parse.\r\n   */\r\n  parse(file) {\r\n    this.file = file;\r\n    this.ast = this.engine.parse(this.file);\r\n    // DEBUG: AST\r\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\r\n    [\r\n      { type: 'leadingComments', context: true },\r\n      { type: 'innerComments', context: false },\r\n      { type: 'trailingComments', context: false },\r\n    ].forEach(comment => this.walkComments(comment));\r\n    return this.results;\r\n  }\r\n  /**\r\n   * Walk the comments.\r\n   * @param {Object} - The comment type and context to walk.\r\n   */\r\n  walkComments(comment) {\r\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\r\n        .filter(this.isJSDocComment)\r\n        .forEach(this.parseComment(node, comment.context)));\r\n  }\r\n  /**\r\n   * Parse the comment.\r\n   * @param {Node} - The current node.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseComment(node, includeContext) {\r\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\r\n    range = !range ? node.range : range;\r\n    range = !range ? [node.start, node.end] : range;\r\n    const context = {\r\n      code: null,\r\n      file: this.file,\r\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\r\n      range: {\r\n        column: [node.loc.start.column, node.loc.end.column],\r\n        line: [node.loc.start.line, node.loc.end.line],\r\n      },\r\n    };\r\n    return (comment) => {\r\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\r\n      if (!this.visited[key]) {\r\n        this.visited[key] = true;\r\n        if (includeContext) {\r\n          Object.defineProperty(context, 'ast', {\r\n            enumerable: false,\r\n            value: node,\r\n          });\r\n          context.code = this.file.source.substring.apply(this.file.source, range);\r\n        }\r\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\r\n      }\r\n    };\r\n  }\r\n  /**\r\n   * Parse the JSDoc comment.\r\n   * @param {String} - The comment to parse.\r\n   * @param {Location} - The comment location.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseJSDoc(comment, loc, context) {\r\n    const result = Doctrine.parse(comment, {\r\n      lineNumbers: true,\r\n      recoverable: true,\r\n      sloppy: true,\r\n      unwrap: true,\r\n    });\r\n    result.loc = loc;\r\n    result.context = context;\r\n    result.errors = [];\r\n    let i = 0;\r\n    while (i < result.tags.length) {\r\n      const tag = result.tags[i];\r\n      if (tag.errors) {\r\n        for (let j = 0; j < tag.errors.length; j++) {\r\n          result.errors.push({ message: tag.errors[j] });\r\n        }\r\n        result.tags.splice(i, 1);\r\n      } else i++;\r\n    }\r\n    return JavaScript.normalize(result);\r\n  }\r\n  /**\r\n   * Determine whether the comment is normalized.\r\n   * @param {String} - The comment to determine.\r\n   * @return {Boolean} - The truth value.\r\n   */\r\n  isJSDocComment(comment) {\r\n    const asterisks = comment.value.match(/^(\\*+)/);\r\n    return (comment.type === 'CommentBlock' ||\r\n      comment.type === 'Block')\r\n      && asterisks && asterisks[1].length === 1;\r\n  }\r\n  /**\r\n   * Normalize the comment tags.\r\n   * @param {Array} - The comment to normalize.\r\n   * @return {Array} - The comment containing normalized tags.\r\n   */\r\n  static normalize(comment) {\r\n    return _.assignIn({}, comment, {\r\n      tags: comment.tags.map(tag => {\r\n        let title = tag.title.toLowerCase();\r\n        const canonical = synonyms[title];\r\n        if (!canonical) {\r\n          switch (title[0]) {\r\n            case 'e':\r\n              if (title === 'extend') title = 'extends';\r\n              break;\r\n            case 'j':\r\n              if (title === 'jsfiddles') title = 'jsfiddle';\r\n              break;\r\n            default: break;\r\n          }\r\n        }\r\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\r\n      }),\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = JavaScript;\r\n",
        "ref": [
          {
            "E1_QbLZRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\cli\\index.js",
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\nconst Extension = require('../utils/extension');\r\nconst File = require('fs-extra');\r\nconst Log = require('../utils/log');\r\nconst Liftoff = require('liftoff');\r\nconst Option = require('mr-doc-utils').Option;\r\nconst Path = require('path');\r\nconst Promise = require('bluebird');\r\nconst Yargs = require('yargs');\r\nconst ViynlFS = require('vinyl-fs');\r\nconst isGlob = require('is-glob');\r\nconst log = Log.global();\r\nconst pkg = require('../../package.json');\r\nconst rc = require('rc');\r\nconst _ = require('lodash');\r\n\r\nclass CLI {\r\n  /**\r\n   * Parse the CLI arguments.\r\n   * @static\r\n   */\r\n  static parse() {\r\n    return Yargs\r\n    .usage('Usage: mrdoc [options]', Option.cli())\r\n    .showHelpOnFail(false, 'Specify --help for available options')\r\n    .help('help', log.color.gray('Show help.'))\r\n    .alias('help', 'h')\r\n    .argv;\r\n  }\r\n  /**\r\n   * Create the CLI.\r\n   * @static\r\n   * @return {Liftoff} - An instance of Liftoff.\r\n   */\r\n  static get rocket() {\r\n    // Create the CLI.\r\n    return new Liftoff({\r\n      name: 'mrdoc',\r\n      processTitle: 'mrdoc',\r\n      v8flags: require('v8flags'),\r\n    });\r\n  }\r\n  /**\r\n   * Launch the cli.\r\n   * @static\r\n   * @param {Object} - The parsed CLI arguments.\r\n   * @return {Promise<Stream>} - A promise to the stream.\r\n   */\r\n  static launch(argv) {\r\n    return new Promise((resolve, reject) => {\r\n      // Launch the CLI!\r\n      CLI.rocket.launch({\r\n        cwd: argv.cwd,\r\n        configPath: argv.mrdocrc,\r\n      }, env => CLI.handler(env, argv)\r\n      .then(stream => resolve(stream))\r\n      .catch(error => reject(error)));\r\n    });\r\n  }\r\n  /**\r\n   * Handles the result from the CLI.\r\n   * @static\r\n   */\r\n  static handler(env, options) {\r\n    const version = options.version || options.v;\r\n    const source = options.source || options.s;\r\n    if (version) {\r\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\r\n      process.exit();\r\n    }\r\n    if (_.isEmpty(source) && version === false) {\r\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\r\n      process.exit();\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      // Get the options.\r\n      const opts = rc('mrdoc', Option.merge(options));\r\n      const sources = opts.mrdoc.source.split(',')\r\n      .map(path => path.trim())\r\n      .map(path => {\r\n        // Check if the path is not in glob pattern.\r\n        if (!isGlob(path)) {\r\n          // Make sure the path is resolved.\r\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\r\n          // Check if the path is a file or directory.\r\n          if (_.isEmpty(Path.parse(path).ext)) {\r\n            // Check if the path has a '/' at the end.\r\n            str = str[str.length - 1] === Path.sep ?\r\n            str : `${str}${Path.sep}`;\r\n          }\r\n          // Make sure the file or directory exists;\r\n          if (File.existsSync(str)) {\r\n            // Check if the directory has sub-directories.\r\n            const hasSubDirs = File.readdirSync(str)\r\n            .filter(file =>\r\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\r\n            // Get the file extension.\r\n            const extension = Extension.find(opts.parser.language);\r\n            // Set the glob pattern based on 'hasSubDirs'.\r\n            str = hasSubDirs ?\r\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\r\n          } else return null;\r\n          return str;\r\n        }\r\n        return path;\r\n      });\r\n      // DEBUG: Sources\r\n      log.debug(log.color.blue('Sources:'), sources);\r\n      if (sources.indexOf(null) > -1) {\r\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\r\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = CLI;\r\n"
            }
          },
          {
            "EkedmbI-Rg": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\index.js",
              "source": "'use strict';\r\nconst JSONC = require('./compilers/json/');\r\n// const HTML = require('./compilers/html');\r\n\r\nclass Compiler {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.compiler().file.format) {\r\n      case 'json':\r\n        return (new JSONC(this.options));\r\n      case 'html':\r\n        // return (new HTML(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Compiler;\r\n"
            }
          },
          {
            "VJZdXZU-Ae": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\index.js",
              "source": "'use strict';\r\nconst JavaScript = require('./parsers/javascript/');\r\n\r\nclass Parser {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.parser().language) {\r\n      case 'js':\r\n      case 'javascript':\r\n        return (new JavaScript(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Parser;\r\n"
            }
          },
          {
            "VkzumbIW0x": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\extension.js",
              "source": "'use strict';\r\n\r\nclass Extension {\r\n  static find(language) {\r\n    return Extension.extensions()[language];\r\n  }\r\n  static extensions() {\r\n    return {\r\n      js: '.js',\r\n      javascript: '.js',\r\n      json: '.json',\r\n      html: '.html',\r\n      typescript: '.ts',\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = Extension;\r\n"
            }
          },
          {
            "EJ7uQ-L-Al": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\log.js",
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\n/* eslint-env node */\r\nconst Utils = require('mr-doc-utils');\r\nconst log = new Utils.Log();\r\nconst _ = require('lodash');\r\n\r\nclass Log {\r\n  constructor(options) {\r\n    if (options.silent) {\r\n      log.on('error', () => { /* NOOP */});\r\n      return log;\r\n    }\r\n    this.levels(options.level)\r\n    .forEach(level => {\r\n      if (level === 'error') this.error();\r\n      else this.other(level);\r\n    });\r\n    return log;\r\n  }\r\n  levels(level) {\r\n    const levels = _.isString(level) ? level.split(',') : level;\r\n    return levels\r\n    .map(i => i.replace(/\\s/g, ''));\r\n  }\r\n  error() {\r\n    log.on('error', function error() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args.map(i => log.color.red(i)));\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  other(level) {\r\n    log.on(level, function logger() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args);\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  /**\r\n   * Get the global instance of Log.\r\n   * @return {Log} - An instance of Log.\r\n   */\r\n  static global() {\r\n    log.color = Utils.Log.color;\r\n    return log;\r\n  }\r\n}\r\n\r\nmodule.exports = Log;\r\n"
            }
          },
          {
            "V1V_7WIWAg": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\output.js",
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nconst Option = require('mr-doc-utils').Option;\n\nclass Output {\n  static handler(options, buffer) {\n    const opt = (new Option(options)).options();\n    return function (callback) {\n      Output.format(opt, buffer).forEach(Output.toStream(opt, this));\n      callback();\n    };\n  }\n  static format(options, buffer) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler().file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n\n  static toStream(options, context) {\n    const format = options.compiler().file.format;\n    const file = options.compiler().file;\n    return function (f) {\n      if (format === 'json' || format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "EJSdQZI-Ce": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\utils\\source.js",
              "source": "'use strict';\r\nconst ShortID = require('shortid');\r\nconst File = require('fs-extra');\r\nconst _ = require('lodash');\r\n\r\nclass Source {\r\n  static create(files) {\r\n    // Process the files.\r\n    const result = files\r\n    .map(file => Source.processFile(file));\r\n    // Create references for each file.\r\n    const references = result\r\n    .map(file => Source.createReference(file));\r\n    // Process the references and attach it to each file.\r\n    return result\r\n    .map(file => Source.processReference(file, references));\r\n  }\r\n  static processFile(file) {\r\n    return {\r\n      id: ShortID.generate(),\r\n      cwd: file.cwd,\r\n      base: file.base,\r\n      path: file.path,\r\n      source: File.readFileSync(file.path, 'utf8'),\r\n      comments: undefined,\r\n    };\r\n  }\r\n  static createReference(file) {\r\n    return {\r\n      id: file.id,\r\n      cwd: file.cwd,\r\n      base: file.base,\r\n      path: file.path,\r\n      source: file.source,\r\n      comments: file.comments,\r\n    };\r\n  }\r\n  static processReference(file, references) {\r\n    return _.merge(file, {\r\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = Source;\r\n"
            }
          },
          {
            "VJU_QZUb0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\compilers\\interface.js",
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.compiler() : options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "VyPuX-LbCx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\engines\\javascript.engine.js",
              "source": "'use strict';\r\n\r\nconst Babylon = require('babylon');\r\nconst Acorn = require('acorn');\r\nconst Espree = require('espree');\r\nconst ESCodeGen = require('escodegen');\r\nconst ESTraverse = require('estraverse');\r\nconst traverse = require('babel-traverse').default;\r\n\r\nconst opts = {\r\n  acorn: (version, comments, tokens) => ({\r\n    ecmaVersion: version,\r\n    locations: true,\r\n    onComment: comments,\r\n    onToken: tokens,\r\n    ranges: true,\r\n  }),\r\n  babylon: () => ({\r\n    allowImportExportEverywhere: true,\r\n    plugins: [\r\n      'jsx',\r\n      'flow',\r\n      'asyncFunctions',\r\n      'classConstructorCall',\r\n      'doExpressions',\r\n      'trailingFunctionCommas',\r\n      'objectRestSpread',\r\n      'decorators',\r\n      'classProperties',\r\n      'exportExtensions',\r\n      'exponentiationOperator',\r\n      'asyncGenerators',\r\n      'functionBind',\r\n      'functionSent',\r\n    ],\r\n    sourceType: 'module',\r\n  }),\r\n  espree: (version) => ({\r\n    attachComment: true,\r\n    comment: true,\r\n    ecmaFeatures: {\r\n      experimentalObjectRestSpread: true,\r\n      globalReturn: true,\r\n      impliedStrict: true,\r\n      jsx: true,\r\n    },\r\n    ecmaVersion: version,\r\n    loc: true,\r\n    range: true,\r\n    sourceType: 'module',\r\n    tokens: true,\r\n  }),\r\n};\r\n\r\nclass Engine {\r\n  constructor(options) {\r\n    this.options = options;\r\n    switch (this.options.engine) {\r\n      case 'acorn':\r\n        this.engine = Acorn;\r\n        break;\r\n      case 'espree':\r\n        this.engine = Espree;\r\n        break;\r\n      default:\r\n        this.engine = Babylon;\r\n        break;\r\n    }\r\n  }\r\n  parse(file) {\r\n    const comments = [];\r\n    const tokens = [];\r\n    try {\r\n      switch (this.options.engine) {\r\n        case 'acorn':\r\n          return ESCodeGen\r\n          .attachComments(this.engine.parse(file.source,\r\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\r\n        case 'espree':\r\n          return this.engine.parse(file.source, opts.espree(this.options.version));\r\n        default:\r\n          return this.engine.parse(file.source, opts.babylon());\r\n      }\r\n    } catch (error) {\r\n      throw (new Error(error));\r\n    }\r\n  }\r\n  static traverse(options, ast, callback) {\r\n    switch (options.engine) {\r\n      case 'babylon':\r\n        traverse(ast, {\r\n          enter: (path) => {\r\n            const node = path.node;\r\n            callback(node);\r\n          } });\r\n        break;\r\n      default:\r\n        ESTraverse.traverse(ast, {\r\n          /* eslint-disable no-param-reassign */\r\n          enter: (node) => {\r\n            if (node.type === 'Program') {\r\n              node = node.body[0];\r\n            }\r\n            callback(node);\r\n          } });\r\n          /* eslint-enable no-param-reassign */\r\n        break;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Engine;\r\n"
            }
          },
          {
            "EyudQbUb0e": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\interface.js",
              "source": "'use strict';\r\nclass IParser {\r\n  /**\r\n   * @constructor\r\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\r\n   */\r\n  constructor(options) {\r\n    this.options = options.parser ? options.parser() : options;\r\n  }\r\n  /**\r\n   * Parses the sources' comments into the desired output.\r\n   * @param  {Array<Object>} results - The files to parse.\r\n   * @return {Array<Object>} - The parsed comments.\r\n   */\r\n  /* eslint-disable no-unused-vars */\r\n  parse(sources) {\r\n    // ...\r\n  }\r\n  /* eslint-enable no-unused-vars */\r\n}\r\n\r\nmodule.exports = IParser;\r\n"
            }
          },
          {
            "4JF_XW8Z0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\compiler\\compilers\\json\\index.js",
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "4yc_7bIZ0l": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\javascript\\index.js",
              "source": "'use strict';\r\n\r\nconst Doctrine = require('doctrine');\r\nconst IParser = require('../interface');\r\nconst Engine = require('../../engines/javascript.engine.js');\r\nconst _ = require('lodash');\r\nconst Log = require('mr-doc-utils').Log;\r\nconst log = new Log();\r\nconst synonyms = require('./synonyms.js');\r\n\r\nclass JavaScript extends IParser {\r\n  constructor(options) {\r\n    super(options);\r\n    this.visited = {};\r\n    this.engine = new Engine(this.options);\r\n    this.comments = [];\r\n    this.results = [];\r\n  }\r\n  /**\r\n   * Parse the file.\r\n   * @param {Object} - The file to parse.\r\n   */\r\n  parse(file) {\r\n    this.file = file;\r\n    this.ast = this.engine.parse(this.file);\r\n    // DEBUG: AST\r\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\r\n    [\r\n      { type: 'leadingComments', context: true },\r\n      { type: 'innerComments', context: false },\r\n      { type: 'trailingComments', context: false },\r\n    ].forEach(comment => this.walkComments(comment));\r\n    return this.results;\r\n  }\r\n  /**\r\n   * Walk the comments.\r\n   * @param {Object} - The comment type and context to walk.\r\n   */\r\n  walkComments(comment) {\r\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\r\n        .filter(this.isJSDocComment)\r\n        .forEach(this.parseComment(node, comment.context)));\r\n  }\r\n  /**\r\n   * Parse the comment.\r\n   * @param {Node} - The current node.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseComment(node, includeContext) {\r\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\r\n    range = !range ? node.range : range;\r\n    range = !range ? [node.start, node.end] : range;\r\n    const context = {\r\n      code: null,\r\n      file: this.file,\r\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\r\n      range: {\r\n        column: [node.loc.start.column, node.loc.end.column],\r\n        line: [node.loc.start.line, node.loc.end.line],\r\n      },\r\n    };\r\n    return (comment) => {\r\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\r\n      if (!this.visited[key]) {\r\n        this.visited[key] = true;\r\n        if (includeContext) {\r\n          Object.defineProperty(context, 'ast', {\r\n            enumerable: false,\r\n            value: node,\r\n          });\r\n          context.code = this.file.source.substring.apply(this.file.source, range);\r\n        }\r\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\r\n      }\r\n    };\r\n  }\r\n  /**\r\n   * Parse the JSDoc comment.\r\n   * @param {String} - The comment to parse.\r\n   * @param {Location} - The comment location.\r\n   * @param {Boolean} - The truth value on whether to include the context.\r\n   */\r\n  parseJSDoc(comment, loc, context) {\r\n    const result = Doctrine.parse(comment, {\r\n      lineNumbers: true,\r\n      recoverable: true,\r\n      sloppy: true,\r\n      unwrap: true,\r\n    });\r\n    result.loc = loc;\r\n    result.context = context;\r\n    result.errors = [];\r\n    let i = 0;\r\n    while (i < result.tags.length) {\r\n      const tag = result.tags[i];\r\n      if (tag.errors) {\r\n        for (let j = 0; j < tag.errors.length; j++) {\r\n          result.errors.push({ message: tag.errors[j] });\r\n        }\r\n        result.tags.splice(i, 1);\r\n      } else i++;\r\n    }\r\n    return JavaScript.normalize(result);\r\n  }\r\n  /**\r\n   * Determine whether the comment is normalized.\r\n   * @param {String} - The comment to determine.\r\n   * @return {Boolean} - The truth value.\r\n   */\r\n  isJSDocComment(comment) {\r\n    const asterisks = comment.value.match(/^(\\*+)/);\r\n    return (comment.type === 'CommentBlock' ||\r\n      comment.type === 'Block')\r\n      && asterisks && asterisks[1].length === 1;\r\n  }\r\n  /**\r\n   * Normalize the comment tags.\r\n   * @param {Array} - The comment to normalize.\r\n   * @return {Array} - The comment containing normalized tags.\r\n   */\r\n  static normalize(comment) {\r\n    return _.assignIn({}, comment, {\r\n      tags: comment.tags.map(tag => {\r\n        let title = tag.title.toLowerCase();\r\n        const canonical = synonyms[title];\r\n        if (!canonical) {\r\n          switch (title[0]) {\r\n            case 'e':\r\n              if (title === 'extend') title = 'extends';\r\n              break;\r\n            case 'j':\r\n              if (title === 'jsfiddles') title = 'jsfiddle';\r\n              break;\r\n            default: break;\r\n          }\r\n        }\r\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\r\n      }),\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = JavaScript;\r\n"
            }
          },
          {
            "VkjOmWLbAl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\",
              "path": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc\\src\\parser\\parsers\\javascript\\synonyms.js",
              "source": "module.exports = {\r\n  arg: 'param',\r\n  argument: 'param',\r\n  constructor: 'class',\r\n  const: 'constant',\r\n  defaultvalue: 'default',\r\n  desc: 'description',\r\n  emits: 'fires',\r\n  exception: 'throws',\r\n  fileoverview: 'file',\r\n  func: 'function',\r\n  host: 'external',\r\n  linkcode: 'link',\r\n  linkplain: 'link',\r\n  virtual: 'abstract',\r\n  method: 'function',\r\n  overview: 'file',\r\n  prop: 'property',\r\n  return: 'returns',\r\n  var: 'member',\r\n};\r\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 121,
          "column": 2
        },
        "end": {
          "line": 140,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          121,
          140
        ]
      }
    }
  }
]